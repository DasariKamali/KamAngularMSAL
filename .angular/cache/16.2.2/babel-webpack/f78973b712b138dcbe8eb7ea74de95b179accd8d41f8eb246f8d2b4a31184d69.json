{"ast":null,"code":"/*! @azure/msal-common v14.0.3 2023-09-05 */\n'use strict';\n\nimport { CredentialType, CacheType, Separators, Constants, AuthenticationScheme } from '../../utils/Constants.mjs';\nimport { ClientAuthError } from '../../error/ClientAuthError.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * Base type for credentials to be stored in the cache: eg: ACCESS_TOKEN, ID_TOKEN etc\n *\n * Key:Value Schema:\n *\n * Key: <home_account_id*>-<environment>-<credential_type>-<client_id>-<realm*>-<target*>-<requestedClaims*>-<scheme*>\n *\n * Value Schema:\n * {\n *      homeAccountId: home account identifier for the auth scheme,\n *      environment: entity that issued the token, represented as a full host\n *      credentialType: Type of credential as a string, can be one of the following: RefreshToken, AccessToken, IdToken, Password, Cookie, Certificate, Other\n *      clientId: client ID of the application\n *      secret: Actual credential as a string\n *      familyId: Family ID identifier, usually only used for refresh tokens\n *      realm: Full tenant or organizational identifier that the account belongs to\n *      target: Permissions that are included in the token, or for refresh tokens, the resource identifier.\n *      tokenType: Matches the authentication scheme for which the token was issued (i.e. Bearer or pop)\n *      requestedClaimsHash: Matches the SHA 256 hash of the claims object included in the token request\n *      userAssertionHash: Matches the SHA 256 hash of the obo_assertion for the OBO flow\n * }\n */\nclass CredentialEntity {\n  /**\n   * Generate Account Id key component as per the schema: <home_account_id>-<environment>\n   */\n  generateAccountId() {\n    return CredentialEntity.generateAccountIdForCacheKey(this.homeAccountId, this.environment);\n  }\n  /**\n   * Generate Credential Id key component as per the schema: <credential_type>-<client_id>-<realm>\n   */\n  generateCredentialId() {\n    return CredentialEntity.generateCredentialIdForCacheKey(this.credentialType, this.clientId, this.realm, this.familyId);\n  }\n  /**\n   * Generate target key component as per schema: <target>\n   */\n  generateTarget() {\n    return CredentialEntity.generateTargetForCacheKey(this.target);\n  }\n  /**\n   * generates credential key\n   */\n  generateCredentialKey() {\n    return CredentialEntity.generateCredentialCacheKey(this.homeAccountId, this.environment, this.credentialType, this.clientId, this.realm, this.target, this.familyId, this.tokenType, this.requestedClaimsHash);\n  }\n  /**\n   * returns the type of the cache (in this case credential)\n   */\n  generateType() {\n    switch (this.credentialType) {\n      case CredentialType.ID_TOKEN:\n        return CacheType.ID_TOKEN;\n      case CredentialType.ACCESS_TOKEN:\n      case CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME:\n        return CacheType.ACCESS_TOKEN;\n      case CredentialType.REFRESH_TOKEN:\n        return CacheType.REFRESH_TOKEN;\n      default:\n        {\n          throw ClientAuthError.createUnexpectedCredentialTypeError();\n        }\n    }\n  }\n  /**\n   * generates credential key\n   * <home_account_id*>-\\<environment>-<credential_type>-<client_id>-<realm\\*>-<target\\*>-<scheme\\*>\n   */\n  static generateCredentialCacheKey(homeAccountId, environment, credentialType, clientId, realm, target, familyId, tokenType, requestedClaimsHash) {\n    const credentialKey = [this.generateAccountIdForCacheKey(homeAccountId, environment), this.generateCredentialIdForCacheKey(credentialType, clientId, realm, familyId), this.generateTargetForCacheKey(target), this.generateClaimsHashForCacheKey(requestedClaimsHash), this.generateSchemeForCacheKey(tokenType)];\n    return credentialKey.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();\n  }\n  /**\n   * generates Account Id for keys\n   * @param homeAccountId\n   * @param environment\n   */\n  static generateAccountIdForCacheKey(homeAccountId, environment) {\n    const accountId = [homeAccountId, environment];\n    return accountId.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();\n  }\n  /**\n   * Generates Credential Id for keys\n   * @param credentialType\n   * @param realm\n   * @param clientId\n   * @param familyId\n   */\n  static generateCredentialIdForCacheKey(credentialType, clientId, realm, familyId) {\n    const clientOrFamilyId = credentialType === CredentialType.REFRESH_TOKEN ? familyId || clientId : clientId;\n    const credentialId = [credentialType, clientOrFamilyId, realm || Constants.EMPTY_STRING];\n    return credentialId.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();\n  }\n  /**\n   * Generate target key component as per schema: <target>\n   */\n  static generateTargetForCacheKey(scopes) {\n    return (scopes || Constants.EMPTY_STRING).toLowerCase();\n  }\n  /**\n   * Generate requested claims key component as per schema: <requestedClaims>\n   */\n  static generateClaimsHashForCacheKey(requestedClaimsHash) {\n    return (requestedClaimsHash || Constants.EMPTY_STRING).toLowerCase();\n  }\n  /**\n   * Generate scheme key componenet as per schema: <scheme>\n   */\n  static generateSchemeForCacheKey(tokenType) {\n    /*\n     * PoP Tokens and SSH certs include scheme in cache key\n     * Cast to lowercase to handle \"bearer\" from ADFS\n     */\n    return tokenType && tokenType.toLowerCase() !== AuthenticationScheme.BEARER.toLowerCase() ? tokenType.toLowerCase() : Constants.EMPTY_STRING;\n  }\n}\nexport { CredentialEntity };","map":{"version":3,"names":["CredentialType","CacheType","Separators","Constants","AuthenticationScheme","ClientAuthError","CredentialEntity","generateAccountId","generateAccountIdForCacheKey","homeAccountId","environment","generateCredentialId","generateCredentialIdForCacheKey","credentialType","clientId","realm","familyId","generateTarget","generateTargetForCacheKey","target","generateCredentialKey","generateCredentialCacheKey","tokenType","requestedClaimsHash","generateType","ID_TOKEN","ACCESS_TOKEN","ACCESS_TOKEN_WITH_AUTH_SCHEME","REFRESH_TOKEN","createUnexpectedCredentialTypeError","credentialKey","generateClaimsHashForCacheKey","generateSchemeForCacheKey","join","CACHE_KEY_SEPARATOR","toLowerCase","accountId","clientOrFamilyId","credentialId","EMPTY_STRING","scopes","BEARER"],"sources":["C:/Users/v-dkamali/Documents/AngularMSALAD/microsoft-login/node_modules/@azure/msal-common/dist/cache/entities/CredentialEntity.mjs"],"sourcesContent":["/*! @azure/msal-common v14.0.3 2023-09-05 */\n'use strict';\nimport { CredentialType, CacheType, Separators, Constants, AuthenticationScheme } from '../../utils/Constants.mjs';\nimport { ClientAuthError } from '../../error/ClientAuthError.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * Base type for credentials to be stored in the cache: eg: ACCESS_TOKEN, ID_TOKEN etc\n *\n * Key:Value Schema:\n *\n * Key: <home_account_id*>-<environment>-<credential_type>-<client_id>-<realm*>-<target*>-<requestedClaims*>-<scheme*>\n *\n * Value Schema:\n * {\n *      homeAccountId: home account identifier for the auth scheme,\n *      environment: entity that issued the token, represented as a full host\n *      credentialType: Type of credential as a string, can be one of the following: RefreshToken, AccessToken, IdToken, Password, Cookie, Certificate, Other\n *      clientId: client ID of the application\n *      secret: Actual credential as a string\n *      familyId: Family ID identifier, usually only used for refresh tokens\n *      realm: Full tenant or organizational identifier that the account belongs to\n *      target: Permissions that are included in the token, or for refresh tokens, the resource identifier.\n *      tokenType: Matches the authentication scheme for which the token was issued (i.e. Bearer or pop)\n *      requestedClaimsHash: Matches the SHA 256 hash of the claims object included in the token request\n *      userAssertionHash: Matches the SHA 256 hash of the obo_assertion for the OBO flow\n * }\n */\nclass CredentialEntity {\n    /**\n     * Generate Account Id key component as per the schema: <home_account_id>-<environment>\n     */\n    generateAccountId() {\n        return CredentialEntity.generateAccountIdForCacheKey(this.homeAccountId, this.environment);\n    }\n    /**\n     * Generate Credential Id key component as per the schema: <credential_type>-<client_id>-<realm>\n     */\n    generateCredentialId() {\n        return CredentialEntity.generateCredentialIdForCacheKey(this.credentialType, this.clientId, this.realm, this.familyId);\n    }\n    /**\n     * Generate target key component as per schema: <target>\n     */\n    generateTarget() {\n        return CredentialEntity.generateTargetForCacheKey(this.target);\n    }\n    /**\n     * generates credential key\n     */\n    generateCredentialKey() {\n        return CredentialEntity.generateCredentialCacheKey(this.homeAccountId, this.environment, this.credentialType, this.clientId, this.realm, this.target, this.familyId, this.tokenType, this.requestedClaimsHash);\n    }\n    /**\n     * returns the type of the cache (in this case credential)\n     */\n    generateType() {\n        switch (this.credentialType) {\n            case CredentialType.ID_TOKEN:\n                return CacheType.ID_TOKEN;\n            case CredentialType.ACCESS_TOKEN:\n            case CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME:\n                return CacheType.ACCESS_TOKEN;\n            case CredentialType.REFRESH_TOKEN:\n                return CacheType.REFRESH_TOKEN;\n            default: {\n                throw ClientAuthError.createUnexpectedCredentialTypeError();\n            }\n        }\n    }\n    /**\n     * generates credential key\n     * <home_account_id*>-\\<environment>-<credential_type>-<client_id>-<realm\\*>-<target\\*>-<scheme\\*>\n     */\n    static generateCredentialCacheKey(homeAccountId, environment, credentialType, clientId, realm, target, familyId, tokenType, requestedClaimsHash) {\n        const credentialKey = [\n            this.generateAccountIdForCacheKey(homeAccountId, environment),\n            this.generateCredentialIdForCacheKey(credentialType, clientId, realm, familyId),\n            this.generateTargetForCacheKey(target),\n            this.generateClaimsHashForCacheKey(requestedClaimsHash),\n            this.generateSchemeForCacheKey(tokenType),\n        ];\n        return credentialKey.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();\n    }\n    /**\n     * generates Account Id for keys\n     * @param homeAccountId\n     * @param environment\n     */\n    static generateAccountIdForCacheKey(homeAccountId, environment) {\n        const accountId = [homeAccountId, environment];\n        return accountId.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();\n    }\n    /**\n     * Generates Credential Id for keys\n     * @param credentialType\n     * @param realm\n     * @param clientId\n     * @param familyId\n     */\n    static generateCredentialIdForCacheKey(credentialType, clientId, realm, familyId) {\n        const clientOrFamilyId = credentialType === CredentialType.REFRESH_TOKEN\n            ? familyId || clientId\n            : clientId;\n        const credentialId = [\n            credentialType,\n            clientOrFamilyId,\n            realm || Constants.EMPTY_STRING,\n        ];\n        return credentialId.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();\n    }\n    /**\n     * Generate target key component as per schema: <target>\n     */\n    static generateTargetForCacheKey(scopes) {\n        return (scopes || Constants.EMPTY_STRING).toLowerCase();\n    }\n    /**\n     * Generate requested claims key component as per schema: <requestedClaims>\n     */\n    static generateClaimsHashForCacheKey(requestedClaimsHash) {\n        return (requestedClaimsHash || Constants.EMPTY_STRING).toLowerCase();\n    }\n    /**\n     * Generate scheme key componenet as per schema: <scheme>\n     */\n    static generateSchemeForCacheKey(tokenType) {\n        /*\n         * PoP Tokens and SSH certs include scheme in cache key\n         * Cast to lowercase to handle \"bearer\" from ADFS\n         */\n        return tokenType &&\n            tokenType.toLowerCase() !==\n                AuthenticationScheme.BEARER.toLowerCase()\n            ? tokenType.toLowerCase()\n            : Constants.EMPTY_STRING;\n    }\n}\n\nexport { CredentialEntity };\n"],"mappings":"AAAA;AACA,YAAY;;AACZ,SAASA,cAAc,EAAEC,SAAS,EAAEC,UAAU,EAAEC,SAAS,EAAEC,oBAAoB,QAAQ,2BAA2B;AAClH,SAASC,eAAe,QAAQ,iCAAiC;;AAEjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,gBAAgB,CAAC;EACnB;AACJ;AACA;EACIC,iBAAiBA,CAAA,EAAG;IAChB,OAAOD,gBAAgB,CAACE,4BAA4B,CAAC,IAAI,CAACC,aAAa,EAAE,IAAI,CAACC,WAAW,CAAC;EAC9F;EACA;AACJ;AACA;EACIC,oBAAoBA,CAAA,EAAG;IACnB,OAAOL,gBAAgB,CAACM,+BAA+B,CAAC,IAAI,CAACC,cAAc,EAAE,IAAI,CAACC,QAAQ,EAAE,IAAI,CAACC,KAAK,EAAE,IAAI,CAACC,QAAQ,CAAC;EAC1H;EACA;AACJ;AACA;EACIC,cAAcA,CAAA,EAAG;IACb,OAAOX,gBAAgB,CAACY,yBAAyB,CAAC,IAAI,CAACC,MAAM,CAAC;EAClE;EACA;AACJ;AACA;EACIC,qBAAqBA,CAAA,EAAG;IACpB,OAAOd,gBAAgB,CAACe,0BAA0B,CAAC,IAAI,CAACZ,aAAa,EAAE,IAAI,CAACC,WAAW,EAAE,IAAI,CAACG,cAAc,EAAE,IAAI,CAACC,QAAQ,EAAE,IAAI,CAACC,KAAK,EAAE,IAAI,CAACI,MAAM,EAAE,IAAI,CAACH,QAAQ,EAAE,IAAI,CAACM,SAAS,EAAE,IAAI,CAACC,mBAAmB,CAAC;EAClN;EACA;AACJ;AACA;EACIC,YAAYA,CAAA,EAAG;IACX,QAAQ,IAAI,CAACX,cAAc;MACvB,KAAKb,cAAc,CAACyB,QAAQ;QACxB,OAAOxB,SAAS,CAACwB,QAAQ;MAC7B,KAAKzB,cAAc,CAAC0B,YAAY;MAChC,KAAK1B,cAAc,CAAC2B,6BAA6B;QAC7C,OAAO1B,SAAS,CAACyB,YAAY;MACjC,KAAK1B,cAAc,CAAC4B,aAAa;QAC7B,OAAO3B,SAAS,CAAC2B,aAAa;MAClC;QAAS;UACL,MAAMvB,eAAe,CAACwB,mCAAmC,CAAC,CAAC;QAC/D;IACJ;EACJ;EACA;AACJ;AACA;AACA;EACI,OAAOR,0BAA0BA,CAACZ,aAAa,EAAEC,WAAW,EAAEG,cAAc,EAAEC,QAAQ,EAAEC,KAAK,EAAEI,MAAM,EAAEH,QAAQ,EAAEM,SAAS,EAAEC,mBAAmB,EAAE;IAC7I,MAAMO,aAAa,GAAG,CAClB,IAAI,CAACtB,4BAA4B,CAACC,aAAa,EAAEC,WAAW,CAAC,EAC7D,IAAI,CAACE,+BAA+B,CAACC,cAAc,EAAEC,QAAQ,EAAEC,KAAK,EAAEC,QAAQ,CAAC,EAC/E,IAAI,CAACE,yBAAyB,CAACC,MAAM,CAAC,EACtC,IAAI,CAACY,6BAA6B,CAACR,mBAAmB,CAAC,EACvD,IAAI,CAACS,yBAAyB,CAACV,SAAS,CAAC,CAC5C;IACD,OAAOQ,aAAa,CAACG,IAAI,CAAC/B,UAAU,CAACgC,mBAAmB,CAAC,CAACC,WAAW,CAAC,CAAC;EAC3E;EACA;AACJ;AACA;AACA;AACA;EACI,OAAO3B,4BAA4BA,CAACC,aAAa,EAAEC,WAAW,EAAE;IAC5D,MAAM0B,SAAS,GAAG,CAAC3B,aAAa,EAAEC,WAAW,CAAC;IAC9C,OAAO0B,SAAS,CAACH,IAAI,CAAC/B,UAAU,CAACgC,mBAAmB,CAAC,CAACC,WAAW,CAAC,CAAC;EACvE;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACI,OAAOvB,+BAA+BA,CAACC,cAAc,EAAEC,QAAQ,EAAEC,KAAK,EAAEC,QAAQ,EAAE;IAC9E,MAAMqB,gBAAgB,GAAGxB,cAAc,KAAKb,cAAc,CAAC4B,aAAa,GAClEZ,QAAQ,IAAIF,QAAQ,GACpBA,QAAQ;IACd,MAAMwB,YAAY,GAAG,CACjBzB,cAAc,EACdwB,gBAAgB,EAChBtB,KAAK,IAAIZ,SAAS,CAACoC,YAAY,CAClC;IACD,OAAOD,YAAY,CAACL,IAAI,CAAC/B,UAAU,CAACgC,mBAAmB,CAAC,CAACC,WAAW,CAAC,CAAC;EAC1E;EACA;AACJ;AACA;EACI,OAAOjB,yBAAyBA,CAACsB,MAAM,EAAE;IACrC,OAAO,CAACA,MAAM,IAAIrC,SAAS,CAACoC,YAAY,EAAEJ,WAAW,CAAC,CAAC;EAC3D;EACA;AACJ;AACA;EACI,OAAOJ,6BAA6BA,CAACR,mBAAmB,EAAE;IACtD,OAAO,CAACA,mBAAmB,IAAIpB,SAAS,CAACoC,YAAY,EAAEJ,WAAW,CAAC,CAAC;EACxE;EACA;AACJ;AACA;EACI,OAAOH,yBAAyBA,CAACV,SAAS,EAAE;IACxC;AACR;AACA;AACA;IACQ,OAAOA,SAAS,IACZA,SAAS,CAACa,WAAW,CAAC,CAAC,KACnB/B,oBAAoB,CAACqC,MAAM,CAACN,WAAW,CAAC,CAAC,GAC3Cb,SAAS,CAACa,WAAW,CAAC,CAAC,GACvBhC,SAAS,CAACoC,YAAY;EAChC;AACJ;AAEA,SAASjC,gBAAgB"},"metadata":{},"sourceType":"module","externalDependencies":[]}