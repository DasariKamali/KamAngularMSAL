{"ast":null,"code":"/*! @azure/msal-browser v3.1.0 2023-09-05 */\n'use strict';\n\nimport _asyncToGenerator from \"C:/Users/v-dkamali/Documents/AngularMSALAD/microsoft-login/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { BrowserAuthError } from '../error/BrowserAuthError.mjs';\nimport { DatabaseStorage } from './DatabaseStorage.mjs';\nimport { MemoryStorage } from './MemoryStorage.mjs';\nimport { databaseUnavailable } from '../error/BrowserAuthErrorCodes.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * This class allows MSAL to store artifacts asynchronously using the DatabaseStorage IndexedDB wrapper,\n * backed up with the more volatile MemoryStorage object for cases in which IndexedDB may be unavailable.\n */\nclass AsyncMemoryStorage {\n  constructor(logger, storeName) {\n    this.inMemoryCache = new MemoryStorage();\n    this.indexedDBCache = new DatabaseStorage();\n    this.logger = logger;\n    this.storeName = storeName;\n  }\n  handleDatabaseAccessError(error) {\n    if (error instanceof BrowserAuthError && error.errorCode === databaseUnavailable) {\n      this.logger.error(\"Could not access persistent storage. This may be caused by browser privacy features which block persistent storage in third-party contexts.\");\n    } else {\n      throw error;\n    }\n  }\n  /**\n   * Get the item matching the given key. Tries in-memory cache first, then in the asynchronous\n   * storage object if item isn't found in-memory.\n   * @param key\n   */\n  getItem(key) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const item = _this.inMemoryCache.getItem(key);\n      if (!item) {\n        try {\n          _this.logger.verbose(\"Queried item not found in in-memory cache, now querying persistent storage.\");\n          return yield _this.indexedDBCache.getItem(key);\n        } catch (e) {\n          _this.handleDatabaseAccessError(e);\n        }\n      }\n      return item;\n    })();\n  }\n  /**\n   * Sets the item in the in-memory cache and then tries to set it in the asynchronous\n   * storage object with the given key.\n   * @param key\n   * @param value\n   */\n  setItem(key, value) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      _this2.inMemoryCache.setItem(key, value);\n      try {\n        yield _this2.indexedDBCache.setItem(key, value);\n      } catch (e) {\n        _this2.handleDatabaseAccessError(e);\n      }\n    })();\n  }\n  /**\n   * Removes the item matching the key from the in-memory cache, then tries to remove it from the asynchronous storage object.\n   * @param key\n   */\n  removeItem(key) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      _this3.inMemoryCache.removeItem(key);\n      try {\n        yield _this3.indexedDBCache.removeItem(key);\n      } catch (e) {\n        _this3.handleDatabaseAccessError(e);\n      }\n    })();\n  }\n  /**\n   * Get all the keys from the in-memory cache as an iterable array of strings. If no keys are found, query the keys in the\n   * asynchronous storage object.\n   */\n  getKeys() {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const cacheKeys = _this4.inMemoryCache.getKeys();\n      if (cacheKeys.length === 0) {\n        try {\n          _this4.logger.verbose(\"In-memory cache is empty, now querying persistent storage.\");\n          return yield _this4.indexedDBCache.getKeys();\n        } catch (e) {\n          _this4.handleDatabaseAccessError(e);\n        }\n      }\n      return cacheKeys;\n    })();\n  }\n  /**\n   * Returns true or false if the given key is present in the cache.\n   * @param key\n   */\n  containsKey(key) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const containsKey = _this5.inMemoryCache.containsKey(key);\n      if (!containsKey) {\n        try {\n          _this5.logger.verbose(\"Key not found in in-memory cache, now querying persistent storage.\");\n          return yield _this5.indexedDBCache.containsKey(key);\n        } catch (e) {\n          _this5.handleDatabaseAccessError(e);\n        }\n      }\n      return containsKey;\n    })();\n  }\n  /**\n   * Clears in-memory Map\n   */\n  clearInMemory() {\n    // InMemory cache is a Map instance, clear is straightforward\n    this.logger.verbose(`Deleting in-memory keystore ${this.storeName}`);\n    this.inMemoryCache.clear();\n    this.logger.verbose(`In-memory keystore ${this.storeName} deleted`);\n  }\n  /**\n   * Tries to delete the IndexedDB database\n   * @returns\n   */\n  clearPersistent() {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        _this6.logger.verbose(\"Deleting persistent keystore\");\n        const dbDeleted = yield _this6.indexedDBCache.deleteDatabase();\n        if (dbDeleted) {\n          _this6.logger.verbose(\"Persistent keystore deleted\");\n        }\n        return dbDeleted;\n      } catch (e) {\n        _this6.handleDatabaseAccessError(e);\n        return false;\n      }\n    })();\n  }\n}\nexport { AsyncMemoryStorage };","map":{"version":3,"names":["_asyncToGenerator","BrowserAuthError","DatabaseStorage","MemoryStorage","databaseUnavailable","AsyncMemoryStorage","constructor","logger","storeName","inMemoryCache","indexedDBCache","handleDatabaseAccessError","error","errorCode","getItem","key","_this","item","verbose","e","setItem","value","_this2","removeItem","_this3","getKeys","_this4","cacheKeys","length","containsKey","_this5","clearInMemory","clear","clearPersistent","_this6","dbDeleted","deleteDatabase"],"sources":["C:/Users/v-dkamali/Documents/AngularMSALAD/microsoft-login/node_modules/@azure/msal-browser/dist/cache/AsyncMemoryStorage.mjs"],"sourcesContent":["/*! @azure/msal-browser v3.1.0 2023-09-05 */\n'use strict';\nimport { BrowserAuthError } from '../error/BrowserAuthError.mjs';\nimport { DatabaseStorage } from './DatabaseStorage.mjs';\nimport { MemoryStorage } from './MemoryStorage.mjs';\nimport { databaseUnavailable } from '../error/BrowserAuthErrorCodes.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * This class allows MSAL to store artifacts asynchronously using the DatabaseStorage IndexedDB wrapper,\n * backed up with the more volatile MemoryStorage object for cases in which IndexedDB may be unavailable.\n */\nclass AsyncMemoryStorage {\n    constructor(logger, storeName) {\n        this.inMemoryCache = new MemoryStorage();\n        this.indexedDBCache = new DatabaseStorage();\n        this.logger = logger;\n        this.storeName = storeName;\n    }\n    handleDatabaseAccessError(error) {\n        if (error instanceof BrowserAuthError &&\n            error.errorCode === databaseUnavailable) {\n            this.logger.error(\"Could not access persistent storage. This may be caused by browser privacy features which block persistent storage in third-party contexts.\");\n        }\n        else {\n            throw error;\n        }\n    }\n    /**\n     * Get the item matching the given key. Tries in-memory cache first, then in the asynchronous\n     * storage object if item isn't found in-memory.\n     * @param key\n     */\n    async getItem(key) {\n        const item = this.inMemoryCache.getItem(key);\n        if (!item) {\n            try {\n                this.logger.verbose(\"Queried item not found in in-memory cache, now querying persistent storage.\");\n                return await this.indexedDBCache.getItem(key);\n            }\n            catch (e) {\n                this.handleDatabaseAccessError(e);\n            }\n        }\n        return item;\n    }\n    /**\n     * Sets the item in the in-memory cache and then tries to set it in the asynchronous\n     * storage object with the given key.\n     * @param key\n     * @param value\n     */\n    async setItem(key, value) {\n        this.inMemoryCache.setItem(key, value);\n        try {\n            await this.indexedDBCache.setItem(key, value);\n        }\n        catch (e) {\n            this.handleDatabaseAccessError(e);\n        }\n    }\n    /**\n     * Removes the item matching the key from the in-memory cache, then tries to remove it from the asynchronous storage object.\n     * @param key\n     */\n    async removeItem(key) {\n        this.inMemoryCache.removeItem(key);\n        try {\n            await this.indexedDBCache.removeItem(key);\n        }\n        catch (e) {\n            this.handleDatabaseAccessError(e);\n        }\n    }\n    /**\n     * Get all the keys from the in-memory cache as an iterable array of strings. If no keys are found, query the keys in the\n     * asynchronous storage object.\n     */\n    async getKeys() {\n        const cacheKeys = this.inMemoryCache.getKeys();\n        if (cacheKeys.length === 0) {\n            try {\n                this.logger.verbose(\"In-memory cache is empty, now querying persistent storage.\");\n                return await this.indexedDBCache.getKeys();\n            }\n            catch (e) {\n                this.handleDatabaseAccessError(e);\n            }\n        }\n        return cacheKeys;\n    }\n    /**\n     * Returns true or false if the given key is present in the cache.\n     * @param key\n     */\n    async containsKey(key) {\n        const containsKey = this.inMemoryCache.containsKey(key);\n        if (!containsKey) {\n            try {\n                this.logger.verbose(\"Key not found in in-memory cache, now querying persistent storage.\");\n                return await this.indexedDBCache.containsKey(key);\n            }\n            catch (e) {\n                this.handleDatabaseAccessError(e);\n            }\n        }\n        return containsKey;\n    }\n    /**\n     * Clears in-memory Map\n     */\n    clearInMemory() {\n        // InMemory cache is a Map instance, clear is straightforward\n        this.logger.verbose(`Deleting in-memory keystore ${this.storeName}`);\n        this.inMemoryCache.clear();\n        this.logger.verbose(`In-memory keystore ${this.storeName} deleted`);\n    }\n    /**\n     * Tries to delete the IndexedDB database\n     * @returns\n     */\n    async clearPersistent() {\n        try {\n            this.logger.verbose(\"Deleting persistent keystore\");\n            const dbDeleted = await this.indexedDBCache.deleteDatabase();\n            if (dbDeleted) {\n                this.logger.verbose(\"Persistent keystore deleted\");\n            }\n            return dbDeleted;\n        }\n        catch (e) {\n            this.handleDatabaseAccessError(e);\n            return false;\n        }\n    }\n}\n\nexport { AsyncMemoryStorage };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}