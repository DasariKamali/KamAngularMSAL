{"ast":null,"code":"/*! @azure/msal-common v14.0.3 2023-09-05 */\n'use strict';\n\nimport _asyncToGenerator from \"C:/Users/v-dkamali/Documents/AngularMSALAD/microsoft-login/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { Separators, CredentialType, AuthenticationScheme, THE_FAMILY_ID, APP_METADATA, AUTHORITY_METADATA_CONSTANTS } from '../utils/Constants.mjs';\nimport { ScopeSet } from '../request/ScopeSet.mjs';\nimport { AccountEntity } from './entities/AccountEntity.mjs';\nimport { AuthError } from '../error/AuthError.mjs';\nimport { ClientAuthError } from '../error/ClientAuthError.mjs';\nimport { extractTokenClaims } from '../account/AuthToken.mjs';\nimport { name, version } from '../packageMetadata.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * Interface class which implement cache storage functions used by MSAL to perform validity checks, and store tokens.\n * @internal\n */\nclass CacheManager {\n  constructor(clientId, cryptoImpl, logger) {\n    this.clientId = clientId;\n    this.cryptoImpl = cryptoImpl;\n    this.commonLogger = logger.clone(name, version);\n  }\n  /**\n   * Returns all accounts in cache\n   */\n  getAllAccounts() {\n    const allAccountKeys = this.getAccountKeys();\n    if (allAccountKeys.length < 1) {\n      return [];\n    }\n    const accountEntities = allAccountKeys.reduce((accounts, key) => {\n      const entity = this.getAccount(key);\n      if (!entity) {\n        return accounts;\n      }\n      accounts.push(entity);\n      return accounts;\n    }, []);\n    if (accountEntities.length < 1) {\n      return [];\n    } else {\n      const allAccounts = accountEntities.map(accountEntity => {\n        return this.getAccountInfoFromEntity(accountEntity);\n      });\n      return allAccounts;\n    }\n  }\n  /**\n   * Gets accountInfo object based on provided filters\n   */\n  getAccountInfoFilteredBy(accountFilter) {\n    const allAccounts = this.getAccountsFilteredBy(accountFilter);\n    if (allAccounts.length > 0) {\n      return this.getAccountInfoFromEntity(allAccounts[0]);\n    } else {\n      return null;\n    }\n  }\n  getAccountInfoFromEntity(accountEntity) {\n    const accountInfo = accountEntity.getAccountInfo();\n    const idToken = this.getIdToken(accountInfo);\n    if (idToken) {\n      accountInfo.idToken = idToken.secret;\n      accountInfo.idTokenClaims = extractTokenClaims(idToken.secret, this.cryptoImpl.base64Decode);\n    }\n    return accountInfo;\n  }\n  /**\n   * saves a cache record\n   * @param cacheRecord\n   */\n  saveCacheRecord(cacheRecord, storeInCache) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      if (!cacheRecord) {\n        throw ClientAuthError.createNullOrUndefinedCacheRecord();\n      }\n      if (!!cacheRecord.account) {\n        _this.setAccount(cacheRecord.account);\n      }\n      if (!!cacheRecord.idToken && storeInCache?.idToken !== false) {\n        _this.setIdTokenCredential(cacheRecord.idToken);\n      }\n      if (!!cacheRecord.accessToken && storeInCache?.accessToken !== false) {\n        yield _this.saveAccessToken(cacheRecord.accessToken);\n      }\n      if (!!cacheRecord.refreshToken && storeInCache?.refreshToken !== false) {\n        _this.setRefreshTokenCredential(cacheRecord.refreshToken);\n      }\n      if (!!cacheRecord.appMetadata) {\n        _this.setAppMetadata(cacheRecord.appMetadata);\n      }\n    })();\n  }\n  /**\n   * saves access token credential\n   * @param credential\n   */\n  saveAccessToken(credential) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const accessTokenFilter = {\n        clientId: credential.clientId,\n        credentialType: credential.credentialType,\n        environment: credential.environment,\n        homeAccountId: credential.homeAccountId,\n        realm: credential.realm,\n        tokenType: credential.tokenType,\n        requestedClaimsHash: credential.requestedClaimsHash\n      };\n      const tokenKeys = _this2.getTokenKeys();\n      const currentScopes = ScopeSet.fromString(credential.target);\n      const removedAccessTokens = [];\n      tokenKeys.accessToken.forEach(key => {\n        if (!_this2.accessTokenKeyMatchesFilter(key, accessTokenFilter, false)) {\n          return;\n        }\n        const tokenEntity = _this2.getAccessTokenCredential(key);\n        if (tokenEntity && _this2.credentialMatchesFilter(tokenEntity, accessTokenFilter)) {\n          const tokenScopeSet = ScopeSet.fromString(tokenEntity.target);\n          if (tokenScopeSet.intersectingScopeSets(currentScopes)) {\n            removedAccessTokens.push(_this2.removeAccessToken(key));\n          }\n        }\n      });\n      yield Promise.all(removedAccessTokens);\n      _this2.setAccessTokenCredential(credential);\n    })();\n  }\n  /**\n   * retrieve accounts matching all provided filters; if no filter is set, get all accounts\n   * not checking for casing as keys are all generated in lower case, remember to convert to lower case if object properties are compared\n   * @param homeAccountId\n   * @param environment\n   * @param realm\n   */\n  getAccountsFilteredBy(accountFilter) {\n    const allAccountKeys = this.getAccountKeys();\n    const matchingAccounts = [];\n    allAccountKeys.forEach(cacheKey => {\n      if (!this.isAccountKey(cacheKey, accountFilter.homeAccountId, accountFilter.realm)) {\n        // Don't parse value if the key doesn't match the account filters\n        return;\n      }\n      const entity = this.getAccount(cacheKey);\n      if (!entity) {\n        return;\n      }\n      if (!!accountFilter.homeAccountId && !this.matchHomeAccountId(entity, accountFilter.homeAccountId)) {\n        return;\n      }\n      if (!!accountFilter.localAccountId && !this.matchLocalAccountId(entity, accountFilter.localAccountId)) {\n        return;\n      }\n      if (!!accountFilter.username && !this.matchUsername(entity, accountFilter.username)) {\n        return;\n      }\n      if (!!accountFilter.environment && !this.matchEnvironment(entity, accountFilter.environment)) {\n        return;\n      }\n      if (!!accountFilter.realm && !this.matchRealm(entity, accountFilter.realm)) {\n        return;\n      }\n      if (!!accountFilter.nativeAccountId && !this.matchNativeAccountId(entity, accountFilter.nativeAccountId)) {\n        return;\n      }\n      matchingAccounts.push(entity);\n    });\n    return matchingAccounts;\n  }\n  /**\n   * Returns true if the given key matches our account key schema. Also matches homeAccountId and/or tenantId if provided\n   * @param key\n   * @param homeAccountId\n   * @param tenantId\n   * @returns\n   */\n  isAccountKey(key, homeAccountId, tenantId) {\n    if (key.split(Separators.CACHE_KEY_SEPARATOR).length < 3) {\n      // Account cache keys contain 3 items separated by '-' (each item may also contain '-')\n      return false;\n    }\n    if (homeAccountId && !key.toLowerCase().includes(homeAccountId.toLowerCase())) {\n      return false;\n    }\n    if (tenantId && !key.toLowerCase().includes(tenantId.toLowerCase())) {\n      return false;\n    }\n    // Do not check environment as aliasing can cause false negatives\n    return true;\n  }\n  /**\n   * Returns true if the given key matches our credential key schema.\n   * @param key\n   */\n  isCredentialKey(key) {\n    if (key.split(Separators.CACHE_KEY_SEPARATOR).length < 6) {\n      // Credential cache keys contain 6 items separated by '-' (each item may also contain '-')\n      return false;\n    }\n    const lowerCaseKey = key.toLowerCase();\n    // Credential keys must indicate what credential type they represent\n    if (lowerCaseKey.indexOf(CredentialType.ID_TOKEN.toLowerCase()) === -1 && lowerCaseKey.indexOf(CredentialType.ACCESS_TOKEN.toLowerCase()) === -1 && lowerCaseKey.indexOf(CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME.toLowerCase()) === -1 && lowerCaseKey.indexOf(CredentialType.REFRESH_TOKEN.toLowerCase()) === -1) {\n      return false;\n    }\n    if (lowerCaseKey.indexOf(CredentialType.REFRESH_TOKEN.toLowerCase()) > -1) {\n      // Refresh tokens must contain the client id or family id\n      const clientIdValidation = `${CredentialType.REFRESH_TOKEN}${Separators.CACHE_KEY_SEPARATOR}${this.clientId}${Separators.CACHE_KEY_SEPARATOR}`;\n      const familyIdValidation = `${CredentialType.REFRESH_TOKEN}${Separators.CACHE_KEY_SEPARATOR}${THE_FAMILY_ID}${Separators.CACHE_KEY_SEPARATOR}`;\n      if (lowerCaseKey.indexOf(clientIdValidation.toLowerCase()) === -1 && lowerCaseKey.indexOf(familyIdValidation.toLowerCase()) === -1) {\n        return false;\n      }\n    } else if (lowerCaseKey.indexOf(this.clientId.toLowerCase()) === -1) {\n      // Tokens must contain the clientId\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Returns whether or not the given credential entity matches the filter\n   * @param entity\n   * @param filter\n   * @returns\n   */\n  credentialMatchesFilter(entity, filter) {\n    if (!!filter.clientId && !this.matchClientId(entity, filter.clientId)) {\n      return false;\n    }\n    if (!!filter.userAssertionHash && !this.matchUserAssertionHash(entity, filter.userAssertionHash)) {\n      return false;\n    }\n    /*\n     * homeAccountId can be undefined, and we want to filter out cached items that have a homeAccountId of \"\"\n     * because we don't want a client_credential request to return a cached token that has a homeAccountId\n     */\n    if (typeof filter.homeAccountId === \"string\" && !this.matchHomeAccountId(entity, filter.homeAccountId)) {\n      return false;\n    }\n    if (!!filter.environment && !this.matchEnvironment(entity, filter.environment)) {\n      return false;\n    }\n    if (!!filter.realm && !this.matchRealm(entity, filter.realm)) {\n      return false;\n    }\n    if (!!filter.credentialType && !this.matchCredentialType(entity, filter.credentialType)) {\n      return false;\n    }\n    if (!!filter.familyId && !this.matchFamilyId(entity, filter.familyId)) {\n      return false;\n    }\n    /*\n     * idTokens do not have \"target\", target specific refreshTokens do exist for some types of authentication\n     * Resource specific refresh tokens case will be added when the support is deemed necessary\n     */\n    if (!!filter.target && !this.matchTarget(entity, filter.target)) {\n      return false;\n    }\n    // If request OR cached entity has requested Claims Hash, check if they match\n    if (filter.requestedClaimsHash || entity.requestedClaimsHash) {\n      // Don't match if either is undefined or they are different\n      if (entity.requestedClaimsHash !== filter.requestedClaimsHash) {\n        return false;\n      }\n    }\n    // Access Token with Auth Scheme specific matching\n    if (entity.credentialType === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME) {\n      if (!!filter.tokenType && !this.matchTokenType(entity, filter.tokenType)) {\n        return false;\n      }\n      // KeyId (sshKid) in request must match cached SSH certificate keyId because SSH cert is bound to a specific key\n      if (filter.tokenType === AuthenticationScheme.SSH) {\n        if (filter.keyId && !this.matchKeyId(entity, filter.keyId)) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n  /**\n   * retrieve appMetadata matching all provided filters; if no filter is set, get all appMetadata\n   * @param filter\n   */\n  getAppMetadataFilteredBy(filter) {\n    return this.getAppMetadataFilteredByInternal(filter.environment, filter.clientId);\n  }\n  /**\n   * Support function to help match appMetadata\n   * @param environment\n   * @param clientId\n   */\n  getAppMetadataFilteredByInternal(environment, clientId) {\n    const allCacheKeys = this.getKeys();\n    const matchingAppMetadata = {};\n    allCacheKeys.forEach(cacheKey => {\n      // don't parse any non-appMetadata type cache entities\n      if (!this.isAppMetadata(cacheKey)) {\n        return;\n      }\n      // Attempt retrieval\n      const entity = this.getAppMetadata(cacheKey);\n      if (!entity) {\n        return;\n      }\n      if (!!environment && !this.matchEnvironment(entity, environment)) {\n        return;\n      }\n      if (!!clientId && !this.matchClientId(entity, clientId)) {\n        return;\n      }\n      matchingAppMetadata[cacheKey] = entity;\n    });\n    return matchingAppMetadata;\n  }\n  /**\n   * retrieve authorityMetadata that contains a matching alias\n   * @param filter\n   */\n  getAuthorityMetadataByAlias(host) {\n    const allCacheKeys = this.getAuthorityMetadataKeys();\n    let matchedEntity = null;\n    allCacheKeys.forEach(cacheKey => {\n      // don't parse any non-authorityMetadata type cache entities\n      if (!this.isAuthorityMetadata(cacheKey) || cacheKey.indexOf(this.clientId) === -1) {\n        return;\n      }\n      // Attempt retrieval\n      const entity = this.getAuthorityMetadata(cacheKey);\n      if (!entity) {\n        return;\n      }\n      if (entity.aliases.indexOf(host) === -1) {\n        return;\n      }\n      matchedEntity = entity;\n    });\n    return matchedEntity;\n  }\n  /**\n   * Removes all accounts and related tokens from cache.\n   */\n  removeAllAccounts() {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const allAccountKeys = _this3.getAccountKeys();\n      const removedAccounts = [];\n      allAccountKeys.forEach(cacheKey => {\n        removedAccounts.push(_this3.removeAccount(cacheKey));\n      });\n      yield Promise.all(removedAccounts);\n    })();\n  }\n  /**\n   * Removes the account and related tokens for a given account key\n   * @param account\n   */\n  removeAccount(accountKey) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const account = _this4.getAccount(accountKey);\n      if (!account) {\n        return;\n      }\n      yield _this4.removeAccountContext(account);\n      _this4.removeItem(accountKey);\n    })();\n  }\n  /**\n   * Removes credentials associated with the provided account\n   * @param account\n   */\n  removeAccountContext(account) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const allTokenKeys = _this5.getTokenKeys();\n      const accountId = account.generateAccountId();\n      const removedCredentials = [];\n      allTokenKeys.idToken.forEach(key => {\n        if (key.indexOf(accountId) === 0) {\n          _this5.removeIdToken(key);\n        }\n      });\n      allTokenKeys.accessToken.forEach(key => {\n        if (key.indexOf(accountId) === 0) {\n          removedCredentials.push(_this5.removeAccessToken(key));\n        }\n      });\n      allTokenKeys.refreshToken.forEach(key => {\n        if (key.indexOf(accountId) === 0) {\n          _this5.removeRefreshToken(key);\n        }\n      });\n      yield Promise.all(removedCredentials);\n    })();\n  }\n  /**\n   * returns a boolean if the given credential is removed\n   * @param credential\n   */\n  removeAccessToken(key) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      const credential = _this6.getAccessTokenCredential(key);\n      if (!credential) {\n        return;\n      }\n      // Remove Token Binding Key from key store for PoP Tokens Credentials\n      if (credential.credentialType.toLowerCase() === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME.toLowerCase()) {\n        if (credential.tokenType === AuthenticationScheme.POP) {\n          const accessTokenWithAuthSchemeEntity = credential;\n          const kid = accessTokenWithAuthSchemeEntity.keyId;\n          if (kid) {\n            try {\n              yield _this6.cryptoImpl.removeTokenBindingKey(kid);\n            } catch (error) {\n              throw ClientAuthError.createBindingKeyNotRemovedError();\n            }\n          }\n        }\n      }\n      return _this6.removeItem(key);\n    })();\n  }\n  /**\n   * Removes all app metadata objects from cache.\n   */\n  removeAppMetadata() {\n    const allCacheKeys = this.getKeys();\n    allCacheKeys.forEach(cacheKey => {\n      if (this.isAppMetadata(cacheKey)) {\n        this.removeItem(cacheKey);\n      }\n    });\n    return true;\n  }\n  /**\n   * Retrieve the cached credentials into a cacherecord\n   * @param account\n   * @param clientId\n   * @param scopes\n   * @param environment\n   * @param authScheme\n   */\n  readCacheRecord(account, request, environment) {\n    const tokenKeys = this.getTokenKeys();\n    const cachedAccount = this.readAccountFromCache(account);\n    const cachedIdToken = this.getIdToken(account, tokenKeys);\n    const cachedAccessToken = this.getAccessToken(account, request, tokenKeys);\n    const cachedRefreshToken = this.getRefreshToken(account, false, tokenKeys);\n    const cachedAppMetadata = this.readAppMetadataFromCache(environment);\n    if (cachedAccount && cachedIdToken) {\n      cachedAccount.idTokenClaims = extractTokenClaims(cachedIdToken.secret, this.cryptoImpl.base64Decode);\n    }\n    return {\n      account: cachedAccount,\n      idToken: cachedIdToken,\n      accessToken: cachedAccessToken,\n      refreshToken: cachedRefreshToken,\n      appMetadata: cachedAppMetadata\n    };\n  }\n  /**\n   * Retrieve AccountEntity from cache\n   * @param account\n   */\n  readAccountFromCache(account) {\n    const accountKey = AccountEntity.generateAccountCacheKey(account);\n    return this.getAccount(accountKey);\n  }\n  /**\n   * Retrieve IdTokenEntity from cache\n   * @param clientId\n   * @param account\n   * @param inputRealm\n   */\n  getIdToken(account, tokenKeys) {\n    this.commonLogger.trace(\"CacheManager - getIdToken called\");\n    const idTokenFilter = {\n      homeAccountId: account.homeAccountId,\n      environment: account.environment,\n      credentialType: CredentialType.ID_TOKEN,\n      clientId: this.clientId,\n      realm: account.tenantId\n    };\n    const idTokens = this.getIdTokensByFilter(idTokenFilter, tokenKeys);\n    const numIdTokens = idTokens.length;\n    if (numIdTokens < 1) {\n      this.commonLogger.info(\"CacheManager:getIdToken - No token found\");\n      return null;\n    } else if (numIdTokens > 1) {\n      this.commonLogger.info(\"CacheManager:getIdToken - Multiple id tokens found, clearing them\");\n      idTokens.forEach(idToken => {\n        this.removeIdToken(idToken.generateCredentialKey());\n      });\n      return null;\n    }\n    this.commonLogger.info(\"CacheManager:getIdToken - Returning id token\");\n    return idTokens[0];\n  }\n  /**\n   * Gets all idTokens matching the given filter\n   * @param filter\n   * @returns\n   */\n  getIdTokensByFilter(filter, tokenKeys) {\n    const idTokenKeys = tokenKeys && tokenKeys.idToken || this.getTokenKeys().idToken;\n    const idTokens = [];\n    idTokenKeys.forEach(key => {\n      if (!this.idTokenKeyMatchesFilter(key, {\n        clientId: this.clientId,\n        ...filter\n      })) {\n        return;\n      }\n      const idToken = this.getIdTokenCredential(key);\n      if (idToken && this.credentialMatchesFilter(idToken, filter)) {\n        idTokens.push(idToken);\n      }\n    });\n    return idTokens;\n  }\n  /**\n   * Validate the cache key against filter before retrieving and parsing cache value\n   * @param key\n   * @param filter\n   * @returns\n   */\n  idTokenKeyMatchesFilter(inputKey, filter) {\n    const key = inputKey.toLowerCase();\n    if (filter.clientId && key.indexOf(filter.clientId.toLowerCase()) === -1) {\n      return false;\n    }\n    if (filter.homeAccountId && key.indexOf(filter.homeAccountId.toLowerCase()) === -1) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Removes idToken from the cache\n   * @param key\n   */\n  removeIdToken(key) {\n    this.removeItem(key);\n  }\n  /**\n   * Removes refresh token from the cache\n   * @param key\n   */\n  removeRefreshToken(key) {\n    this.removeItem(key);\n  }\n  /**\n   * Retrieve AccessTokenEntity from cache\n   * @param clientId\n   * @param account\n   * @param scopes\n   * @param authScheme\n   */\n  getAccessToken(account, request, tokenKeys) {\n    this.commonLogger.trace(\"CacheManager - getAccessToken called\");\n    const scopes = ScopeSet.createSearchScopes(request.scopes);\n    const authScheme = request.authenticationScheme || AuthenticationScheme.BEARER;\n    /*\n     * Distinguish between Bearer and PoP/SSH token cache types\n     * Cast to lowercase to handle \"bearer\" from ADFS\n     */\n    const credentialType = authScheme && authScheme.toLowerCase() !== AuthenticationScheme.BEARER.toLowerCase() ? CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME : CredentialType.ACCESS_TOKEN;\n    const accessTokenFilter = {\n      homeAccountId: account.homeAccountId,\n      environment: account.environment,\n      credentialType: credentialType,\n      clientId: this.clientId,\n      realm: account.tenantId,\n      target: scopes,\n      tokenType: authScheme,\n      keyId: request.sshKid,\n      requestedClaimsHash: request.requestedClaimsHash\n    };\n    const accessTokenKeys = tokenKeys && tokenKeys.accessToken || this.getTokenKeys().accessToken;\n    const accessTokens = [];\n    accessTokenKeys.forEach(key => {\n      // Validate key\n      if (this.accessTokenKeyMatchesFilter(key, accessTokenFilter, true)) {\n        const accessToken = this.getAccessTokenCredential(key);\n        // Validate value\n        if (accessToken && this.credentialMatchesFilter(accessToken, accessTokenFilter)) {\n          accessTokens.push(accessToken);\n        }\n      }\n    });\n    const numAccessTokens = accessTokens.length;\n    if (numAccessTokens < 1) {\n      this.commonLogger.info(\"CacheManager:getAccessToken - No token found\");\n      return null;\n    } else if (numAccessTokens > 1) {\n      this.commonLogger.info(\"CacheManager:getAccessToken - Multiple access tokens found, clearing them\");\n      accessTokens.forEach(accessToken => {\n        void this.removeAccessToken(accessToken.generateCredentialKey());\n      });\n      return null;\n    }\n    this.commonLogger.info(\"CacheManager:getAccessToken - Returning access token\");\n    return accessTokens[0];\n  }\n  /**\n   * Validate the cache key against filter before retrieving and parsing cache value\n   * @param key\n   * @param filter\n   * @param keyMustContainAllScopes\n   * @returns\n   */\n  accessTokenKeyMatchesFilter(inputKey, filter, keyMustContainAllScopes) {\n    const key = inputKey.toLowerCase();\n    if (filter.clientId && key.indexOf(filter.clientId.toLowerCase()) === -1) {\n      return false;\n    }\n    if (filter.homeAccountId && key.indexOf(filter.homeAccountId.toLowerCase()) === -1) {\n      return false;\n    }\n    if (filter.realm && key.indexOf(filter.realm.toLowerCase()) === -1) {\n      return false;\n    }\n    if (filter.requestedClaimsHash && key.indexOf(filter.requestedClaimsHash.toLowerCase()) === -1) {\n      return false;\n    }\n    if (filter.target) {\n      const scopes = filter.target.asArray();\n      for (let i = 0; i < scopes.length; i++) {\n        if (keyMustContainAllScopes && !key.includes(scopes[i].toLowerCase())) {\n          // When performing a cache lookup a missing scope would be a cache miss\n          return false;\n        } else if (!keyMustContainAllScopes && key.includes(scopes[i].toLowerCase())) {\n          // When performing a cache write, any token with a subset of requested scopes should be replaced\n          return true;\n        }\n      }\n    }\n    return true;\n  }\n  /**\n   * Gets all access tokens matching the filter\n   * @param filter\n   * @returns\n   */\n  getAccessTokensByFilter(filter) {\n    const tokenKeys = this.getTokenKeys();\n    const accessTokens = [];\n    tokenKeys.accessToken.forEach(key => {\n      if (!this.accessTokenKeyMatchesFilter(key, filter, true)) {\n        return;\n      }\n      const accessToken = this.getAccessTokenCredential(key);\n      if (accessToken && this.credentialMatchesFilter(accessToken, filter)) {\n        accessTokens.push(accessToken);\n      }\n    });\n    return accessTokens;\n  }\n  /**\n   * Helper to retrieve the appropriate refresh token from cache\n   * @param clientId\n   * @param account\n   * @param familyRT\n   */\n  getRefreshToken(account, familyRT, tokenKeys) {\n    this.commonLogger.trace(\"CacheManager - getRefreshToken called\");\n    const id = familyRT ? THE_FAMILY_ID : undefined;\n    const refreshTokenFilter = {\n      homeAccountId: account.homeAccountId,\n      environment: account.environment,\n      credentialType: CredentialType.REFRESH_TOKEN,\n      clientId: this.clientId,\n      familyId: id\n    };\n    const refreshTokenKeys = tokenKeys && tokenKeys.refreshToken || this.getTokenKeys().refreshToken;\n    const refreshTokens = [];\n    refreshTokenKeys.forEach(key => {\n      // Validate key\n      if (this.refreshTokenKeyMatchesFilter(key, refreshTokenFilter)) {\n        const refreshToken = this.getRefreshTokenCredential(key);\n        // Validate value\n        if (refreshToken && this.credentialMatchesFilter(refreshToken, refreshTokenFilter)) {\n          refreshTokens.push(refreshToken);\n        }\n      }\n    });\n    const numRefreshTokens = refreshTokens.length;\n    if (numRefreshTokens < 1) {\n      this.commonLogger.info(\"CacheManager:getRefreshToken - No refresh token found.\");\n      return null;\n    }\n    // address the else case after remove functions address environment aliases\n    this.commonLogger.info(\"CacheManager:getRefreshToken - returning refresh token\");\n    return refreshTokens[0];\n  }\n  /**\n   * Validate the cache key against filter before retrieving and parsing cache value\n   * @param key\n   * @param filter\n   */\n  refreshTokenKeyMatchesFilter(inputKey, filter) {\n    const key = inputKey.toLowerCase();\n    if (filter.familyId && key.indexOf(filter.familyId.toLowerCase()) === -1) {\n      return false;\n    }\n    // If familyId is used, clientId is not in the key\n    if (!filter.familyId && filter.clientId && key.indexOf(filter.clientId.toLowerCase()) === -1) {\n      return false;\n    }\n    if (filter.homeAccountId && key.indexOf(filter.homeAccountId.toLowerCase()) === -1) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Retrieve AppMetadataEntity from cache\n   */\n  readAppMetadataFromCache(environment) {\n    const appMetadataFilter = {\n      environment,\n      clientId: this.clientId\n    };\n    const appMetadata = this.getAppMetadataFilteredBy(appMetadataFilter);\n    const appMetadataEntries = Object.keys(appMetadata).map(key => appMetadata[key]);\n    const numAppMetadata = appMetadataEntries.length;\n    if (numAppMetadata < 1) {\n      return null;\n    } else if (numAppMetadata > 1) {\n      throw ClientAuthError.createMultipleMatchingAppMetadataInCacheError();\n    }\n    return appMetadataEntries[0];\n  }\n  /**\n   * Return the family_id value associated  with FOCI\n   * @param environment\n   * @param clientId\n   */\n  isAppMetadataFOCI(environment) {\n    const appMetadata = this.readAppMetadataFromCache(environment);\n    return !!(appMetadata && appMetadata.familyId === THE_FAMILY_ID);\n  }\n  /**\n   * helper to match account ids\n   * @param value\n   * @param homeAccountId\n   */\n  matchHomeAccountId(entity, homeAccountId) {\n    return !!(typeof entity.homeAccountId === \"string\" && homeAccountId === entity.homeAccountId);\n  }\n  /**\n   * helper to match account ids\n   * @param entity\n   * @param localAccountId\n   * @returns\n   */\n  matchLocalAccountId(entity, localAccountId) {\n    return !!(typeof entity.localAccountId === \"string\" && localAccountId === entity.localAccountId);\n  }\n  /**\n   * helper to match usernames\n   * @param entity\n   * @param username\n   * @returns\n   */\n  matchUsername(entity, username) {\n    return !!(typeof entity.username === \"string\" && username.toLowerCase() === entity.username.toLowerCase());\n  }\n  /**\n   * helper to match assertion\n   * @param value\n   * @param oboAssertion\n   */\n  matchUserAssertionHash(entity, userAssertionHash) {\n    return !!(entity.userAssertionHash && userAssertionHash === entity.userAssertionHash);\n  }\n  /**\n   * helper to match environment\n   * @param value\n   * @param environment\n   */\n  matchEnvironment(entity, environment) {\n    const cloudMetadata = this.getAuthorityMetadataByAlias(environment);\n    if (cloudMetadata && cloudMetadata.aliases.indexOf(entity.environment) > -1) {\n      return true;\n    }\n    return false;\n  }\n  /**\n   * helper to match credential type\n   * @param entity\n   * @param credentialType\n   */\n  matchCredentialType(entity, credentialType) {\n    return entity.credentialType && credentialType.toLowerCase() === entity.credentialType.toLowerCase();\n  }\n  /**\n   * helper to match client ids\n   * @param entity\n   * @param clientId\n   */\n  matchClientId(entity, clientId) {\n    return !!(entity.clientId && clientId === entity.clientId);\n  }\n  /**\n   * helper to match family ids\n   * @param entity\n   * @param familyId\n   */\n  matchFamilyId(entity, familyId) {\n    return !!(entity.familyId && familyId === entity.familyId);\n  }\n  /**\n   * helper to match realm\n   * @param entity\n   * @param realm\n   */\n  matchRealm(entity, realm) {\n    return !!(entity.realm && realm === entity.realm);\n  }\n  /**\n   * helper to match nativeAccountId\n   * @param entity\n   * @param nativeAccountId\n   * @returns boolean indicating the match result\n   */\n  matchNativeAccountId(entity, nativeAccountId) {\n    return !!(entity.nativeAccountId && nativeAccountId === entity.nativeAccountId);\n  }\n  /**\n   * Returns true if the target scopes are a subset of the current entity's scopes, false otherwise.\n   * @param entity\n   * @param target\n   */\n  matchTarget(entity, target) {\n    const isNotAccessTokenCredential = entity.credentialType !== CredentialType.ACCESS_TOKEN && entity.credentialType !== CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME;\n    if (isNotAccessTokenCredential || !entity.target) {\n      return false;\n    }\n    const entityScopeSet = ScopeSet.fromString(entity.target);\n    return entityScopeSet.containsScopeSet(target);\n  }\n  /**\n   * Returns true if the credential's tokenType or Authentication Scheme matches the one in the request, false otherwise\n   * @param entity\n   * @param tokenType\n   */\n  matchTokenType(entity, tokenType) {\n    return !!(entity.tokenType && entity.tokenType === tokenType);\n  }\n  /**\n   * Returns true if the credential's keyId matches the one in the request, false otherwise\n   * @param entity\n   * @param tokenType\n   */\n  matchKeyId(entity, keyId) {\n    return !!(entity.keyId && entity.keyId === keyId);\n  }\n  /**\n   * returns if a given cache entity is of the type appmetadata\n   * @param key\n   */\n  isAppMetadata(key) {\n    return key.indexOf(APP_METADATA) !== -1;\n  }\n  /**\n   * returns if a given cache entity is of the type authoritymetadata\n   * @param key\n   */\n  isAuthorityMetadata(key) {\n    return key.indexOf(AUTHORITY_METADATA_CONSTANTS.CACHE_KEY) !== -1;\n  }\n  /**\n   * returns cache key used for cloud instance metadata\n   */\n  generateAuthorityMetadataCacheKey(authority) {\n    return `${AUTHORITY_METADATA_CONSTANTS.CACHE_KEY}-${this.clientId}-${authority}`;\n  }\n  /**\n   * Helper to convert serialized data to object\n   * @param obj\n   * @param json\n   */\n  static toObject(obj, json) {\n    for (const propertyName in json) {\n      obj[propertyName] = json[propertyName];\n    }\n    return obj;\n  }\n}\n/** @internal */\nclass DefaultStorageClass extends CacheManager {\n  setAccount() {\n    const notImplErr = \"Storage interface - setAccount() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  }\n  getAccount() {\n    const notImplErr = \"Storage interface - getAccount() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  }\n  setIdTokenCredential() {\n    const notImplErr = \"Storage interface - setIdTokenCredential() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  }\n  getIdTokenCredential() {\n    const notImplErr = \"Storage interface - getIdTokenCredential() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  }\n  setAccessTokenCredential() {\n    const notImplErr = \"Storage interface - setAccessTokenCredential() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  }\n  getAccessTokenCredential() {\n    const notImplErr = \"Storage interface - getAccessTokenCredential() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  }\n  setRefreshTokenCredential() {\n    const notImplErr = \"Storage interface - setRefreshTokenCredential() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  }\n  getRefreshTokenCredential() {\n    const notImplErr = \"Storage interface - getRefreshTokenCredential() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  }\n  setAppMetadata() {\n    const notImplErr = \"Storage interface - setAppMetadata() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  }\n  getAppMetadata() {\n    const notImplErr = \"Storage interface - getAppMetadata() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  }\n  setServerTelemetry() {\n    const notImplErr = \"Storage interface - setServerTelemetry() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  }\n  getServerTelemetry() {\n    const notImplErr = \"Storage interface - getServerTelemetry() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  }\n  setAuthorityMetadata() {\n    const notImplErr = \"Storage interface - setAuthorityMetadata() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  }\n  getAuthorityMetadata() {\n    const notImplErr = \"Storage interface - getAuthorityMetadata() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  }\n  getAuthorityMetadataKeys() {\n    const notImplErr = \"Storage interface - getAuthorityMetadataKeys() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  }\n  setThrottlingCache() {\n    const notImplErr = \"Storage interface - setThrottlingCache() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  }\n  getThrottlingCache() {\n    const notImplErr = \"Storage interface - getThrottlingCache() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  }\n  removeItem() {\n    const notImplErr = \"Storage interface - removeItem() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  }\n  containsKey() {\n    const notImplErr = \"Storage interface - containsKey() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  }\n  getKeys() {\n    const notImplErr = \"Storage interface - getKeys() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  }\n  getAccountKeys() {\n    const notImplErr = \"Storage interface - getAccountKeys() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  }\n  getTokenKeys() {\n    const notImplErr = \"Storage interface - getTokenKeys() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  }\n  clear() {\n    return _asyncToGenerator(function* () {\n      const notImplErr = \"Storage interface - clear() has not been implemented for the cacheStorage interface.\";\n      throw AuthError.createUnexpectedError(notImplErr);\n    })();\n  }\n  updateCredentialCacheKey() {\n    const notImplErr = \"Storage interface - updateCredentialCacheKey() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  }\n}\nexport { CacheManager, DefaultStorageClass };","map":{"version":3,"names":["_asyncToGenerator","Separators","CredentialType","AuthenticationScheme","THE_FAMILY_ID","APP_METADATA","AUTHORITY_METADATA_CONSTANTS","ScopeSet","AccountEntity","AuthError","ClientAuthError","extractTokenClaims","name","version","CacheManager","constructor","clientId","cryptoImpl","logger","commonLogger","clone","getAllAccounts","allAccountKeys","getAccountKeys","length","accountEntities","reduce","accounts","key","entity","getAccount","push","allAccounts","map","accountEntity","getAccountInfoFromEntity","getAccountInfoFilteredBy","accountFilter","getAccountsFilteredBy","accountInfo","getAccountInfo","idToken","getIdToken","secret","idTokenClaims","base64Decode","saveCacheRecord","cacheRecord","storeInCache","_this","createNullOrUndefinedCacheRecord","account","setAccount","setIdTokenCredential","accessToken","saveAccessToken","refreshToken","setRefreshTokenCredential","appMetadata","setAppMetadata","credential","_this2","accessTokenFilter","credentialType","environment","homeAccountId","realm","tokenType","requestedClaimsHash","tokenKeys","getTokenKeys","currentScopes","fromString","target","removedAccessTokens","forEach","accessTokenKeyMatchesFilter","tokenEntity","getAccessTokenCredential","credentialMatchesFilter","tokenScopeSet","intersectingScopeSets","removeAccessToken","Promise","all","setAccessTokenCredential","matchingAccounts","cacheKey","isAccountKey","matchHomeAccountId","localAccountId","matchLocalAccountId","username","matchUsername","matchEnvironment","matchRealm","nativeAccountId","matchNativeAccountId","tenantId","split","CACHE_KEY_SEPARATOR","toLowerCase","includes","isCredentialKey","lowerCaseKey","indexOf","ID_TOKEN","ACCESS_TOKEN","ACCESS_TOKEN_WITH_AUTH_SCHEME","REFRESH_TOKEN","clientIdValidation","familyIdValidation","filter","matchClientId","userAssertionHash","matchUserAssertionHash","matchCredentialType","familyId","matchFamilyId","matchTarget","matchTokenType","SSH","keyId","matchKeyId","getAppMetadataFilteredBy","getAppMetadataFilteredByInternal","allCacheKeys","getKeys","matchingAppMetadata","isAppMetadata","getAppMetadata","getAuthorityMetadataByAlias","host","getAuthorityMetadataKeys","matchedEntity","isAuthorityMetadata","getAuthorityMetadata","aliases","removeAllAccounts","_this3","removedAccounts","removeAccount","accountKey","_this4","removeAccountContext","removeItem","_this5","allTokenKeys","accountId","generateAccountId","removedCredentials","removeIdToken","removeRefreshToken","_this6","POP","accessTokenWithAuthSchemeEntity","kid","removeTokenBindingKey","error","createBindingKeyNotRemovedError","removeAppMetadata","readCacheRecord","request","cachedAccount","readAccountFromCache","cachedIdToken","cachedAccessToken","getAccessToken","cachedRefreshToken","getRefreshToken","cachedAppMetadata","readAppMetadataFromCache","generateAccountCacheKey","trace","idTokenFilter","idTokens","getIdTokensByFilter","numIdTokens","info","generateCredentialKey","idTokenKeys","idTokenKeyMatchesFilter","getIdTokenCredential","inputKey","scopes","createSearchScopes","authScheme","authenticationScheme","BEARER","sshKid","accessTokenKeys","accessTokens","numAccessTokens","keyMustContainAllScopes","asArray","i","getAccessTokensByFilter","familyRT","id","undefined","refreshTokenFilter","refreshTokenKeys","refreshTokens","refreshTokenKeyMatchesFilter","getRefreshTokenCredential","numRefreshTokens","appMetadataFilter","appMetadataEntries","Object","keys","numAppMetadata","createMultipleMatchingAppMetadataInCacheError","isAppMetadataFOCI","cloudMetadata","isNotAccessTokenCredential","entityScopeSet","containsScopeSet","CACHE_KEY","generateAuthorityMetadataCacheKey","authority","toObject","obj","json","propertyName","DefaultStorageClass","notImplErr","createUnexpectedError","setServerTelemetry","getServerTelemetry","setAuthorityMetadata","setThrottlingCache","getThrottlingCache","containsKey","clear","updateCredentialCacheKey"],"sources":["C:/Users/v-dkamali/Documents/AngularMSALAD/microsoft-login/node_modules/@azure/msal-common/dist/cache/CacheManager.mjs"],"sourcesContent":["/*! @azure/msal-common v14.0.3 2023-09-05 */\n'use strict';\nimport { Separators, CredentialType, AuthenticationScheme, THE_FAMILY_ID, APP_METADATA, AUTHORITY_METADATA_CONSTANTS } from '../utils/Constants.mjs';\nimport { ScopeSet } from '../request/ScopeSet.mjs';\nimport { AccountEntity } from './entities/AccountEntity.mjs';\nimport { AuthError } from '../error/AuthError.mjs';\nimport { ClientAuthError } from '../error/ClientAuthError.mjs';\nimport { extractTokenClaims } from '../account/AuthToken.mjs';\nimport { name, version } from '../packageMetadata.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * Interface class which implement cache storage functions used by MSAL to perform validity checks, and store tokens.\n * @internal\n */\nclass CacheManager {\n    constructor(clientId, cryptoImpl, logger) {\n        this.clientId = clientId;\n        this.cryptoImpl = cryptoImpl;\n        this.commonLogger = logger.clone(name, version);\n    }\n    /**\n     * Returns all accounts in cache\n     */\n    getAllAccounts() {\n        const allAccountKeys = this.getAccountKeys();\n        if (allAccountKeys.length < 1) {\n            return [];\n        }\n        const accountEntities = allAccountKeys.reduce((accounts, key) => {\n            const entity = this.getAccount(key);\n            if (!entity) {\n                return accounts;\n            }\n            accounts.push(entity);\n            return accounts;\n        }, []);\n        if (accountEntities.length < 1) {\n            return [];\n        }\n        else {\n            const allAccounts = accountEntities.map((accountEntity) => {\n                return this.getAccountInfoFromEntity(accountEntity);\n            });\n            return allAccounts;\n        }\n    }\n    /**\n     * Gets accountInfo object based on provided filters\n     */\n    getAccountInfoFilteredBy(accountFilter) {\n        const allAccounts = this.getAccountsFilteredBy(accountFilter);\n        if (allAccounts.length > 0) {\n            return this.getAccountInfoFromEntity(allAccounts[0]);\n        }\n        else {\n            return null;\n        }\n    }\n    getAccountInfoFromEntity(accountEntity) {\n        const accountInfo = accountEntity.getAccountInfo();\n        const idToken = this.getIdToken(accountInfo);\n        if (idToken) {\n            accountInfo.idToken = idToken.secret;\n            accountInfo.idTokenClaims = extractTokenClaims(idToken.secret, this.cryptoImpl.base64Decode);\n        }\n        return accountInfo;\n    }\n    /**\n     * saves a cache record\n     * @param cacheRecord\n     */\n    async saveCacheRecord(cacheRecord, storeInCache) {\n        if (!cacheRecord) {\n            throw ClientAuthError.createNullOrUndefinedCacheRecord();\n        }\n        if (!!cacheRecord.account) {\n            this.setAccount(cacheRecord.account);\n        }\n        if (!!cacheRecord.idToken && storeInCache?.idToken !== false) {\n            this.setIdTokenCredential(cacheRecord.idToken);\n        }\n        if (!!cacheRecord.accessToken && storeInCache?.accessToken !== false) {\n            await this.saveAccessToken(cacheRecord.accessToken);\n        }\n        if (!!cacheRecord.refreshToken &&\n            storeInCache?.refreshToken !== false) {\n            this.setRefreshTokenCredential(cacheRecord.refreshToken);\n        }\n        if (!!cacheRecord.appMetadata) {\n            this.setAppMetadata(cacheRecord.appMetadata);\n        }\n    }\n    /**\n     * saves access token credential\n     * @param credential\n     */\n    async saveAccessToken(credential) {\n        const accessTokenFilter = {\n            clientId: credential.clientId,\n            credentialType: credential.credentialType,\n            environment: credential.environment,\n            homeAccountId: credential.homeAccountId,\n            realm: credential.realm,\n            tokenType: credential.tokenType,\n            requestedClaimsHash: credential.requestedClaimsHash,\n        };\n        const tokenKeys = this.getTokenKeys();\n        const currentScopes = ScopeSet.fromString(credential.target);\n        const removedAccessTokens = [];\n        tokenKeys.accessToken.forEach((key) => {\n            if (!this.accessTokenKeyMatchesFilter(key, accessTokenFilter, false)) {\n                return;\n            }\n            const tokenEntity = this.getAccessTokenCredential(key);\n            if (tokenEntity &&\n                this.credentialMatchesFilter(tokenEntity, accessTokenFilter)) {\n                const tokenScopeSet = ScopeSet.fromString(tokenEntity.target);\n                if (tokenScopeSet.intersectingScopeSets(currentScopes)) {\n                    removedAccessTokens.push(this.removeAccessToken(key));\n                }\n            }\n        });\n        await Promise.all(removedAccessTokens);\n        this.setAccessTokenCredential(credential);\n    }\n    /**\n     * retrieve accounts matching all provided filters; if no filter is set, get all accounts\n     * not checking for casing as keys are all generated in lower case, remember to convert to lower case if object properties are compared\n     * @param homeAccountId\n     * @param environment\n     * @param realm\n     */\n    getAccountsFilteredBy(accountFilter) {\n        const allAccountKeys = this.getAccountKeys();\n        const matchingAccounts = [];\n        allAccountKeys.forEach((cacheKey) => {\n            if (!this.isAccountKey(cacheKey, accountFilter.homeAccountId, accountFilter.realm)) {\n                // Don't parse value if the key doesn't match the account filters\n                return;\n            }\n            const entity = this.getAccount(cacheKey);\n            if (!entity) {\n                return;\n            }\n            if (!!accountFilter.homeAccountId &&\n                !this.matchHomeAccountId(entity, accountFilter.homeAccountId)) {\n                return;\n            }\n            if (!!accountFilter.localAccountId &&\n                !this.matchLocalAccountId(entity, accountFilter.localAccountId)) {\n                return;\n            }\n            if (!!accountFilter.username &&\n                !this.matchUsername(entity, accountFilter.username)) {\n                return;\n            }\n            if (!!accountFilter.environment &&\n                !this.matchEnvironment(entity, accountFilter.environment)) {\n                return;\n            }\n            if (!!accountFilter.realm &&\n                !this.matchRealm(entity, accountFilter.realm)) {\n                return;\n            }\n            if (!!accountFilter.nativeAccountId &&\n                !this.matchNativeAccountId(entity, accountFilter.nativeAccountId)) {\n                return;\n            }\n            matchingAccounts.push(entity);\n        });\n        return matchingAccounts;\n    }\n    /**\n     * Returns true if the given key matches our account key schema. Also matches homeAccountId and/or tenantId if provided\n     * @param key\n     * @param homeAccountId\n     * @param tenantId\n     * @returns\n     */\n    isAccountKey(key, homeAccountId, tenantId) {\n        if (key.split(Separators.CACHE_KEY_SEPARATOR).length < 3) {\n            // Account cache keys contain 3 items separated by '-' (each item may also contain '-')\n            return false;\n        }\n        if (homeAccountId &&\n            !key.toLowerCase().includes(homeAccountId.toLowerCase())) {\n            return false;\n        }\n        if (tenantId && !key.toLowerCase().includes(tenantId.toLowerCase())) {\n            return false;\n        }\n        // Do not check environment as aliasing can cause false negatives\n        return true;\n    }\n    /**\n     * Returns true if the given key matches our credential key schema.\n     * @param key\n     */\n    isCredentialKey(key) {\n        if (key.split(Separators.CACHE_KEY_SEPARATOR).length < 6) {\n            // Credential cache keys contain 6 items separated by '-' (each item may also contain '-')\n            return false;\n        }\n        const lowerCaseKey = key.toLowerCase();\n        // Credential keys must indicate what credential type they represent\n        if (lowerCaseKey.indexOf(CredentialType.ID_TOKEN.toLowerCase()) ===\n            -1 &&\n            lowerCaseKey.indexOf(CredentialType.ACCESS_TOKEN.toLowerCase()) ===\n                -1 &&\n            lowerCaseKey.indexOf(CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME.toLowerCase()) === -1 &&\n            lowerCaseKey.indexOf(CredentialType.REFRESH_TOKEN.toLowerCase()) ===\n                -1) {\n            return false;\n        }\n        if (lowerCaseKey.indexOf(CredentialType.REFRESH_TOKEN.toLowerCase()) >\n            -1) {\n            // Refresh tokens must contain the client id or family id\n            const clientIdValidation = `${CredentialType.REFRESH_TOKEN}${Separators.CACHE_KEY_SEPARATOR}${this.clientId}${Separators.CACHE_KEY_SEPARATOR}`;\n            const familyIdValidation = `${CredentialType.REFRESH_TOKEN}${Separators.CACHE_KEY_SEPARATOR}${THE_FAMILY_ID}${Separators.CACHE_KEY_SEPARATOR}`;\n            if (lowerCaseKey.indexOf(clientIdValidation.toLowerCase()) === -1 &&\n                lowerCaseKey.indexOf(familyIdValidation.toLowerCase()) === -1) {\n                return false;\n            }\n        }\n        else if (lowerCaseKey.indexOf(this.clientId.toLowerCase()) === -1) {\n            // Tokens must contain the clientId\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Returns whether or not the given credential entity matches the filter\n     * @param entity\n     * @param filter\n     * @returns\n     */\n    credentialMatchesFilter(entity, filter) {\n        if (!!filter.clientId && !this.matchClientId(entity, filter.clientId)) {\n            return false;\n        }\n        if (!!filter.userAssertionHash &&\n            !this.matchUserAssertionHash(entity, filter.userAssertionHash)) {\n            return false;\n        }\n        /*\n         * homeAccountId can be undefined, and we want to filter out cached items that have a homeAccountId of \"\"\n         * because we don't want a client_credential request to return a cached token that has a homeAccountId\n         */\n        if (typeof filter.homeAccountId === \"string\" &&\n            !this.matchHomeAccountId(entity, filter.homeAccountId)) {\n            return false;\n        }\n        if (!!filter.environment &&\n            !this.matchEnvironment(entity, filter.environment)) {\n            return false;\n        }\n        if (!!filter.realm && !this.matchRealm(entity, filter.realm)) {\n            return false;\n        }\n        if (!!filter.credentialType &&\n            !this.matchCredentialType(entity, filter.credentialType)) {\n            return false;\n        }\n        if (!!filter.familyId && !this.matchFamilyId(entity, filter.familyId)) {\n            return false;\n        }\n        /*\n         * idTokens do not have \"target\", target specific refreshTokens do exist for some types of authentication\n         * Resource specific refresh tokens case will be added when the support is deemed necessary\n         */\n        if (!!filter.target && !this.matchTarget(entity, filter.target)) {\n            return false;\n        }\n        // If request OR cached entity has requested Claims Hash, check if they match\n        if (filter.requestedClaimsHash || entity.requestedClaimsHash) {\n            // Don't match if either is undefined or they are different\n            if (entity.requestedClaimsHash !== filter.requestedClaimsHash) {\n                return false;\n            }\n        }\n        // Access Token with Auth Scheme specific matching\n        if (entity.credentialType ===\n            CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME) {\n            if (!!filter.tokenType &&\n                !this.matchTokenType(entity, filter.tokenType)) {\n                return false;\n            }\n            // KeyId (sshKid) in request must match cached SSH certificate keyId because SSH cert is bound to a specific key\n            if (filter.tokenType === AuthenticationScheme.SSH) {\n                if (filter.keyId && !this.matchKeyId(entity, filter.keyId)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    /**\n     * retrieve appMetadata matching all provided filters; if no filter is set, get all appMetadata\n     * @param filter\n     */\n    getAppMetadataFilteredBy(filter) {\n        return this.getAppMetadataFilteredByInternal(filter.environment, filter.clientId);\n    }\n    /**\n     * Support function to help match appMetadata\n     * @param environment\n     * @param clientId\n     */\n    getAppMetadataFilteredByInternal(environment, clientId) {\n        const allCacheKeys = this.getKeys();\n        const matchingAppMetadata = {};\n        allCacheKeys.forEach((cacheKey) => {\n            // don't parse any non-appMetadata type cache entities\n            if (!this.isAppMetadata(cacheKey)) {\n                return;\n            }\n            // Attempt retrieval\n            const entity = this.getAppMetadata(cacheKey);\n            if (!entity) {\n                return;\n            }\n            if (!!environment && !this.matchEnvironment(entity, environment)) {\n                return;\n            }\n            if (!!clientId && !this.matchClientId(entity, clientId)) {\n                return;\n            }\n            matchingAppMetadata[cacheKey] = entity;\n        });\n        return matchingAppMetadata;\n    }\n    /**\n     * retrieve authorityMetadata that contains a matching alias\n     * @param filter\n     */\n    getAuthorityMetadataByAlias(host) {\n        const allCacheKeys = this.getAuthorityMetadataKeys();\n        let matchedEntity = null;\n        allCacheKeys.forEach((cacheKey) => {\n            // don't parse any non-authorityMetadata type cache entities\n            if (!this.isAuthorityMetadata(cacheKey) ||\n                cacheKey.indexOf(this.clientId) === -1) {\n                return;\n            }\n            // Attempt retrieval\n            const entity = this.getAuthorityMetadata(cacheKey);\n            if (!entity) {\n                return;\n            }\n            if (entity.aliases.indexOf(host) === -1) {\n                return;\n            }\n            matchedEntity = entity;\n        });\n        return matchedEntity;\n    }\n    /**\n     * Removes all accounts and related tokens from cache.\n     */\n    async removeAllAccounts() {\n        const allAccountKeys = this.getAccountKeys();\n        const removedAccounts = [];\n        allAccountKeys.forEach((cacheKey) => {\n            removedAccounts.push(this.removeAccount(cacheKey));\n        });\n        await Promise.all(removedAccounts);\n    }\n    /**\n     * Removes the account and related tokens for a given account key\n     * @param account\n     */\n    async removeAccount(accountKey) {\n        const account = this.getAccount(accountKey);\n        if (!account) {\n            return;\n        }\n        await this.removeAccountContext(account);\n        this.removeItem(accountKey);\n    }\n    /**\n     * Removes credentials associated with the provided account\n     * @param account\n     */\n    async removeAccountContext(account) {\n        const allTokenKeys = this.getTokenKeys();\n        const accountId = account.generateAccountId();\n        const removedCredentials = [];\n        allTokenKeys.idToken.forEach((key) => {\n            if (key.indexOf(accountId) === 0) {\n                this.removeIdToken(key);\n            }\n        });\n        allTokenKeys.accessToken.forEach((key) => {\n            if (key.indexOf(accountId) === 0) {\n                removedCredentials.push(this.removeAccessToken(key));\n            }\n        });\n        allTokenKeys.refreshToken.forEach((key) => {\n            if (key.indexOf(accountId) === 0) {\n                this.removeRefreshToken(key);\n            }\n        });\n        await Promise.all(removedCredentials);\n    }\n    /**\n     * returns a boolean if the given credential is removed\n     * @param credential\n     */\n    async removeAccessToken(key) {\n        const credential = this.getAccessTokenCredential(key);\n        if (!credential) {\n            return;\n        }\n        // Remove Token Binding Key from key store for PoP Tokens Credentials\n        if (credential.credentialType.toLowerCase() ===\n            CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME.toLowerCase()) {\n            if (credential.tokenType === AuthenticationScheme.POP) {\n                const accessTokenWithAuthSchemeEntity = credential;\n                const kid = accessTokenWithAuthSchemeEntity.keyId;\n                if (kid) {\n                    try {\n                        await this.cryptoImpl.removeTokenBindingKey(kid);\n                    }\n                    catch (error) {\n                        throw ClientAuthError.createBindingKeyNotRemovedError();\n                    }\n                }\n            }\n        }\n        return this.removeItem(key);\n    }\n    /**\n     * Removes all app metadata objects from cache.\n     */\n    removeAppMetadata() {\n        const allCacheKeys = this.getKeys();\n        allCacheKeys.forEach((cacheKey) => {\n            if (this.isAppMetadata(cacheKey)) {\n                this.removeItem(cacheKey);\n            }\n        });\n        return true;\n    }\n    /**\n     * Retrieve the cached credentials into a cacherecord\n     * @param account\n     * @param clientId\n     * @param scopes\n     * @param environment\n     * @param authScheme\n     */\n    readCacheRecord(account, request, environment) {\n        const tokenKeys = this.getTokenKeys();\n        const cachedAccount = this.readAccountFromCache(account);\n        const cachedIdToken = this.getIdToken(account, tokenKeys);\n        const cachedAccessToken = this.getAccessToken(account, request, tokenKeys);\n        const cachedRefreshToken = this.getRefreshToken(account, false, tokenKeys);\n        const cachedAppMetadata = this.readAppMetadataFromCache(environment);\n        if (cachedAccount && cachedIdToken) {\n            cachedAccount.idTokenClaims = extractTokenClaims(cachedIdToken.secret, this.cryptoImpl.base64Decode);\n        }\n        return {\n            account: cachedAccount,\n            idToken: cachedIdToken,\n            accessToken: cachedAccessToken,\n            refreshToken: cachedRefreshToken,\n            appMetadata: cachedAppMetadata,\n        };\n    }\n    /**\n     * Retrieve AccountEntity from cache\n     * @param account\n     */\n    readAccountFromCache(account) {\n        const accountKey = AccountEntity.generateAccountCacheKey(account);\n        return this.getAccount(accountKey);\n    }\n    /**\n     * Retrieve IdTokenEntity from cache\n     * @param clientId\n     * @param account\n     * @param inputRealm\n     */\n    getIdToken(account, tokenKeys) {\n        this.commonLogger.trace(\"CacheManager - getIdToken called\");\n        const idTokenFilter = {\n            homeAccountId: account.homeAccountId,\n            environment: account.environment,\n            credentialType: CredentialType.ID_TOKEN,\n            clientId: this.clientId,\n            realm: account.tenantId,\n        };\n        const idTokens = this.getIdTokensByFilter(idTokenFilter, tokenKeys);\n        const numIdTokens = idTokens.length;\n        if (numIdTokens < 1) {\n            this.commonLogger.info(\"CacheManager:getIdToken - No token found\");\n            return null;\n        }\n        else if (numIdTokens > 1) {\n            this.commonLogger.info(\"CacheManager:getIdToken - Multiple id tokens found, clearing them\");\n            idTokens.forEach((idToken) => {\n                this.removeIdToken(idToken.generateCredentialKey());\n            });\n            return null;\n        }\n        this.commonLogger.info(\"CacheManager:getIdToken - Returning id token\");\n        return idTokens[0];\n    }\n    /**\n     * Gets all idTokens matching the given filter\n     * @param filter\n     * @returns\n     */\n    getIdTokensByFilter(filter, tokenKeys) {\n        const idTokenKeys = (tokenKeys && tokenKeys.idToken) || this.getTokenKeys().idToken;\n        const idTokens = [];\n        idTokenKeys.forEach((key) => {\n            if (!this.idTokenKeyMatchesFilter(key, {\n                clientId: this.clientId,\n                ...filter,\n            })) {\n                return;\n            }\n            const idToken = this.getIdTokenCredential(key);\n            if (idToken && this.credentialMatchesFilter(idToken, filter)) {\n                idTokens.push(idToken);\n            }\n        });\n        return idTokens;\n    }\n    /**\n     * Validate the cache key against filter before retrieving and parsing cache value\n     * @param key\n     * @param filter\n     * @returns\n     */\n    idTokenKeyMatchesFilter(inputKey, filter) {\n        const key = inputKey.toLowerCase();\n        if (filter.clientId &&\n            key.indexOf(filter.clientId.toLowerCase()) === -1) {\n            return false;\n        }\n        if (filter.homeAccountId &&\n            key.indexOf(filter.homeAccountId.toLowerCase()) === -1) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Removes idToken from the cache\n     * @param key\n     */\n    removeIdToken(key) {\n        this.removeItem(key);\n    }\n    /**\n     * Removes refresh token from the cache\n     * @param key\n     */\n    removeRefreshToken(key) {\n        this.removeItem(key);\n    }\n    /**\n     * Retrieve AccessTokenEntity from cache\n     * @param clientId\n     * @param account\n     * @param scopes\n     * @param authScheme\n     */\n    getAccessToken(account, request, tokenKeys) {\n        this.commonLogger.trace(\"CacheManager - getAccessToken called\");\n        const scopes = ScopeSet.createSearchScopes(request.scopes);\n        const authScheme = request.authenticationScheme || AuthenticationScheme.BEARER;\n        /*\n         * Distinguish between Bearer and PoP/SSH token cache types\n         * Cast to lowercase to handle \"bearer\" from ADFS\n         */\n        const credentialType = authScheme &&\n            authScheme.toLowerCase() !==\n                AuthenticationScheme.BEARER.toLowerCase()\n            ? CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME\n            : CredentialType.ACCESS_TOKEN;\n        const accessTokenFilter = {\n            homeAccountId: account.homeAccountId,\n            environment: account.environment,\n            credentialType: credentialType,\n            clientId: this.clientId,\n            realm: account.tenantId,\n            target: scopes,\n            tokenType: authScheme,\n            keyId: request.sshKid,\n            requestedClaimsHash: request.requestedClaimsHash,\n        };\n        const accessTokenKeys = (tokenKeys && tokenKeys.accessToken) ||\n            this.getTokenKeys().accessToken;\n        const accessTokens = [];\n        accessTokenKeys.forEach((key) => {\n            // Validate key\n            if (this.accessTokenKeyMatchesFilter(key, accessTokenFilter, true)) {\n                const accessToken = this.getAccessTokenCredential(key);\n                // Validate value\n                if (accessToken &&\n                    this.credentialMatchesFilter(accessToken, accessTokenFilter)) {\n                    accessTokens.push(accessToken);\n                }\n            }\n        });\n        const numAccessTokens = accessTokens.length;\n        if (numAccessTokens < 1) {\n            this.commonLogger.info(\"CacheManager:getAccessToken - No token found\");\n            return null;\n        }\n        else if (numAccessTokens > 1) {\n            this.commonLogger.info(\"CacheManager:getAccessToken - Multiple access tokens found, clearing them\");\n            accessTokens.forEach((accessToken) => {\n                void this.removeAccessToken(accessToken.generateCredentialKey());\n            });\n            return null;\n        }\n        this.commonLogger.info(\"CacheManager:getAccessToken - Returning access token\");\n        return accessTokens[0];\n    }\n    /**\n     * Validate the cache key against filter before retrieving and parsing cache value\n     * @param key\n     * @param filter\n     * @param keyMustContainAllScopes\n     * @returns\n     */\n    accessTokenKeyMatchesFilter(inputKey, filter, keyMustContainAllScopes) {\n        const key = inputKey.toLowerCase();\n        if (filter.clientId &&\n            key.indexOf(filter.clientId.toLowerCase()) === -1) {\n            return false;\n        }\n        if (filter.homeAccountId &&\n            key.indexOf(filter.homeAccountId.toLowerCase()) === -1) {\n            return false;\n        }\n        if (filter.realm && key.indexOf(filter.realm.toLowerCase()) === -1) {\n            return false;\n        }\n        if (filter.requestedClaimsHash &&\n            key.indexOf(filter.requestedClaimsHash.toLowerCase()) === -1) {\n            return false;\n        }\n        if (filter.target) {\n            const scopes = filter.target.asArray();\n            for (let i = 0; i < scopes.length; i++) {\n                if (keyMustContainAllScopes &&\n                    !key.includes(scopes[i].toLowerCase())) {\n                    // When performing a cache lookup a missing scope would be a cache miss\n                    return false;\n                }\n                else if (!keyMustContainAllScopes &&\n                    key.includes(scopes[i].toLowerCase())) {\n                    // When performing a cache write, any token with a subset of requested scopes should be replaced\n                    return true;\n                }\n            }\n        }\n        return true;\n    }\n    /**\n     * Gets all access tokens matching the filter\n     * @param filter\n     * @returns\n     */\n    getAccessTokensByFilter(filter) {\n        const tokenKeys = this.getTokenKeys();\n        const accessTokens = [];\n        tokenKeys.accessToken.forEach((key) => {\n            if (!this.accessTokenKeyMatchesFilter(key, filter, true)) {\n                return;\n            }\n            const accessToken = this.getAccessTokenCredential(key);\n            if (accessToken &&\n                this.credentialMatchesFilter(accessToken, filter)) {\n                accessTokens.push(accessToken);\n            }\n        });\n        return accessTokens;\n    }\n    /**\n     * Helper to retrieve the appropriate refresh token from cache\n     * @param clientId\n     * @param account\n     * @param familyRT\n     */\n    getRefreshToken(account, familyRT, tokenKeys) {\n        this.commonLogger.trace(\"CacheManager - getRefreshToken called\");\n        const id = familyRT ? THE_FAMILY_ID : undefined;\n        const refreshTokenFilter = {\n            homeAccountId: account.homeAccountId,\n            environment: account.environment,\n            credentialType: CredentialType.REFRESH_TOKEN,\n            clientId: this.clientId,\n            familyId: id,\n        };\n        const refreshTokenKeys = (tokenKeys && tokenKeys.refreshToken) ||\n            this.getTokenKeys().refreshToken;\n        const refreshTokens = [];\n        refreshTokenKeys.forEach((key) => {\n            // Validate key\n            if (this.refreshTokenKeyMatchesFilter(key, refreshTokenFilter)) {\n                const refreshToken = this.getRefreshTokenCredential(key);\n                // Validate value\n                if (refreshToken &&\n                    this.credentialMatchesFilter(refreshToken, refreshTokenFilter)) {\n                    refreshTokens.push(refreshToken);\n                }\n            }\n        });\n        const numRefreshTokens = refreshTokens.length;\n        if (numRefreshTokens < 1) {\n            this.commonLogger.info(\"CacheManager:getRefreshToken - No refresh token found.\");\n            return null;\n        }\n        // address the else case after remove functions address environment aliases\n        this.commonLogger.info(\"CacheManager:getRefreshToken - returning refresh token\");\n        return refreshTokens[0];\n    }\n    /**\n     * Validate the cache key against filter before retrieving and parsing cache value\n     * @param key\n     * @param filter\n     */\n    refreshTokenKeyMatchesFilter(inputKey, filter) {\n        const key = inputKey.toLowerCase();\n        if (filter.familyId &&\n            key.indexOf(filter.familyId.toLowerCase()) === -1) {\n            return false;\n        }\n        // If familyId is used, clientId is not in the key\n        if (!filter.familyId &&\n            filter.clientId &&\n            key.indexOf(filter.clientId.toLowerCase()) === -1) {\n            return false;\n        }\n        if (filter.homeAccountId &&\n            key.indexOf(filter.homeAccountId.toLowerCase()) === -1) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Retrieve AppMetadataEntity from cache\n     */\n    readAppMetadataFromCache(environment) {\n        const appMetadataFilter = {\n            environment,\n            clientId: this.clientId,\n        };\n        const appMetadata = this.getAppMetadataFilteredBy(appMetadataFilter);\n        const appMetadataEntries = Object.keys(appMetadata).map((key) => appMetadata[key]);\n        const numAppMetadata = appMetadataEntries.length;\n        if (numAppMetadata < 1) {\n            return null;\n        }\n        else if (numAppMetadata > 1) {\n            throw ClientAuthError.createMultipleMatchingAppMetadataInCacheError();\n        }\n        return appMetadataEntries[0];\n    }\n    /**\n     * Return the family_id value associated  with FOCI\n     * @param environment\n     * @param clientId\n     */\n    isAppMetadataFOCI(environment) {\n        const appMetadata = this.readAppMetadataFromCache(environment);\n        return !!(appMetadata && appMetadata.familyId === THE_FAMILY_ID);\n    }\n    /**\n     * helper to match account ids\n     * @param value\n     * @param homeAccountId\n     */\n    matchHomeAccountId(entity, homeAccountId) {\n        return !!(typeof entity.homeAccountId === \"string\" &&\n            homeAccountId === entity.homeAccountId);\n    }\n    /**\n     * helper to match account ids\n     * @param entity\n     * @param localAccountId\n     * @returns\n     */\n    matchLocalAccountId(entity, localAccountId) {\n        return !!(typeof entity.localAccountId === \"string\" &&\n            localAccountId === entity.localAccountId);\n    }\n    /**\n     * helper to match usernames\n     * @param entity\n     * @param username\n     * @returns\n     */\n    matchUsername(entity, username) {\n        return !!(typeof entity.username === \"string\" &&\n            username.toLowerCase() === entity.username.toLowerCase());\n    }\n    /**\n     * helper to match assertion\n     * @param value\n     * @param oboAssertion\n     */\n    matchUserAssertionHash(entity, userAssertionHash) {\n        return !!(entity.userAssertionHash &&\n            userAssertionHash === entity.userAssertionHash);\n    }\n    /**\n     * helper to match environment\n     * @param value\n     * @param environment\n     */\n    matchEnvironment(entity, environment) {\n        const cloudMetadata = this.getAuthorityMetadataByAlias(environment);\n        if (cloudMetadata &&\n            cloudMetadata.aliases.indexOf(entity.environment) > -1) {\n            return true;\n        }\n        return false;\n    }\n    /**\n     * helper to match credential type\n     * @param entity\n     * @param credentialType\n     */\n    matchCredentialType(entity, credentialType) {\n        return (entity.credentialType &&\n            credentialType.toLowerCase() === entity.credentialType.toLowerCase());\n    }\n    /**\n     * helper to match client ids\n     * @param entity\n     * @param clientId\n     */\n    matchClientId(entity, clientId) {\n        return !!(entity.clientId && clientId === entity.clientId);\n    }\n    /**\n     * helper to match family ids\n     * @param entity\n     * @param familyId\n     */\n    matchFamilyId(entity, familyId) {\n        return !!(entity.familyId && familyId === entity.familyId);\n    }\n    /**\n     * helper to match realm\n     * @param entity\n     * @param realm\n     */\n    matchRealm(entity, realm) {\n        return !!(entity.realm && realm === entity.realm);\n    }\n    /**\n     * helper to match nativeAccountId\n     * @param entity\n     * @param nativeAccountId\n     * @returns boolean indicating the match result\n     */\n    matchNativeAccountId(entity, nativeAccountId) {\n        return !!(entity.nativeAccountId && nativeAccountId === entity.nativeAccountId);\n    }\n    /**\n     * Returns true if the target scopes are a subset of the current entity's scopes, false otherwise.\n     * @param entity\n     * @param target\n     */\n    matchTarget(entity, target) {\n        const isNotAccessTokenCredential = entity.credentialType !== CredentialType.ACCESS_TOKEN &&\n            entity.credentialType !==\n                CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME;\n        if (isNotAccessTokenCredential || !entity.target) {\n            return false;\n        }\n        const entityScopeSet = ScopeSet.fromString(entity.target);\n        return entityScopeSet.containsScopeSet(target);\n    }\n    /**\n     * Returns true if the credential's tokenType or Authentication Scheme matches the one in the request, false otherwise\n     * @param entity\n     * @param tokenType\n     */\n    matchTokenType(entity, tokenType) {\n        return !!(entity.tokenType && entity.tokenType === tokenType);\n    }\n    /**\n     * Returns true if the credential's keyId matches the one in the request, false otherwise\n     * @param entity\n     * @param tokenType\n     */\n    matchKeyId(entity, keyId) {\n        return !!(entity.keyId && entity.keyId === keyId);\n    }\n    /**\n     * returns if a given cache entity is of the type appmetadata\n     * @param key\n     */\n    isAppMetadata(key) {\n        return key.indexOf(APP_METADATA) !== -1;\n    }\n    /**\n     * returns if a given cache entity is of the type authoritymetadata\n     * @param key\n     */\n    isAuthorityMetadata(key) {\n        return key.indexOf(AUTHORITY_METADATA_CONSTANTS.CACHE_KEY) !== -1;\n    }\n    /**\n     * returns cache key used for cloud instance metadata\n     */\n    generateAuthorityMetadataCacheKey(authority) {\n        return `${AUTHORITY_METADATA_CONSTANTS.CACHE_KEY}-${this.clientId}-${authority}`;\n    }\n    /**\n     * Helper to convert serialized data to object\n     * @param obj\n     * @param json\n     */\n    static toObject(obj, json) {\n        for (const propertyName in json) {\n            obj[propertyName] = json[propertyName];\n        }\n        return obj;\n    }\n}\n/** @internal */\nclass DefaultStorageClass extends CacheManager {\n    setAccount() {\n        const notImplErr = \"Storage interface - setAccount() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    getAccount() {\n        const notImplErr = \"Storage interface - getAccount() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    setIdTokenCredential() {\n        const notImplErr = \"Storage interface - setIdTokenCredential() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    getIdTokenCredential() {\n        const notImplErr = \"Storage interface - getIdTokenCredential() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    setAccessTokenCredential() {\n        const notImplErr = \"Storage interface - setAccessTokenCredential() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    getAccessTokenCredential() {\n        const notImplErr = \"Storage interface - getAccessTokenCredential() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    setRefreshTokenCredential() {\n        const notImplErr = \"Storage interface - setRefreshTokenCredential() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    getRefreshTokenCredential() {\n        const notImplErr = \"Storage interface - getRefreshTokenCredential() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    setAppMetadata() {\n        const notImplErr = \"Storage interface - setAppMetadata() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    getAppMetadata() {\n        const notImplErr = \"Storage interface - getAppMetadata() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    setServerTelemetry() {\n        const notImplErr = \"Storage interface - setServerTelemetry() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    getServerTelemetry() {\n        const notImplErr = \"Storage interface - getServerTelemetry() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    setAuthorityMetadata() {\n        const notImplErr = \"Storage interface - setAuthorityMetadata() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    getAuthorityMetadata() {\n        const notImplErr = \"Storage interface - getAuthorityMetadata() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    getAuthorityMetadataKeys() {\n        const notImplErr = \"Storage interface - getAuthorityMetadataKeys() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    setThrottlingCache() {\n        const notImplErr = \"Storage interface - setThrottlingCache() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    getThrottlingCache() {\n        const notImplErr = \"Storage interface - getThrottlingCache() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    removeItem() {\n        const notImplErr = \"Storage interface - removeItem() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    containsKey() {\n        const notImplErr = \"Storage interface - containsKey() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    getKeys() {\n        const notImplErr = \"Storage interface - getKeys() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    getAccountKeys() {\n        const notImplErr = \"Storage interface - getAccountKeys() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    getTokenKeys() {\n        const notImplErr = \"Storage interface - getTokenKeys() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    async clear() {\n        const notImplErr = \"Storage interface - clear() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    updateCredentialCacheKey() {\n        const notImplErr = \"Storage interface - updateCredentialCacheKey() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n}\n\nexport { CacheManager, DefaultStorageClass };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}