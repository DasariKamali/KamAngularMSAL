{"ast":null,"code":"/*! @azure/msal-browser v3.1.0 2023-09-05 */\n'use strict';\n\nimport _asyncToGenerator from \"C:/Users/v-dkamali/Documents/AngularMSALAD/microsoft-login/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { NativeConstants, NativeExtensionMethod } from '../../utils/BrowserConstants.mjs';\nimport { PerformanceEvents, AuthError, AuthenticationScheme } from '@azure/msal-common';\nimport { NativeAuthError } from '../../error/NativeAuthError.mjs';\nimport { createBrowserAuthError } from '../../error/BrowserAuthError.mjs';\nimport { nativeHandshakeTimeout, nativeExtensionNotInstalled } from '../../error/BrowserAuthErrorCodes.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nclass NativeMessageHandler {\n  constructor(logger, handshakeTimeoutMs, performanceClient, crypto, extensionId) {\n    this.logger = logger;\n    this.handshakeTimeoutMs = handshakeTimeoutMs;\n    this.extensionId = extensionId;\n    this.resolvers = new Map(); // Used for non-handshake messages\n    this.handshakeResolvers = new Map(); // Used for handshake messages\n    this.messageChannel = new MessageChannel();\n    this.windowListener = this.onWindowMessage.bind(this); // Window event callback doesn't have access to 'this' unless it's bound\n    this.performanceClient = performanceClient;\n    this.handshakeEvent = performanceClient.startMeasurement(PerformanceEvents.NativeMessageHandlerHandshake);\n    this.crypto = crypto;\n  }\n  /**\n   * Sends a given message to the extension and resolves with the extension response\n   * @param body\n   */\n  sendMessage(body) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      _this.logger.trace(\"NativeMessageHandler - sendMessage called.\");\n      const req = {\n        channel: NativeConstants.CHANNEL_ID,\n        extensionId: _this.extensionId,\n        responseId: _this.crypto.createNewGuid(),\n        body: body\n      };\n      _this.logger.trace(\"NativeMessageHandler - Sending request to browser extension\");\n      _this.logger.tracePii(`NativeMessageHandler - Sending request to browser extension: ${JSON.stringify(req)}`);\n      _this.messageChannel.port1.postMessage(req);\n      return new Promise((resolve, reject) => {\n        _this.resolvers.set(req.responseId, {\n          resolve,\n          reject\n        });\n      });\n    })();\n  }\n  /**\n   * Returns an instance of the MessageHandler that has successfully established a connection with an extension\n   * @param {Logger} logger\n   * @param {number} handshakeTimeoutMs\n   * @param {IPerformanceClient} performanceClient\n   * @param {ICrypto} crypto\n   */\n  static createProvider(logger, handshakeTimeoutMs, performanceClient, crypto) {\n    return _asyncToGenerator(function* () {\n      logger.trace(\"NativeMessageHandler - createProvider called.\");\n      try {\n        const preferredProvider = new NativeMessageHandler(logger, handshakeTimeoutMs, performanceClient, crypto, NativeConstants.PREFERRED_EXTENSION_ID);\n        yield preferredProvider.sendHandshakeRequest();\n        return preferredProvider;\n      } catch (e) {\n        // If preferred extension fails for whatever reason, fallback to using any installed extension\n        const backupProvider = new NativeMessageHandler(logger, handshakeTimeoutMs, performanceClient, crypto);\n        yield backupProvider.sendHandshakeRequest();\n        return backupProvider;\n      }\n    })();\n  }\n  /**\n   * Send handshake request helper.\n   */\n  sendHandshakeRequest() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      _this2.logger.trace(\"NativeMessageHandler - sendHandshakeRequest called.\");\n      // Register this event listener before sending handshake\n      window.addEventListener(\"message\", _this2.windowListener, false); // false is important, because content script message processing should work first\n      const req = {\n        channel: NativeConstants.CHANNEL_ID,\n        extensionId: _this2.extensionId,\n        responseId: _this2.crypto.createNewGuid(),\n        body: {\n          method: NativeExtensionMethod.HandshakeRequest\n        }\n      };\n      _this2.handshakeEvent.add({\n        extensionId: _this2.extensionId,\n        extensionHandshakeTimeoutMs: _this2.handshakeTimeoutMs\n      });\n      _this2.messageChannel.port1.onmessage = event => {\n        _this2.onChannelMessage(event);\n      };\n      window.postMessage(req, window.origin, [_this2.messageChannel.port2]);\n      return new Promise((resolve, reject) => {\n        _this2.handshakeResolvers.set(req.responseId, {\n          resolve,\n          reject\n        });\n        _this2.timeoutId = window.setTimeout(() => {\n          /*\n           * Throw an error if neither HandshakeResponse nor original Handshake request are received in a reasonable timeframe.\n           * This typically suggests an event handler stopped propagation of the Handshake request but did not respond to it on the MessageChannel port\n           */\n          window.removeEventListener(\"message\", _this2.windowListener, false);\n          _this2.messageChannel.port1.close();\n          _this2.messageChannel.port2.close();\n          _this2.handshakeEvent.end({\n            extensionHandshakeTimedOut: true,\n            success: false\n          });\n          reject(createBrowserAuthError(nativeHandshakeTimeout));\n          _this2.handshakeResolvers.delete(req.responseId);\n        }, _this2.handshakeTimeoutMs); // Use a reasonable timeout in milliseconds here\n      });\n    })();\n  }\n  /**\n   * Invoked when a message is posted to the window. If a handshake request is received it means the extension is not installed.\n   * @param event\n   */\n  onWindowMessage(event) {\n    this.logger.trace(\"NativeMessageHandler - onWindowMessage called\");\n    // We only accept messages from ourselves\n    if (event.source !== window) {\n      return;\n    }\n    const request = event.data;\n    if (!request.channel || request.channel !== NativeConstants.CHANNEL_ID) {\n      return;\n    }\n    if (request.extensionId && request.extensionId !== this.extensionId) {\n      return;\n    }\n    if (request.body.method === NativeExtensionMethod.HandshakeRequest) {\n      const handshakeResolver = this.handshakeResolvers.get(request.responseId);\n      /*\n       * Filter out responses with no matched resolvers sooner to keep channel ports open while waiting for\n       * the proper response.\n       */\n      if (!handshakeResolver) {\n        this.logger.trace(`NativeMessageHandler.onWindowMessage - resolver can't be found for request ${request.responseId}`);\n        return;\n      }\n      // If we receive this message back it means no extension intercepted the request, meaning no extension supporting handshake protocol is installed\n      this.logger.verbose(request.extensionId ? `Extension with id: ${request.extensionId} not installed` : \"No extension installed\");\n      clearTimeout(this.timeoutId);\n      this.messageChannel.port1.close();\n      this.messageChannel.port2.close();\n      window.removeEventListener(\"message\", this.windowListener, false);\n      this.handshakeEvent.end({\n        success: false,\n        extensionInstalled: false\n      });\n      handshakeResolver.reject(createBrowserAuthError(nativeExtensionNotInstalled));\n    }\n  }\n  /**\n   * Invoked when a message is received from the extension on the MessageChannel port\n   * @param event\n   */\n  onChannelMessage(event) {\n    this.logger.trace(\"NativeMessageHandler - onChannelMessage called.\");\n    const request = event.data;\n    const resolver = this.resolvers.get(request.responseId);\n    const handshakeResolver = this.handshakeResolvers.get(request.responseId);\n    try {\n      const method = request.body.method;\n      if (method === NativeExtensionMethod.Response) {\n        if (!resolver) {\n          return;\n        }\n        const response = request.body.response;\n        this.logger.trace(\"NativeMessageHandler - Received response from browser extension\");\n        this.logger.tracePii(`NativeMessageHandler - Received response from browser extension: ${JSON.stringify(response)}`);\n        if (response.status !== \"Success\") {\n          resolver.reject(NativeAuthError.createError(response.code, response.description, response.ext));\n        } else if (response.result) {\n          if (response.result[\"code\"] && response.result[\"description\"]) {\n            resolver.reject(NativeAuthError.createError(response.result[\"code\"], response.result[\"description\"], response.result[\"ext\"]));\n          } else {\n            resolver.resolve(response.result);\n          }\n        } else {\n          throw AuthError.createUnexpectedError(\"Event does not contain result.\");\n        }\n        this.resolvers.delete(request.responseId);\n      } else if (method === NativeExtensionMethod.HandshakeResponse) {\n        if (!handshakeResolver) {\n          this.logger.trace(`NativeMessageHandler.onChannelMessage - resolver can't be found for request ${request.responseId}`);\n          return;\n        }\n        clearTimeout(this.timeoutId); // Clear setTimeout\n        window.removeEventListener(\"message\", this.windowListener, false); // Remove 'No extension' listener\n        this.extensionId = request.extensionId;\n        this.extensionVersion = request.body.version;\n        this.logger.verbose(`NativeMessageHandler - Received HandshakeResponse from extension: ${this.extensionId}`);\n        this.handshakeEvent.end({\n          extensionInstalled: true,\n          success: true\n        });\n        handshakeResolver.resolve();\n        this.handshakeResolvers.delete(request.responseId);\n      }\n      // Do nothing if method is not Response or HandshakeResponse\n    } catch (err) {\n      this.logger.error(\"Error parsing response from WAM Extension\");\n      this.logger.errorPii(`Error parsing response from WAM Extension: ${err}`);\n      this.logger.errorPii(`Unable to parse ${event}`);\n      if (resolver) {\n        resolver.reject(err);\n      } else if (handshakeResolver) {\n        handshakeResolver.reject(err);\n      }\n    }\n  }\n  /**\n   * Returns the Id for the browser extension this handler is communicating with\n   * @returns\n   */\n  getExtensionId() {\n    return this.extensionId;\n  }\n  /**\n   * Returns the version for the browser extension this handler is communicating with\n   * @returns\n   */\n  getExtensionVersion() {\n    return this.extensionVersion;\n  }\n  /**\n   * Returns boolean indicating whether or not the request should attempt to use native broker\n   * @param logger\n   * @param config\n   * @param nativeExtensionProvider\n   * @param authenticationScheme\n   */\n  static isNativeAvailable(config, logger, nativeExtensionProvider, authenticationScheme) {\n    logger.trace(\"isNativeAvailable called\");\n    if (!config.system.allowNativeBroker) {\n      logger.trace(\"isNativeAvailable: allowNativeBroker is not enabled, returning false\");\n      // Developer disabled WAM\n      return false;\n    }\n    if (!nativeExtensionProvider) {\n      logger.trace(\"isNativeAvailable: WAM extension provider is not initialized, returning false\");\n      // Extension is not available\n      return false;\n    }\n    if (authenticationScheme) {\n      switch (authenticationScheme) {\n        case AuthenticationScheme.BEARER:\n        case AuthenticationScheme.POP:\n          logger.trace(\"isNativeAvailable: authenticationScheme is supported, returning true\");\n          return true;\n        default:\n          logger.trace(\"isNativeAvailable: authenticationScheme is not supported, returning false\");\n          return false;\n      }\n    }\n    return true;\n  }\n}\nexport { NativeMessageHandler };","map":{"version":3,"names":["_asyncToGenerator","NativeConstants","NativeExtensionMethod","PerformanceEvents","AuthError","AuthenticationScheme","NativeAuthError","createBrowserAuthError","nativeHandshakeTimeout","nativeExtensionNotInstalled","NativeMessageHandler","constructor","logger","handshakeTimeoutMs","performanceClient","crypto","extensionId","resolvers","Map","handshakeResolvers","messageChannel","MessageChannel","windowListener","onWindowMessage","bind","handshakeEvent","startMeasurement","NativeMessageHandlerHandshake","sendMessage","body","_this","trace","req","channel","CHANNEL_ID","responseId","createNewGuid","tracePii","JSON","stringify","port1","postMessage","Promise","resolve","reject","set","createProvider","preferredProvider","PREFERRED_EXTENSION_ID","sendHandshakeRequest","e","backupProvider","_this2","window","addEventListener","method","HandshakeRequest","add","extensionHandshakeTimeoutMs","onmessage","event","onChannelMessage","origin","port2","timeoutId","setTimeout","removeEventListener","close","end","extensionHandshakeTimedOut","success","delete","source","request","data","handshakeResolver","get","verbose","clearTimeout","extensionInstalled","resolver","Response","response","status","createError","code","description","ext","result","createUnexpectedError","HandshakeResponse","extensionVersion","version","err","error","errorPii","getExtensionId","getExtensionVersion","isNativeAvailable","config","nativeExtensionProvider","authenticationScheme","system","allowNativeBroker","BEARER","POP"],"sources":["C:/Users/v-dkamali/Documents/AngularMSALAD/microsoft-login/node_modules/@azure/msal-browser/dist/broker/nativeBroker/NativeMessageHandler.mjs"],"sourcesContent":["/*! @azure/msal-browser v3.1.0 2023-09-05 */\n'use strict';\nimport { NativeConstants, NativeExtensionMethod } from '../../utils/BrowserConstants.mjs';\nimport { PerformanceEvents, AuthError, AuthenticationScheme } from '@azure/msal-common';\nimport { NativeAuthError } from '../../error/NativeAuthError.mjs';\nimport { createBrowserAuthError } from '../../error/BrowserAuthError.mjs';\nimport { nativeHandshakeTimeout, nativeExtensionNotInstalled } from '../../error/BrowserAuthErrorCodes.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nclass NativeMessageHandler {\n    constructor(logger, handshakeTimeoutMs, performanceClient, crypto, extensionId) {\n        this.logger = logger;\n        this.handshakeTimeoutMs = handshakeTimeoutMs;\n        this.extensionId = extensionId;\n        this.resolvers = new Map(); // Used for non-handshake messages\n        this.handshakeResolvers = new Map(); // Used for handshake messages\n        this.messageChannel = new MessageChannel();\n        this.windowListener = this.onWindowMessage.bind(this); // Window event callback doesn't have access to 'this' unless it's bound\n        this.performanceClient = performanceClient;\n        this.handshakeEvent = performanceClient.startMeasurement(PerformanceEvents.NativeMessageHandlerHandshake);\n        this.crypto = crypto;\n    }\n    /**\n     * Sends a given message to the extension and resolves with the extension response\n     * @param body\n     */\n    async sendMessage(body) {\n        this.logger.trace(\"NativeMessageHandler - sendMessage called.\");\n        const req = {\n            channel: NativeConstants.CHANNEL_ID,\n            extensionId: this.extensionId,\n            responseId: this.crypto.createNewGuid(),\n            body: body,\n        };\n        this.logger.trace(\"NativeMessageHandler - Sending request to browser extension\");\n        this.logger.tracePii(`NativeMessageHandler - Sending request to browser extension: ${JSON.stringify(req)}`);\n        this.messageChannel.port1.postMessage(req);\n        return new Promise((resolve, reject) => {\n            this.resolvers.set(req.responseId, { resolve, reject });\n        });\n    }\n    /**\n     * Returns an instance of the MessageHandler that has successfully established a connection with an extension\n     * @param {Logger} logger\n     * @param {number} handshakeTimeoutMs\n     * @param {IPerformanceClient} performanceClient\n     * @param {ICrypto} crypto\n     */\n    static async createProvider(logger, handshakeTimeoutMs, performanceClient, crypto) {\n        logger.trace(\"NativeMessageHandler - createProvider called.\");\n        try {\n            const preferredProvider = new NativeMessageHandler(logger, handshakeTimeoutMs, performanceClient, crypto, NativeConstants.PREFERRED_EXTENSION_ID);\n            await preferredProvider.sendHandshakeRequest();\n            return preferredProvider;\n        }\n        catch (e) {\n            // If preferred extension fails for whatever reason, fallback to using any installed extension\n            const backupProvider = new NativeMessageHandler(logger, handshakeTimeoutMs, performanceClient, crypto);\n            await backupProvider.sendHandshakeRequest();\n            return backupProvider;\n        }\n    }\n    /**\n     * Send handshake request helper.\n     */\n    async sendHandshakeRequest() {\n        this.logger.trace(\"NativeMessageHandler - sendHandshakeRequest called.\");\n        // Register this event listener before sending handshake\n        window.addEventListener(\"message\", this.windowListener, false); // false is important, because content script message processing should work first\n        const req = {\n            channel: NativeConstants.CHANNEL_ID,\n            extensionId: this.extensionId,\n            responseId: this.crypto.createNewGuid(),\n            body: {\n                method: NativeExtensionMethod.HandshakeRequest,\n            },\n        };\n        this.handshakeEvent.add({\n            extensionId: this.extensionId,\n            extensionHandshakeTimeoutMs: this.handshakeTimeoutMs,\n        });\n        this.messageChannel.port1.onmessage = (event) => {\n            this.onChannelMessage(event);\n        };\n        window.postMessage(req, window.origin, [this.messageChannel.port2]);\n        return new Promise((resolve, reject) => {\n            this.handshakeResolvers.set(req.responseId, { resolve, reject });\n            this.timeoutId = window.setTimeout(() => {\n                /*\n                 * Throw an error if neither HandshakeResponse nor original Handshake request are received in a reasonable timeframe.\n                 * This typically suggests an event handler stopped propagation of the Handshake request but did not respond to it on the MessageChannel port\n                 */\n                window.removeEventListener(\"message\", this.windowListener, false);\n                this.messageChannel.port1.close();\n                this.messageChannel.port2.close();\n                this.handshakeEvent.end({\n                    extensionHandshakeTimedOut: true,\n                    success: false,\n                });\n                reject(createBrowserAuthError(nativeHandshakeTimeout));\n                this.handshakeResolvers.delete(req.responseId);\n            }, this.handshakeTimeoutMs); // Use a reasonable timeout in milliseconds here\n        });\n    }\n    /**\n     * Invoked when a message is posted to the window. If a handshake request is received it means the extension is not installed.\n     * @param event\n     */\n    onWindowMessage(event) {\n        this.logger.trace(\"NativeMessageHandler - onWindowMessage called\");\n        // We only accept messages from ourselves\n        if (event.source !== window) {\n            return;\n        }\n        const request = event.data;\n        if (!request.channel ||\n            request.channel !== NativeConstants.CHANNEL_ID) {\n            return;\n        }\n        if (request.extensionId && request.extensionId !== this.extensionId) {\n            return;\n        }\n        if (request.body.method === NativeExtensionMethod.HandshakeRequest) {\n            const handshakeResolver = this.handshakeResolvers.get(request.responseId);\n            /*\n             * Filter out responses with no matched resolvers sooner to keep channel ports open while waiting for\n             * the proper response.\n             */\n            if (!handshakeResolver) {\n                this.logger.trace(`NativeMessageHandler.onWindowMessage - resolver can't be found for request ${request.responseId}`);\n                return;\n            }\n            // If we receive this message back it means no extension intercepted the request, meaning no extension supporting handshake protocol is installed\n            this.logger.verbose(request.extensionId\n                ? `Extension with id: ${request.extensionId} not installed`\n                : \"No extension installed\");\n            clearTimeout(this.timeoutId);\n            this.messageChannel.port1.close();\n            this.messageChannel.port2.close();\n            window.removeEventListener(\"message\", this.windowListener, false);\n            this.handshakeEvent.end({\n                success: false,\n                extensionInstalled: false,\n            });\n            handshakeResolver.reject(createBrowserAuthError(nativeExtensionNotInstalled));\n        }\n    }\n    /**\n     * Invoked when a message is received from the extension on the MessageChannel port\n     * @param event\n     */\n    onChannelMessage(event) {\n        this.logger.trace(\"NativeMessageHandler - onChannelMessage called.\");\n        const request = event.data;\n        const resolver = this.resolvers.get(request.responseId);\n        const handshakeResolver = this.handshakeResolvers.get(request.responseId);\n        try {\n            const method = request.body.method;\n            if (method === NativeExtensionMethod.Response) {\n                if (!resolver) {\n                    return;\n                }\n                const response = request.body.response;\n                this.logger.trace(\"NativeMessageHandler - Received response from browser extension\");\n                this.logger.tracePii(`NativeMessageHandler - Received response from browser extension: ${JSON.stringify(response)}`);\n                if (response.status !== \"Success\") {\n                    resolver.reject(NativeAuthError.createError(response.code, response.description, response.ext));\n                }\n                else if (response.result) {\n                    if (response.result[\"code\"] &&\n                        response.result[\"description\"]) {\n                        resolver.reject(NativeAuthError.createError(response.result[\"code\"], response.result[\"description\"], response.result[\"ext\"]));\n                    }\n                    else {\n                        resolver.resolve(response.result);\n                    }\n                }\n                else {\n                    throw AuthError.createUnexpectedError(\"Event does not contain result.\");\n                }\n                this.resolvers.delete(request.responseId);\n            }\n            else if (method === NativeExtensionMethod.HandshakeResponse) {\n                if (!handshakeResolver) {\n                    this.logger.trace(`NativeMessageHandler.onChannelMessage - resolver can't be found for request ${request.responseId}`);\n                    return;\n                }\n                clearTimeout(this.timeoutId); // Clear setTimeout\n                window.removeEventListener(\"message\", this.windowListener, false); // Remove 'No extension' listener\n                this.extensionId = request.extensionId;\n                this.extensionVersion = request.body.version;\n                this.logger.verbose(`NativeMessageHandler - Received HandshakeResponse from extension: ${this.extensionId}`);\n                this.handshakeEvent.end({\n                    extensionInstalled: true,\n                    success: true,\n                });\n                handshakeResolver.resolve();\n                this.handshakeResolvers.delete(request.responseId);\n            }\n            // Do nothing if method is not Response or HandshakeResponse\n        }\n        catch (err) {\n            this.logger.error(\"Error parsing response from WAM Extension\");\n            this.logger.errorPii(`Error parsing response from WAM Extension: ${err}`);\n            this.logger.errorPii(`Unable to parse ${event}`);\n            if (resolver) {\n                resolver.reject(err);\n            }\n            else if (handshakeResolver) {\n                handshakeResolver.reject(err);\n            }\n        }\n    }\n    /**\n     * Returns the Id for the browser extension this handler is communicating with\n     * @returns\n     */\n    getExtensionId() {\n        return this.extensionId;\n    }\n    /**\n     * Returns the version for the browser extension this handler is communicating with\n     * @returns\n     */\n    getExtensionVersion() {\n        return this.extensionVersion;\n    }\n    /**\n     * Returns boolean indicating whether or not the request should attempt to use native broker\n     * @param logger\n     * @param config\n     * @param nativeExtensionProvider\n     * @param authenticationScheme\n     */\n    static isNativeAvailable(config, logger, nativeExtensionProvider, authenticationScheme) {\n        logger.trace(\"isNativeAvailable called\");\n        if (!config.system.allowNativeBroker) {\n            logger.trace(\"isNativeAvailable: allowNativeBroker is not enabled, returning false\");\n            // Developer disabled WAM\n            return false;\n        }\n        if (!nativeExtensionProvider) {\n            logger.trace(\"isNativeAvailable: WAM extension provider is not initialized, returning false\");\n            // Extension is not available\n            return false;\n        }\n        if (authenticationScheme) {\n            switch (authenticationScheme) {\n                case AuthenticationScheme.BEARER:\n                case AuthenticationScheme.POP:\n                    logger.trace(\"isNativeAvailable: authenticationScheme is supported, returning true\");\n                    return true;\n                default:\n                    logger.trace(\"isNativeAvailable: authenticationScheme is not supported, returning false\");\n                    return false;\n            }\n        }\n        return true;\n    }\n}\n\nexport { NativeMessageHandler };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}