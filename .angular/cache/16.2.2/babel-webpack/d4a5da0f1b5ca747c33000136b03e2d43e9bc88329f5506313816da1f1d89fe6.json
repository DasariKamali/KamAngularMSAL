{"ast":null,"code":"/*! @azure/msal-browser v3.1.0 2023-09-05 */\n'use strict';\n\nimport _asyncToGenerator from \"C:/Users/v-dkamali/Documents/AngularMSALAD/microsoft-login/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { PerformanceEvents, JoseHeader } from '@azure/msal-common';\nimport { base64Encode, urlEncode, urlEncodeArr } from '../encode/Base64Encode.mjs';\nimport { base64Decode } from '../encode/Base64Decode.mjs';\nimport { PkceGenerator } from './PkceGenerator.mjs';\nimport { BrowserCrypto } from './BrowserCrypto.mjs';\nimport { BrowserStringUtils } from '../utils/BrowserStringUtils.mjs';\nimport { createBrowserAuthError } from '../error/BrowserAuthError.mjs';\nimport { CryptoKeyStore } from '../cache/CryptoKeyStore.mjs';\nimport { cryptoKeyNotFound } from '../error/BrowserAuthErrorCodes.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * This class implements MSAL's crypto interface, which allows it to perform base64 encoding and decoding, generating cryptographically random GUIDs and\n * implementing Proof Key for Code Exchange specs for the OAuth Authorization Code Flow using PKCE (rfc here: https://tools.ietf.org/html/rfc7636).\n */\nclass CryptoOps {\n  constructor(logger, performanceClient) {\n    this.logger = logger;\n    // Browser crypto needs to be validated first before any other classes can be set.\n    this.browserCrypto = new BrowserCrypto(this.logger);\n    this.pkceGenerator = new PkceGenerator(this.browserCrypto);\n    this.cache = new CryptoKeyStore(this.logger);\n    this.performanceClient = performanceClient;\n  }\n  /**\n   * Creates a new random GUID - used to populate state and nonce.\n   * @returns string (GUID)\n   */\n  createNewGuid() {\n    return window.crypto.randomUUID();\n  }\n  /**\n   * Encodes input string to base64.\n   * @param input\n   */\n  base64Encode(input) {\n    return base64Encode(input);\n  }\n  /**\n   * Decodes input string from base64.\n   * @param input\n   */\n  base64Decode(input) {\n    return base64Decode(input);\n  }\n  /**\n   * Generates PKCE codes used in Authorization Code Flow.\n   */\n  generatePkceCodes() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      return _this.pkceGenerator.generateCodes();\n    })();\n  }\n  /**\n   * Generates a keypair, stores it and returns a thumbprint\n   * @param request\n   */\n  getPublicKeyThumbprint(request) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const publicKeyThumbMeasurement = _this2.performanceClient?.startMeasurement(PerformanceEvents.CryptoOptsGetPublicKeyThumbprint, request.correlationId);\n      // Generate Keypair\n      const keyPair = yield _this2.browserCrypto.generateKeyPair(CryptoOps.EXTRACTABLE, CryptoOps.POP_KEY_USAGES);\n      // Generate Thumbprint for Public Key\n      const publicKeyJwk = yield _this2.browserCrypto.exportJwk(keyPair.publicKey);\n      const pubKeyThumprintObj = {\n        e: publicKeyJwk.e,\n        kty: publicKeyJwk.kty,\n        n: publicKeyJwk.n\n      };\n      const publicJwkString = BrowserStringUtils.getSortedObjectString(pubKeyThumprintObj);\n      const publicJwkHash = yield _this2.hashString(publicJwkString);\n      // Generate Thumbprint for Private Key\n      const privateKeyJwk = yield _this2.browserCrypto.exportJwk(keyPair.privateKey);\n      // Re-import private key to make it unextractable\n      const unextractablePrivateKey = yield _this2.browserCrypto.importJwk(privateKeyJwk, false, [\"sign\"]);\n      // Store Keypair data in keystore\n      yield _this2.cache.asymmetricKeys.setItem(publicJwkHash, {\n        privateKey: unextractablePrivateKey,\n        publicKey: keyPair.publicKey,\n        requestMethod: request.resourceRequestMethod,\n        requestUri: request.resourceRequestUri\n      });\n      if (publicKeyThumbMeasurement) {\n        publicKeyThumbMeasurement.end({\n          success: true\n        });\n      }\n      return publicJwkHash;\n    })();\n  }\n  /**\n   * Removes cryptographic keypair from key store matching the keyId passed in\n   * @param kid\n   */\n  removeTokenBindingKey(kid) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      yield _this3.cache.asymmetricKeys.removeItem(kid);\n      const keyFound = yield _this3.cache.asymmetricKeys.containsKey(kid);\n      return !keyFound;\n    })();\n  }\n  /**\n   * Removes all cryptographic keys from IndexedDB storage\n   */\n  clearKeystore() {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      return yield _this4.cache.clear();\n    })();\n  }\n  /**\n   * Signs the given object as a jwt payload with private key retrieved by given kid.\n   * @param payload\n   * @param kid\n   */\n  signJwt(payload, kid, correlationId) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const signJwtMeasurement = _this5.performanceClient?.startMeasurement(PerformanceEvents.CryptoOptsSignJwt, correlationId);\n      const cachedKeyPair = yield _this5.cache.asymmetricKeys.getItem(kid);\n      if (!cachedKeyPair) {\n        throw createBrowserAuthError(cryptoKeyNotFound);\n      }\n      // Get public key as JWK\n      const publicKeyJwk = yield _this5.browserCrypto.exportJwk(cachedKeyPair.publicKey);\n      const publicKeyJwkString = BrowserStringUtils.getSortedObjectString(publicKeyJwk);\n      // Base64URL encode public key thumbprint with keyId only: BASE64URL({ kid: \"FULL_PUBLIC_KEY_HASH\" })\n      const encodedKeyIdThumbprint = urlEncode(JSON.stringify({\n        kid: kid\n      }));\n      // Generate header\n      const shrHeader = JoseHeader.getShrHeaderString({\n        kid: encodedKeyIdThumbprint,\n        alg: publicKeyJwk.alg\n      });\n      const encodedShrHeader = urlEncode(shrHeader);\n      // Generate payload\n      payload.cnf = {\n        jwk: JSON.parse(publicKeyJwkString)\n      };\n      const encodedPayload = urlEncode(JSON.stringify(payload));\n      // Form token string\n      const tokenString = `${encodedShrHeader}.${encodedPayload}`;\n      // Sign token\n      const tokenBuffer = BrowserStringUtils.stringToUtf8Arr(tokenString);\n      const signatureBuffer = yield _this5.browserCrypto.sign(cachedKeyPair.privateKey, tokenBuffer);\n      const encodedSignature = urlEncodeArr(new Uint8Array(signatureBuffer));\n      const signedJwt = `${tokenString}.${encodedSignature}`;\n      if (signJwtMeasurement) {\n        signJwtMeasurement.end({\n          success: true\n        });\n      }\n      return signedJwt;\n    })();\n  }\n  /**\n   * Returns the SHA-256 hash of an input string\n   * @param plainText\n   */\n  hashString(plainText) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      const hashBuffer = yield _this6.browserCrypto.sha256Digest(plainText);\n      const hashBytes = new Uint8Array(hashBuffer);\n      return urlEncodeArr(hashBytes);\n    })();\n  }\n}\nCryptoOps.POP_KEY_USAGES = [\"sign\", \"verify\"];\nCryptoOps.EXTRACTABLE = true;\nexport { CryptoOps };","map":{"version":3,"names":["_asyncToGenerator","PerformanceEvents","JoseHeader","base64Encode","urlEncode","urlEncodeArr","base64Decode","PkceGenerator","BrowserCrypto","BrowserStringUtils","createBrowserAuthError","CryptoKeyStore","cryptoKeyNotFound","CryptoOps","constructor","logger","performanceClient","browserCrypto","pkceGenerator","cache","createNewGuid","window","crypto","randomUUID","input","generatePkceCodes","_this","generateCodes","getPublicKeyThumbprint","request","_this2","publicKeyThumbMeasurement","startMeasurement","CryptoOptsGetPublicKeyThumbprint","correlationId","keyPair","generateKeyPair","EXTRACTABLE","POP_KEY_USAGES","publicKeyJwk","exportJwk","publicKey","pubKeyThumprintObj","e","kty","n","publicJwkString","getSortedObjectString","publicJwkHash","hashString","privateKeyJwk","privateKey","unextractablePrivateKey","importJwk","asymmetricKeys","setItem","requestMethod","resourceRequestMethod","requestUri","resourceRequestUri","end","success","removeTokenBindingKey","kid","_this3","removeItem","keyFound","containsKey","clearKeystore","_this4","clear","signJwt","payload","_this5","signJwtMeasurement","CryptoOptsSignJwt","cachedKeyPair","getItem","publicKeyJwkString","encodedKeyIdThumbprint","JSON","stringify","shrHeader","getShrHeaderString","alg","encodedShrHeader","cnf","jwk","parse","encodedPayload","tokenString","tokenBuffer","stringToUtf8Arr","signatureBuffer","sign","encodedSignature","Uint8Array","signedJwt","plainText","_this6","hashBuffer","sha256Digest","hashBytes"],"sources":["C:/Users/v-dkamali/Documents/AngularMSALAD/microsoft-login/node_modules/@azure/msal-browser/dist/crypto/CryptoOps.mjs"],"sourcesContent":["/*! @azure/msal-browser v3.1.0 2023-09-05 */\n'use strict';\nimport { PerformanceEvents, JoseHeader } from '@azure/msal-common';\nimport { base64Encode, urlEncode, urlEncodeArr } from '../encode/Base64Encode.mjs';\nimport { base64Decode } from '../encode/Base64Decode.mjs';\nimport { PkceGenerator } from './PkceGenerator.mjs';\nimport { BrowserCrypto } from './BrowserCrypto.mjs';\nimport { BrowserStringUtils } from '../utils/BrowserStringUtils.mjs';\nimport { createBrowserAuthError } from '../error/BrowserAuthError.mjs';\nimport { CryptoKeyStore } from '../cache/CryptoKeyStore.mjs';\nimport { cryptoKeyNotFound } from '../error/BrowserAuthErrorCodes.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * This class implements MSAL's crypto interface, which allows it to perform base64 encoding and decoding, generating cryptographically random GUIDs and\n * implementing Proof Key for Code Exchange specs for the OAuth Authorization Code Flow using PKCE (rfc here: https://tools.ietf.org/html/rfc7636).\n */\nclass CryptoOps {\n    constructor(logger, performanceClient) {\n        this.logger = logger;\n        // Browser crypto needs to be validated first before any other classes can be set.\n        this.browserCrypto = new BrowserCrypto(this.logger);\n        this.pkceGenerator = new PkceGenerator(this.browserCrypto);\n        this.cache = new CryptoKeyStore(this.logger);\n        this.performanceClient = performanceClient;\n    }\n    /**\n     * Creates a new random GUID - used to populate state and nonce.\n     * @returns string (GUID)\n     */\n    createNewGuid() {\n        return window.crypto.randomUUID();\n    }\n    /**\n     * Encodes input string to base64.\n     * @param input\n     */\n    base64Encode(input) {\n        return base64Encode(input);\n    }\n    /**\n     * Decodes input string from base64.\n     * @param input\n     */\n    base64Decode(input) {\n        return base64Decode(input);\n    }\n    /**\n     * Generates PKCE codes used in Authorization Code Flow.\n     */\n    async generatePkceCodes() {\n        return this.pkceGenerator.generateCodes();\n    }\n    /**\n     * Generates a keypair, stores it and returns a thumbprint\n     * @param request\n     */\n    async getPublicKeyThumbprint(request) {\n        const publicKeyThumbMeasurement = this.performanceClient?.startMeasurement(PerformanceEvents.CryptoOptsGetPublicKeyThumbprint, request.correlationId);\n        // Generate Keypair\n        const keyPair = await this.browserCrypto.generateKeyPair(CryptoOps.EXTRACTABLE, CryptoOps.POP_KEY_USAGES);\n        // Generate Thumbprint for Public Key\n        const publicKeyJwk = await this.browserCrypto.exportJwk(keyPair.publicKey);\n        const pubKeyThumprintObj = {\n            e: publicKeyJwk.e,\n            kty: publicKeyJwk.kty,\n            n: publicKeyJwk.n,\n        };\n        const publicJwkString = BrowserStringUtils.getSortedObjectString(pubKeyThumprintObj);\n        const publicJwkHash = await this.hashString(publicJwkString);\n        // Generate Thumbprint for Private Key\n        const privateKeyJwk = await this.browserCrypto.exportJwk(keyPair.privateKey);\n        // Re-import private key to make it unextractable\n        const unextractablePrivateKey = await this.browserCrypto.importJwk(privateKeyJwk, false, [\"sign\"]);\n        // Store Keypair data in keystore\n        await this.cache.asymmetricKeys.setItem(publicJwkHash, {\n            privateKey: unextractablePrivateKey,\n            publicKey: keyPair.publicKey,\n            requestMethod: request.resourceRequestMethod,\n            requestUri: request.resourceRequestUri,\n        });\n        if (publicKeyThumbMeasurement) {\n            publicKeyThumbMeasurement.end({\n                success: true,\n            });\n        }\n        return publicJwkHash;\n    }\n    /**\n     * Removes cryptographic keypair from key store matching the keyId passed in\n     * @param kid\n     */\n    async removeTokenBindingKey(kid) {\n        await this.cache.asymmetricKeys.removeItem(kid);\n        const keyFound = await this.cache.asymmetricKeys.containsKey(kid);\n        return !keyFound;\n    }\n    /**\n     * Removes all cryptographic keys from IndexedDB storage\n     */\n    async clearKeystore() {\n        return await this.cache.clear();\n    }\n    /**\n     * Signs the given object as a jwt payload with private key retrieved by given kid.\n     * @param payload\n     * @param kid\n     */\n    async signJwt(payload, kid, correlationId) {\n        const signJwtMeasurement = this.performanceClient?.startMeasurement(PerformanceEvents.CryptoOptsSignJwt, correlationId);\n        const cachedKeyPair = await this.cache.asymmetricKeys.getItem(kid);\n        if (!cachedKeyPair) {\n            throw createBrowserAuthError(cryptoKeyNotFound);\n        }\n        // Get public key as JWK\n        const publicKeyJwk = await this.browserCrypto.exportJwk(cachedKeyPair.publicKey);\n        const publicKeyJwkString = BrowserStringUtils.getSortedObjectString(publicKeyJwk);\n        // Base64URL encode public key thumbprint with keyId only: BASE64URL({ kid: \"FULL_PUBLIC_KEY_HASH\" })\n        const encodedKeyIdThumbprint = urlEncode(JSON.stringify({ kid: kid }));\n        // Generate header\n        const shrHeader = JoseHeader.getShrHeaderString({\n            kid: encodedKeyIdThumbprint,\n            alg: publicKeyJwk.alg,\n        });\n        const encodedShrHeader = urlEncode(shrHeader);\n        // Generate payload\n        payload.cnf = {\n            jwk: JSON.parse(publicKeyJwkString),\n        };\n        const encodedPayload = urlEncode(JSON.stringify(payload));\n        // Form token string\n        const tokenString = `${encodedShrHeader}.${encodedPayload}`;\n        // Sign token\n        const tokenBuffer = BrowserStringUtils.stringToUtf8Arr(tokenString);\n        const signatureBuffer = await this.browserCrypto.sign(cachedKeyPair.privateKey, tokenBuffer);\n        const encodedSignature = urlEncodeArr(new Uint8Array(signatureBuffer));\n        const signedJwt = `${tokenString}.${encodedSignature}`;\n        if (signJwtMeasurement) {\n            signJwtMeasurement.end({\n                success: true,\n            });\n        }\n        return signedJwt;\n    }\n    /**\n     * Returns the SHA-256 hash of an input string\n     * @param plainText\n     */\n    async hashString(plainText) {\n        const hashBuffer = await this.browserCrypto.sha256Digest(plainText);\n        const hashBytes = new Uint8Array(hashBuffer);\n        return urlEncodeArr(hashBytes);\n    }\n}\nCryptoOps.POP_KEY_USAGES = [\"sign\", \"verify\"];\nCryptoOps.EXTRACTABLE = true;\n\nexport { CryptoOps };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}