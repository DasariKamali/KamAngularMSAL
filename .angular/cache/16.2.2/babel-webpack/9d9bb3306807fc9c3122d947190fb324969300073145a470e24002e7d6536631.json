{"ast":null,"code":"/*! @azure/msal-browser v3.1.0 2023-09-05 */\n'use strict';\n\nimport _asyncToGenerator from \"C:/Users/v-dkamali/Documents/AngularMSALAD/microsoft-login/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { CacheManager, CredentialType, RefreshTokenEntity, AccessTokenEntity, IdTokenEntity, AccountEntity, ClientAuthError, AppMetadataEntity, ServerTelemetryEntity, AuthorityMetadataEntity, Constants, PersistentCacheKeys, ThrottlingEntity, StringUtils, ProtocolUtils, AuthToken, CacheRecord, DEFAULT_CRYPTO_IMPLEMENTATION, CcsCredentialType } from '@azure/msal-common';\nimport { createBrowserAuthError } from '../error/BrowserAuthError.mjs';\nimport { BrowserCacheLocation, StaticCacheKeys, InMemoryCacheKeys, TemporaryCacheKeys } from '../utils/BrowserConstants.mjs';\nimport { BrowserStorage } from './BrowserStorage.mjs';\nimport { MemoryStorage } from './MemoryStorage.mjs';\nimport { BrowserProtocolUtils } from '../utils/BrowserProtocolUtils.mjs';\nimport { base64Decode } from '../encode/Base64Decode.mjs';\nimport { base64Encode } from '../encode/Base64Encode.mjs';\nimport { noTokenRequestCacheError, unableToParseTokenRequestCacheError, noCachedAuthorityError, interactionInProgress } from '../error/BrowserAuthErrorCodes.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * This class implements the cache storage interface for MSAL through browser local or session storage.\n * Cookies are only used if storeAuthStateInCookie is true, and are only used for\n * parameters such as state and nonce, generally.\n */\nclass BrowserCacheManager extends CacheManager {\n  constructor(clientId, cacheConfig, cryptoImpl, logger) {\n    super(clientId, cryptoImpl, logger);\n    // Cookie life calculation (hours * minutes * seconds * ms)\n    this.COOKIE_LIFE_MULTIPLIER = 24 * 60 * 60 * 1000;\n    this.cacheConfig = cacheConfig;\n    this.logger = logger;\n    this.internalStorage = new MemoryStorage();\n    this.browserStorage = this.setupBrowserStorage(this.cacheConfig.cacheLocation);\n    this.temporaryCacheStorage = this.setupTemporaryCacheStorage(this.cacheConfig.temporaryCacheLocation, this.cacheConfig.cacheLocation);\n    // Migrate cache entries from older versions of MSAL.\n    if (cacheConfig.cacheMigrationEnabled) {\n      this.migrateCacheEntries();\n      this.createKeyMaps();\n    }\n  }\n  /**\n   * Returns a window storage class implementing the IWindowStorage interface that corresponds to the configured cacheLocation.\n   * @param cacheLocation\n   */\n  setupBrowserStorage(cacheLocation) {\n    switch (cacheLocation) {\n      case BrowserCacheLocation.LocalStorage:\n      case BrowserCacheLocation.SessionStorage:\n        try {\n          return new BrowserStorage(cacheLocation);\n        } catch (e) {\n          this.logger.verbose(e);\n          break;\n        }\n    }\n    this.cacheConfig.cacheLocation = BrowserCacheLocation.MemoryStorage;\n    return new MemoryStorage();\n  }\n  /**\n   * Returns a window storage class implementing the IWindowStorage interface that corresponds to the configured temporaryCacheLocation.\n   * @param temporaryCacheLocation\n   * @param cacheLocation\n   */\n  setupTemporaryCacheStorage(temporaryCacheLocation, cacheLocation) {\n    switch (cacheLocation) {\n      case BrowserCacheLocation.LocalStorage:\n      case BrowserCacheLocation.SessionStorage:\n        try {\n          // Temporary cache items will always be stored in session storage to mitigate problems caused by multiple tabs\n          return new BrowserStorage(temporaryCacheLocation || BrowserCacheLocation.SessionStorage);\n        } catch (e) {\n          this.logger.verbose(e);\n          return this.internalStorage;\n        }\n      case BrowserCacheLocation.MemoryStorage:\n      default:\n        return this.internalStorage;\n    }\n  }\n  /**\n   * Migrate all old cache entries to new schema. No rollback supported.\n   * @param storeAuthStateInCookie\n   */\n  migrateCacheEntries() {\n    const idTokenKey = `${Constants.CACHE_PREFIX}.${PersistentCacheKeys.ID_TOKEN}`;\n    const clientInfoKey = `${Constants.CACHE_PREFIX}.${PersistentCacheKeys.CLIENT_INFO}`;\n    const errorKey = `${Constants.CACHE_PREFIX}.${PersistentCacheKeys.ERROR}`;\n    const errorDescKey = `${Constants.CACHE_PREFIX}.${PersistentCacheKeys.ERROR_DESC}`;\n    const idTokenValue = this.browserStorage.getItem(idTokenKey);\n    const clientInfoValue = this.browserStorage.getItem(clientInfoKey);\n    const errorValue = this.browserStorage.getItem(errorKey);\n    const errorDescValue = this.browserStorage.getItem(errorDescKey);\n    const values = [idTokenValue, clientInfoValue, errorValue, errorDescValue];\n    const keysToMigrate = [PersistentCacheKeys.ID_TOKEN, PersistentCacheKeys.CLIENT_INFO, PersistentCacheKeys.ERROR, PersistentCacheKeys.ERROR_DESC];\n    keysToMigrate.forEach((cacheKey, index) => this.migrateCacheEntry(cacheKey, values[index]));\n  }\n  /**\n   * Utility function to help with migration.\n   * @param newKey\n   * @param value\n   * @param storeAuthStateInCookie\n   */\n  migrateCacheEntry(newKey, value) {\n    if (value) {\n      this.setTemporaryCache(newKey, value, true);\n    }\n  }\n  /**\n   * Searches all cache entries for MSAL accounts and creates the account key map\n   * This is used to migrate users from older versions of MSAL which did not create the map.\n   * @returns\n   */\n  createKeyMaps() {\n    this.logger.trace(\"BrowserCacheManager - createKeyMaps called.\");\n    const accountKeys = this.getItem(StaticCacheKeys.ACCOUNT_KEYS);\n    const tokenKeys = this.getItem(`${StaticCacheKeys.TOKEN_KEYS}.${this.clientId}`);\n    if (accountKeys && tokenKeys) {\n      this.logger.verbose(\"BrowserCacheManager:createKeyMaps - account and token key maps already exist, skipping migration.\");\n      // Key maps already exist, no need to iterate through cache\n      return;\n    }\n    const allKeys = this.browserStorage.getKeys();\n    allKeys.forEach(key => {\n      if (this.isCredentialKey(key)) {\n        // Get item, parse, validate and write key to map\n        const value = this.getItem(key);\n        if (value) {\n          const credObj = this.validateAndParseJson(value);\n          if (credObj && credObj.hasOwnProperty(\"credentialType\")) {\n            switch (credObj[\"credentialType\"]) {\n              case CredentialType.ID_TOKEN:\n                if (IdTokenEntity.isIdTokenEntity(credObj)) {\n                  this.logger.trace(\"BrowserCacheManager:createKeyMaps - idToken found, saving key to token key map\");\n                  this.logger.tracePii(`BrowserCacheManager:createKeyMaps - idToken with key: ${key} found, saving key to token key map`);\n                  const idTokenEntity = CacheManager.toObject(new IdTokenEntity(), credObj);\n                  const newKey = this.updateCredentialCacheKey(key, idTokenEntity);\n                  this.addTokenKey(newKey, CredentialType.ID_TOKEN);\n                  return;\n                } else {\n                  this.logger.trace(\"BrowserCacheManager:createKeyMaps - key found matching idToken schema with value containing idToken credentialType field but value failed IdTokenEntity validation, skipping.\");\n                  this.logger.tracePii(`BrowserCacheManager:createKeyMaps - failed idToken validation on key: ${key}`);\n                }\n                break;\n              case CredentialType.ACCESS_TOKEN:\n              case CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME:\n                if (AccessTokenEntity.isAccessTokenEntity(credObj)) {\n                  this.logger.trace(\"BrowserCacheManager:createKeyMaps - accessToken found, saving key to token key map\");\n                  this.logger.tracePii(`BrowserCacheManager:createKeyMaps - accessToken with key: ${key} found, saving key to token key map`);\n                  const accessTokenEntity = CacheManager.toObject(new AccessTokenEntity(), credObj);\n                  const newKey = this.updateCredentialCacheKey(key, accessTokenEntity);\n                  this.addTokenKey(newKey, CredentialType.ACCESS_TOKEN);\n                  return;\n                } else {\n                  this.logger.trace(\"BrowserCacheManager:createKeyMaps - key found matching accessToken schema with value containing accessToken credentialType field but value failed AccessTokenEntity validation, skipping.\");\n                  this.logger.tracePii(`BrowserCacheManager:createKeyMaps - failed accessToken validation on key: ${key}`);\n                }\n                break;\n              case CredentialType.REFRESH_TOKEN:\n                if (RefreshTokenEntity.isRefreshTokenEntity(credObj)) {\n                  this.logger.trace(\"BrowserCacheManager:createKeyMaps - refreshToken found, saving key to token key map\");\n                  this.logger.tracePii(`BrowserCacheManager:createKeyMaps - refreshToken with key: ${key} found, saving key to token key map`);\n                  const refreshTokenEntity = CacheManager.toObject(new RefreshTokenEntity(), credObj);\n                  const newKey = this.updateCredentialCacheKey(key, refreshTokenEntity);\n                  this.addTokenKey(newKey, CredentialType.REFRESH_TOKEN);\n                  return;\n                } else {\n                  this.logger.trace(\"BrowserCacheManager:createKeyMaps - key found matching refreshToken schema with value containing refreshToken credentialType field but value failed RefreshTokenEntity validation, skipping.\");\n                  this.logger.tracePii(`BrowserCacheManager:createKeyMaps - failed refreshToken validation on key: ${key}`);\n                }\n                break;\n              // If credentialType isn't one of our predefined ones, it may not be an MSAL cache value. Ignore.\n            }\n          }\n        }\n      }\n\n      if (this.isAccountKey(key)) {\n        const value = this.getItem(key);\n        if (value) {\n          const accountObj = this.validateAndParseJson(value);\n          if (accountObj && AccountEntity.isAccountEntity(accountObj)) {\n            this.logger.trace(\"BrowserCacheManager:createKeyMaps - account found, saving key to account key map\");\n            this.logger.tracePii(`BrowserCacheManager:createKeyMaps - account with key: ${key} found, saving key to account key map`);\n            this.addAccountKeyToMap(key);\n          }\n        }\n      }\n    });\n  }\n  /**\n   * Parses passed value as JSON object, JSON.parse() will throw an error.\n   * @param input\n   */\n  validateAndParseJson(jsonValue) {\n    try {\n      const parsedJson = JSON.parse(jsonValue);\n      /**\n       * There are edge cases in which JSON.parse will successfully parse a non-valid JSON object\n       * (e.g. JSON.parse will parse an escaped string into an unescaped string), so adding a type check\n       * of the parsed value is necessary in order to be certain that the string represents a valid JSON object.\n       *\n       */\n      return parsedJson && typeof parsedJson === \"object\" ? parsedJson : null;\n    } catch (error) {\n      return null;\n    }\n  }\n  /**\n   * fetches the entry from the browser storage based off the key\n   * @param key\n   */\n  getItem(key) {\n    return this.browserStorage.getItem(key);\n  }\n  /**\n   * sets the entry in the browser storage\n   * @param key\n   * @param value\n   */\n  setItem(key, value) {\n    this.browserStorage.setItem(key, value);\n  }\n  /**\n   * fetch the account entity from the platform cache\n   * @param accountKey\n   */\n  getAccount(accountKey) {\n    this.logger.trace(\"BrowserCacheManager.getAccount called\");\n    const account = this.getItem(accountKey);\n    if (!account) {\n      this.removeAccountKeyFromMap(accountKey);\n      return null;\n    }\n    const parsedAccount = this.validateAndParseJson(account);\n    if (!parsedAccount || !AccountEntity.isAccountEntity(parsedAccount)) {\n      this.removeAccountKeyFromMap(accountKey);\n      return null;\n    }\n    return CacheManager.toObject(new AccountEntity(), parsedAccount);\n  }\n  /**\n   * set account entity in the platform cache\n   * @param account\n   */\n  setAccount(account) {\n    this.logger.trace(\"BrowserCacheManager.setAccount called\");\n    const key = account.generateAccountKey();\n    this.setItem(key, JSON.stringify(account));\n    this.addAccountKeyToMap(key);\n  }\n  /**\n   * Returns the array of account keys currently cached\n   * @returns\n   */\n  getAccountKeys() {\n    this.logger.trace(\"BrowserCacheManager.getAccountKeys called\");\n    const accountKeys = this.getItem(StaticCacheKeys.ACCOUNT_KEYS);\n    if (accountKeys) {\n      return JSON.parse(accountKeys);\n    }\n    this.logger.verbose(\"BrowserCacheManager.getAccountKeys - No account keys found\");\n    return [];\n  }\n  /**\n   * Add a new account to the key map\n   * @param key\n   */\n  addAccountKeyToMap(key) {\n    this.logger.trace(\"BrowserCacheManager.addAccountKeyToMap called\");\n    this.logger.tracePii(`BrowserCacheManager.addAccountKeyToMap called with key: ${key}`);\n    const accountKeys = this.getAccountKeys();\n    if (accountKeys.indexOf(key) === -1) {\n      // Only add key if it does not already exist in the map\n      accountKeys.push(key);\n      this.setItem(StaticCacheKeys.ACCOUNT_KEYS, JSON.stringify(accountKeys));\n      this.logger.verbose(\"BrowserCacheManager.addAccountKeyToMap account key added\");\n    } else {\n      this.logger.verbose(\"BrowserCacheManager.addAccountKeyToMap account key already exists in map\");\n    }\n  }\n  /**\n   * Remove an account from the key map\n   * @param key\n   */\n  removeAccountKeyFromMap(key) {\n    this.logger.trace(\"BrowserCacheManager.removeAccountKeyFromMap called\");\n    this.logger.tracePii(`BrowserCacheManager.removeAccountKeyFromMap called with key: ${key}`);\n    const accountKeys = this.getAccountKeys();\n    const removalIndex = accountKeys.indexOf(key);\n    if (removalIndex > -1) {\n      accountKeys.splice(removalIndex, 1);\n      this.setItem(StaticCacheKeys.ACCOUNT_KEYS, JSON.stringify(accountKeys));\n      this.logger.trace(\"BrowserCacheManager.removeAccountKeyFromMap account key removed\");\n    } else {\n      this.logger.trace(\"BrowserCacheManager.removeAccountKeyFromMap key not found in existing map\");\n    }\n  }\n  /**\n   * Extends inherited removeAccount function to include removal of the account key from the map\n   * @param key\n   */\n  removeAccount(key) {\n    var _superprop_getRemoveAccount = () => super.removeAccount,\n      _this = this;\n    return _asyncToGenerator(function* () {\n      void _superprop_getRemoveAccount().call(_this, key);\n      _this.removeAccountKeyFromMap(key);\n    })();\n  }\n  /**\n   * Removes given idToken from the cache and from the key map\n   * @param key\n   */\n  removeIdToken(key) {\n    super.removeIdToken(key);\n    this.removeTokenKey(key, CredentialType.ID_TOKEN);\n  }\n  /**\n   * Removes given accessToken from the cache and from the key map\n   * @param key\n   */\n  removeAccessToken(key) {\n    var _superprop_getRemoveAccessToken = () => super.removeAccessToken,\n      _this2 = this;\n    return _asyncToGenerator(function* () {\n      void _superprop_getRemoveAccessToken().call(_this2, key);\n      _this2.removeTokenKey(key, CredentialType.ACCESS_TOKEN);\n    })();\n  }\n  /**\n   * Removes given refreshToken from the cache and from the key map\n   * @param key\n   */\n  removeRefreshToken(key) {\n    super.removeRefreshToken(key);\n    this.removeTokenKey(key, CredentialType.REFRESH_TOKEN);\n  }\n  /**\n   * Gets the keys for the cached tokens associated with this clientId\n   * @returns\n   */\n  getTokenKeys() {\n    this.logger.trace(\"BrowserCacheManager.getTokenKeys called\");\n    const item = this.getItem(`${StaticCacheKeys.TOKEN_KEYS}.${this.clientId}`);\n    if (item) {\n      const tokenKeys = this.validateAndParseJson(item);\n      if (tokenKeys && tokenKeys.hasOwnProperty(\"idToken\") && tokenKeys.hasOwnProperty(\"accessToken\") && tokenKeys.hasOwnProperty(\"refreshToken\")) {\n        return tokenKeys;\n      } else {\n        this.logger.error(\"BrowserCacheManager.getTokenKeys - Token keys found but in an unknown format. Returning empty key map.\");\n      }\n    } else {\n      this.logger.verbose(\"BrowserCacheManager.getTokenKeys - No token keys found\");\n    }\n    return {\n      idToken: [],\n      accessToken: [],\n      refreshToken: []\n    };\n  }\n  /**\n   * Adds the given key to the token key map\n   * @param key\n   * @param type\n   */\n  addTokenKey(key, type) {\n    this.logger.trace(\"BrowserCacheManager addTokenKey called\");\n    const tokenKeys = this.getTokenKeys();\n    switch (type) {\n      case CredentialType.ID_TOKEN:\n        if (tokenKeys.idToken.indexOf(key) === -1) {\n          this.logger.info(\"BrowserCacheManager: addTokenKey - idToken added to map\");\n          tokenKeys.idToken.push(key);\n        }\n        break;\n      case CredentialType.ACCESS_TOKEN:\n        if (tokenKeys.accessToken.indexOf(key) === -1) {\n          this.logger.info(\"BrowserCacheManager: addTokenKey - accessToken added to map\");\n          tokenKeys.accessToken.push(key);\n        }\n        break;\n      case CredentialType.REFRESH_TOKEN:\n        if (tokenKeys.refreshToken.indexOf(key) === -1) {\n          this.logger.info(\"BrowserCacheManager: addTokenKey - refreshToken added to map\");\n          tokenKeys.refreshToken.push(key);\n        }\n        break;\n      default:\n        this.logger.error(`BrowserCacheManager:addTokenKey - CredentialType provided invalid. CredentialType: ${type}`);\n        ClientAuthError.createUnexpectedCredentialTypeError();\n    }\n    this.setItem(`${StaticCacheKeys.TOKEN_KEYS}.${this.clientId}`, JSON.stringify(tokenKeys));\n  }\n  /**\n   * Removes the given key from the token key map\n   * @param key\n   * @param type\n   */\n  removeTokenKey(key, type) {\n    this.logger.trace(\"BrowserCacheManager removeTokenKey called\");\n    const tokenKeys = this.getTokenKeys();\n    switch (type) {\n      case CredentialType.ID_TOKEN:\n        this.logger.infoPii(`BrowserCacheManager: removeTokenKey - attempting to remove idToken with key: ${key} from map`);\n        const idRemoval = tokenKeys.idToken.indexOf(key);\n        if (idRemoval > -1) {\n          this.logger.info(\"BrowserCacheManager: removeTokenKey - idToken removed from map\");\n          tokenKeys.idToken.splice(idRemoval, 1);\n        } else {\n          this.logger.info(\"BrowserCacheManager: removeTokenKey - idToken does not exist in map. Either it was previously removed or it was never added.\");\n        }\n        break;\n      case CredentialType.ACCESS_TOKEN:\n        this.logger.infoPii(`BrowserCacheManager: removeTokenKey - attempting to remove accessToken with key: ${key} from map`);\n        const accessRemoval = tokenKeys.accessToken.indexOf(key);\n        if (accessRemoval > -1) {\n          this.logger.info(\"BrowserCacheManager: removeTokenKey - accessToken removed from map\");\n          tokenKeys.accessToken.splice(accessRemoval, 1);\n        } else {\n          this.logger.info(\"BrowserCacheManager: removeTokenKey - accessToken does not exist in map. Either it was previously removed or it was never added.\");\n        }\n        break;\n      case CredentialType.REFRESH_TOKEN:\n        this.logger.infoPii(`BrowserCacheManager: removeTokenKey - attempting to remove refreshToken with key: ${key} from map`);\n        const refreshRemoval = tokenKeys.refreshToken.indexOf(key);\n        if (refreshRemoval > -1) {\n          this.logger.info(\"BrowserCacheManager: removeTokenKey - refreshToken removed from map\");\n          tokenKeys.refreshToken.splice(refreshRemoval, 1);\n        } else {\n          this.logger.info(\"BrowserCacheManager: removeTokenKey - refreshToken does not exist in map. Either it was previously removed or it was never added.\");\n        }\n        break;\n      default:\n        this.logger.error(`BrowserCacheManager:removeTokenKey - CredentialType provided invalid. CredentialType: ${type}`);\n        ClientAuthError.createUnexpectedCredentialTypeError();\n    }\n    this.setItem(`${StaticCacheKeys.TOKEN_KEYS}.${this.clientId}`, JSON.stringify(tokenKeys));\n  }\n  /**\n   * generates idToken entity from a string\n   * @param idTokenKey\n   */\n  getIdTokenCredential(idTokenKey) {\n    const value = this.getItem(idTokenKey);\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getIdTokenCredential: called, no cache hit\");\n      this.removeTokenKey(idTokenKey, CredentialType.ID_TOKEN);\n      return null;\n    }\n    const parsedIdToken = this.validateAndParseJson(value);\n    if (!parsedIdToken || !IdTokenEntity.isIdTokenEntity(parsedIdToken)) {\n      this.logger.trace(\"BrowserCacheManager.getIdTokenCredential: called, no cache hit\");\n      this.removeTokenKey(idTokenKey, CredentialType.ID_TOKEN);\n      return null;\n    }\n    this.logger.trace(\"BrowserCacheManager.getIdTokenCredential: cache hit\");\n    return CacheManager.toObject(new IdTokenEntity(), parsedIdToken);\n  }\n  /**\n   * set IdToken credential to the platform cache\n   * @param idToken\n   */\n  setIdTokenCredential(idToken) {\n    this.logger.trace(\"BrowserCacheManager.setIdTokenCredential called\");\n    const idTokenKey = idToken.generateCredentialKey();\n    this.setItem(idTokenKey, JSON.stringify(idToken));\n    this.addTokenKey(idTokenKey, CredentialType.ID_TOKEN);\n  }\n  /**\n   * generates accessToken entity from a string\n   * @param key\n   */\n  getAccessTokenCredential(accessTokenKey) {\n    const value = this.getItem(accessTokenKey);\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getAccessTokenCredential: called, no cache hit\");\n      this.removeTokenKey(accessTokenKey, CredentialType.ACCESS_TOKEN);\n      return null;\n    }\n    const parsedAccessToken = this.validateAndParseJson(value);\n    if (!parsedAccessToken || !AccessTokenEntity.isAccessTokenEntity(parsedAccessToken)) {\n      this.logger.trace(\"BrowserCacheManager.getAccessTokenCredential: called, no cache hit\");\n      this.removeTokenKey(accessTokenKey, CredentialType.ACCESS_TOKEN);\n      return null;\n    }\n    this.logger.trace(\"BrowserCacheManager.getAccessTokenCredential: cache hit\");\n    return CacheManager.toObject(new AccessTokenEntity(), parsedAccessToken);\n  }\n  /**\n   * set accessToken credential to the platform cache\n   * @param accessToken\n   */\n  setAccessTokenCredential(accessToken) {\n    this.logger.trace(\"BrowserCacheManager.setAccessTokenCredential called\");\n    const accessTokenKey = accessToken.generateCredentialKey();\n    this.setItem(accessTokenKey, JSON.stringify(accessToken));\n    this.addTokenKey(accessTokenKey, CredentialType.ACCESS_TOKEN);\n  }\n  /**\n   * generates refreshToken entity from a string\n   * @param refreshTokenKey\n   */\n  getRefreshTokenCredential(refreshTokenKey) {\n    const value = this.getItem(refreshTokenKey);\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getRefreshTokenCredential: called, no cache hit\");\n      this.removeTokenKey(refreshTokenKey, CredentialType.REFRESH_TOKEN);\n      return null;\n    }\n    const parsedRefreshToken = this.validateAndParseJson(value);\n    if (!parsedRefreshToken || !RefreshTokenEntity.isRefreshTokenEntity(parsedRefreshToken)) {\n      this.logger.trace(\"BrowserCacheManager.getRefreshTokenCredential: called, no cache hit\");\n      this.removeTokenKey(refreshTokenKey, CredentialType.REFRESH_TOKEN);\n      return null;\n    }\n    this.logger.trace(\"BrowserCacheManager.getRefreshTokenCredential: cache hit\");\n    return CacheManager.toObject(new RefreshTokenEntity(), parsedRefreshToken);\n  }\n  /**\n   * set refreshToken credential to the platform cache\n   * @param refreshToken\n   */\n  setRefreshTokenCredential(refreshToken) {\n    this.logger.trace(\"BrowserCacheManager.setRefreshTokenCredential called\");\n    const refreshTokenKey = refreshToken.generateCredentialKey();\n    this.setItem(refreshTokenKey, JSON.stringify(refreshToken));\n    this.addTokenKey(refreshTokenKey, CredentialType.REFRESH_TOKEN);\n  }\n  /**\n   * fetch appMetadata entity from the platform cache\n   * @param appMetadataKey\n   */\n  getAppMetadata(appMetadataKey) {\n    const value = this.getItem(appMetadataKey);\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getAppMetadata: called, no cache hit\");\n      return null;\n    }\n    const parsedMetadata = this.validateAndParseJson(value);\n    if (!parsedMetadata || !AppMetadataEntity.isAppMetadataEntity(appMetadataKey, parsedMetadata)) {\n      this.logger.trace(\"BrowserCacheManager.getAppMetadata: called, no cache hit\");\n      return null;\n    }\n    this.logger.trace(\"BrowserCacheManager.getAppMetadata: cache hit\");\n    return CacheManager.toObject(new AppMetadataEntity(), parsedMetadata);\n  }\n  /**\n   * set appMetadata entity to the platform cache\n   * @param appMetadata\n   */\n  setAppMetadata(appMetadata) {\n    this.logger.trace(\"BrowserCacheManager.setAppMetadata called\");\n    const appMetadataKey = appMetadata.generateAppMetadataKey();\n    this.setItem(appMetadataKey, JSON.stringify(appMetadata));\n  }\n  /**\n   * fetch server telemetry entity from the platform cache\n   * @param serverTelemetryKey\n   */\n  getServerTelemetry(serverTelemetryKey) {\n    const value = this.getItem(serverTelemetryKey);\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getServerTelemetry: called, no cache hit\");\n      return null;\n    }\n    const parsedMetadata = this.validateAndParseJson(value);\n    if (!parsedMetadata || !ServerTelemetryEntity.isServerTelemetryEntity(serverTelemetryKey, parsedMetadata)) {\n      this.logger.trace(\"BrowserCacheManager.getServerTelemetry: called, no cache hit\");\n      return null;\n    }\n    this.logger.trace(\"BrowserCacheManager.getServerTelemetry: cache hit\");\n    return CacheManager.toObject(new ServerTelemetryEntity(), parsedMetadata);\n  }\n  /**\n   * set server telemetry entity to the platform cache\n   * @param serverTelemetryKey\n   * @param serverTelemetry\n   */\n  setServerTelemetry(serverTelemetryKey, serverTelemetry) {\n    this.logger.trace(\"BrowserCacheManager.setServerTelemetry called\");\n    this.setItem(serverTelemetryKey, JSON.stringify(serverTelemetry));\n  }\n  /**\n   *\n   */\n  getAuthorityMetadata(key) {\n    const value = this.internalStorage.getItem(key);\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getAuthorityMetadata: called, no cache hit\");\n      return null;\n    }\n    const parsedMetadata = this.validateAndParseJson(value);\n    if (parsedMetadata && AuthorityMetadataEntity.isAuthorityMetadataEntity(key, parsedMetadata)) {\n      this.logger.trace(\"BrowserCacheManager.getAuthorityMetadata: cache hit\");\n      return CacheManager.toObject(new AuthorityMetadataEntity(), parsedMetadata);\n    }\n    return null;\n  }\n  /**\n   *\n   */\n  getAuthorityMetadataKeys() {\n    const allKeys = this.internalStorage.getKeys();\n    return allKeys.filter(key => {\n      return this.isAuthorityMetadata(key);\n    });\n  }\n  /**\n   * Sets wrapper metadata in memory\n   * @param wrapperSKU\n   * @param wrapperVersion\n   */\n  setWrapperMetadata(wrapperSKU, wrapperVersion) {\n    this.internalStorage.setItem(InMemoryCacheKeys.WRAPPER_SKU, wrapperSKU);\n    this.internalStorage.setItem(InMemoryCacheKeys.WRAPPER_VER, wrapperVersion);\n  }\n  /**\n   * Returns wrapper metadata from in-memory storage\n   */\n  getWrapperMetadata() {\n    const sku = this.internalStorage.getItem(InMemoryCacheKeys.WRAPPER_SKU) || Constants.EMPTY_STRING;\n    const version = this.internalStorage.getItem(InMemoryCacheKeys.WRAPPER_VER) || Constants.EMPTY_STRING;\n    return [sku, version];\n  }\n  /**\n   *\n   * @param entity\n   */\n  setAuthorityMetadata(key, entity) {\n    this.logger.trace(\"BrowserCacheManager.setAuthorityMetadata called\");\n    this.internalStorage.setItem(key, JSON.stringify(entity));\n  }\n  /**\n   * Gets the active account\n   */\n  getActiveAccount() {\n    const activeAccountKeyFilters = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT_FILTERS);\n    const activeAccountValueFilters = this.getItem(activeAccountKeyFilters);\n    if (!activeAccountValueFilters) {\n      // if new active account cache type isn't found, it's an old version, so look for that instead\n      this.logger.trace(\"BrowserCacheManager.getActiveAccount: No active account filters cache schema found, looking for legacy schema\");\n      const activeAccountKeyLocal = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT);\n      const activeAccountValueLocal = this.getItem(activeAccountKeyLocal);\n      if (!activeAccountValueLocal) {\n        this.logger.trace(\"BrowserCacheManager.getActiveAccount: No active account found\");\n        return null;\n      }\n      const activeAccount = this.getAccountInfoByFilter({\n        localAccountId: activeAccountValueLocal\n      })[0] || null;\n      if (activeAccount) {\n        this.logger.trace(\"BrowserCacheManager.getActiveAccount: Legacy active account cache schema found\");\n        this.logger.trace(\"BrowserCacheManager.getActiveAccount: Adding active account filters cache schema\");\n        this.setActiveAccount(activeAccount);\n        return activeAccount;\n      }\n      return null;\n    }\n    const activeAccountValueObj = this.validateAndParseJson(activeAccountValueFilters);\n    if (activeAccountValueObj) {\n      this.logger.trace(\"BrowserCacheManager.getActiveAccount: Active account filters schema found\");\n      return this.getAccountInfoByFilter({\n        homeAccountId: activeAccountValueObj.homeAccountId,\n        localAccountId: activeAccountValueObj.localAccountId\n      })[0] || null;\n    }\n    this.logger.trace(\"BrowserCacheManager.getActiveAccount: No active account found\");\n    return null;\n  }\n  /**\n   * Sets the active account's localAccountId in cache\n   * @param account\n   */\n  setActiveAccount(account) {\n    const activeAccountKey = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT_FILTERS);\n    const activeAccountKeyLocal = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT);\n    if (account) {\n      this.logger.verbose(\"setActiveAccount: Active account set\");\n      const activeAccountValue = {\n        homeAccountId: account.homeAccountId,\n        localAccountId: account.localAccountId\n      };\n      this.browserStorage.setItem(activeAccountKey, JSON.stringify(activeAccountValue));\n      this.browserStorage.setItem(activeAccountKeyLocal, account.localAccountId);\n    } else {\n      this.logger.verbose(\"setActiveAccount: No account passed, active account not set\");\n      this.browserStorage.removeItem(activeAccountKey);\n      this.browserStorage.removeItem(activeAccountKeyLocal);\n    }\n  }\n  /**\n   * Gets a list of accounts that match all of the filters provided\n   * @param account\n   */\n  getAccountInfoByFilter(accountFilter) {\n    const allAccounts = this.getAllAccounts();\n    this.logger.trace(`BrowserCacheManager.getAccountInfoByFilter: total ${allAccounts.length} accounts found`);\n    return allAccounts.filter(accountObj => {\n      if (accountFilter.username && accountFilter.username.toLowerCase() !== accountObj.username.toLowerCase()) {\n        return false;\n      }\n      if (accountFilter.homeAccountId && accountFilter.homeAccountId !== accountObj.homeAccountId) {\n        return false;\n      }\n      if (accountFilter.localAccountId && accountFilter.localAccountId !== accountObj.localAccountId) {\n        return false;\n      }\n      if (accountFilter.tenantId && accountFilter.tenantId !== accountObj.tenantId) {\n        return false;\n      }\n      if (accountFilter.environment && accountFilter.environment !== accountObj.environment) {\n        return false;\n      }\n      return true;\n    });\n  }\n  /**\n   * Checks the cache for accounts matching loginHint or SID\n   * @param loginHint\n   * @param sid\n   */\n  getAccountInfoByHints(loginHint, sid) {\n    const matchingAccounts = this.getAllAccounts().filter(accountInfo => {\n      if (sid) {\n        const accountSid = accountInfo.idTokenClaims && accountInfo.idTokenClaims[\"sid\"];\n        return sid === accountSid;\n      }\n      if (loginHint) {\n        return loginHint === accountInfo.username;\n      }\n      return false;\n    });\n    if (matchingAccounts.length === 1) {\n      return matchingAccounts[0];\n    } else if (matchingAccounts.length > 1) {\n      throw ClientAuthError.createMultipleMatchingAccountsInCacheError();\n    }\n    return null;\n  }\n  /**\n   * fetch throttling entity from the platform cache\n   * @param throttlingCacheKey\n   */\n  getThrottlingCache(throttlingCacheKey) {\n    const value = this.getItem(throttlingCacheKey);\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getThrottlingCache: called, no cache hit\");\n      return null;\n    }\n    const parsedThrottlingCache = this.validateAndParseJson(value);\n    if (!parsedThrottlingCache || !ThrottlingEntity.isThrottlingEntity(throttlingCacheKey, parsedThrottlingCache)) {\n      this.logger.trace(\"BrowserCacheManager.getThrottlingCache: called, no cache hit\");\n      return null;\n    }\n    this.logger.trace(\"BrowserCacheManager.getThrottlingCache: cache hit\");\n    return CacheManager.toObject(new ThrottlingEntity(), parsedThrottlingCache);\n  }\n  /**\n   * set throttling entity to the platform cache\n   * @param throttlingCacheKey\n   * @param throttlingCache\n   */\n  setThrottlingCache(throttlingCacheKey, throttlingCache) {\n    this.logger.trace(\"BrowserCacheManager.setThrottlingCache called\");\n    this.setItem(throttlingCacheKey, JSON.stringify(throttlingCache));\n  }\n  /**\n   * Gets cache item with given key.\n   * Will retrieve from cookies if storeAuthStateInCookie is set to true.\n   * @param key\n   */\n  getTemporaryCache(cacheKey, generateKey) {\n    const key = generateKey ? this.generateCacheKey(cacheKey) : cacheKey;\n    if (this.cacheConfig.storeAuthStateInCookie) {\n      const itemCookie = this.getItemCookie(key);\n      if (itemCookie) {\n        this.logger.trace(\"BrowserCacheManager.getTemporaryCache: storeAuthStateInCookies set to true, retrieving from cookies\");\n        return itemCookie;\n      }\n    }\n    const value = this.temporaryCacheStorage.getItem(key);\n    if (!value) {\n      // If temp cache item not found in session/memory, check local storage for items set by old versions\n      if (this.cacheConfig.cacheLocation === BrowserCacheLocation.LocalStorage) {\n        const item = this.browserStorage.getItem(key);\n        if (item) {\n          this.logger.trace(\"BrowserCacheManager.getTemporaryCache: Temporary cache item found in local storage\");\n          return item;\n        }\n      }\n      this.logger.trace(\"BrowserCacheManager.getTemporaryCache: No cache item found in local storage\");\n      return null;\n    }\n    this.logger.trace(\"BrowserCacheManager.getTemporaryCache: Temporary cache item returned\");\n    return value;\n  }\n  /**\n   * Sets the cache item with the key and value given.\n   * Stores in cookie if storeAuthStateInCookie is set to true.\n   * This can cause cookie overflow if used incorrectly.\n   * @param key\n   * @param value\n   */\n  setTemporaryCache(cacheKey, value, generateKey) {\n    const key = generateKey ? this.generateCacheKey(cacheKey) : cacheKey;\n    this.temporaryCacheStorage.setItem(key, value);\n    if (this.cacheConfig.storeAuthStateInCookie) {\n      this.logger.trace(\"BrowserCacheManager.setTemporaryCache: storeAuthStateInCookie set to true, setting item cookie\");\n      this.setItemCookie(key, value);\n    }\n  }\n  /**\n   * Removes the cache item with the given key.\n   * Will also clear the cookie item if storeAuthStateInCookie is set to true.\n   * @param key\n   */\n  removeItem(key) {\n    this.browserStorage.removeItem(key);\n    this.temporaryCacheStorage.removeItem(key);\n    if (this.cacheConfig.storeAuthStateInCookie) {\n      this.logger.trace(\"BrowserCacheManager.removeItem: storeAuthStateInCookie is true, clearing item cookie\");\n      this.clearItemCookie(key);\n    }\n  }\n  /**\n   * Checks whether key is in cache.\n   * @param key\n   */\n  containsKey(key) {\n    return this.browserStorage.containsKey(key) || this.temporaryCacheStorage.containsKey(key);\n  }\n  /**\n   * Gets all keys in window.\n   */\n  getKeys() {\n    return [...this.browserStorage.getKeys(), ...this.temporaryCacheStorage.getKeys()];\n  }\n  /**\n   * Clears all cache entries created by MSAL.\n   */\n  clear() {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      // Removes all accounts and their credentials\n      yield _this3.removeAllAccounts();\n      _this3.removeAppMetadata();\n      // Removes all remaining MSAL cache items\n      _this3.getKeys().forEach(cacheKey => {\n        // Check if key contains msal prefix; For now, we are clearing all the cache items created by MSAL.js\n        if ((_this3.browserStorage.containsKey(cacheKey) || _this3.temporaryCacheStorage.containsKey(cacheKey)) && (cacheKey.indexOf(Constants.CACHE_PREFIX) !== -1 || cacheKey.indexOf(_this3.clientId) !== -1)) {\n          _this3.removeItem(cacheKey);\n        }\n      });\n      _this3.internalStorage.clear();\n    })();\n  }\n  /**\n   * Clears all access tokes that have claims prior to saving the current one\n   * @param credential\n   * @returns\n   */\n  clearTokensAndKeysWithClaims() {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const tokenKeys = _this4.getTokenKeys();\n      const removedAccessTokens = [];\n      tokenKeys.accessToken.forEach(key => {\n        // if the access token has claims in its key, remove the token key and the token\n        const credential = _this4.getAccessTokenCredential(key);\n        if (credential?.requestedClaimsHash && key.includes(credential.requestedClaimsHash.toLowerCase())) {\n          removedAccessTokens.push(_this4.removeAccessToken(key));\n        }\n      });\n      yield Promise.all(removedAccessTokens);\n      // warn if any access tokens are removed\n      if (removedAccessTokens.length > 0) {\n        _this4.logger.warning(`${removedAccessTokens.length} access tokens with claims in the cache keys have been removed from the cache.`);\n      }\n    })();\n  }\n  /**\n   * Add value to cookies\n   * @param cookieName\n   * @param cookieValue\n   * @param expires\n   */\n  setItemCookie(cookieName, cookieValue, expires) {\n    let cookieStr = `${encodeURIComponent(cookieName)}=${encodeURIComponent(cookieValue)};path=/;SameSite=Lax;`;\n    if (expires) {\n      const expireTime = this.getCookieExpirationTime(expires);\n      cookieStr += `expires=${expireTime};`;\n    }\n    if (this.cacheConfig.secureCookies) {\n      cookieStr += \"Secure;\";\n    }\n    document.cookie = cookieStr;\n  }\n  /**\n   * Get one item by key from cookies\n   * @param cookieName\n   */\n  getItemCookie(cookieName) {\n    const name = `${encodeURIComponent(cookieName)}=`;\n    const cookieList = document.cookie.split(\";\");\n    for (let i = 0; i < cookieList.length; i++) {\n      let cookie = cookieList[i];\n      while (cookie.charAt(0) === \" \") {\n        cookie = cookie.substring(1);\n      }\n      if (cookie.indexOf(name) === 0) {\n        return decodeURIComponent(cookie.substring(name.length, cookie.length));\n      }\n    }\n    return Constants.EMPTY_STRING;\n  }\n  /**\n   * Clear all msal-related cookies currently set in the browser. Should only be used to clear temporary cache items.\n   */\n  clearMsalCookies() {\n    const cookiePrefix = `${Constants.CACHE_PREFIX}.${this.clientId}`;\n    const cookieList = document.cookie.split(\";\");\n    cookieList.forEach(cookie => {\n      while (cookie.charAt(0) === \" \") {\n        // eslint-disable-next-line no-param-reassign\n        cookie = cookie.substring(1);\n      }\n      if (cookie.indexOf(cookiePrefix) === 0) {\n        const cookieKey = cookie.split(\"=\")[0];\n        this.clearItemCookie(cookieKey);\n      }\n    });\n  }\n  /**\n   * Clear an item in the cookies by key\n   * @param cookieName\n   */\n  clearItemCookie(cookieName) {\n    this.setItemCookie(cookieName, Constants.EMPTY_STRING, -1);\n  }\n  /**\n   * Get cookie expiration time\n   * @param cookieLifeDays\n   */\n  getCookieExpirationTime(cookieLifeDays) {\n    const today = new Date();\n    const expr = new Date(today.getTime() + cookieLifeDays * this.COOKIE_LIFE_MULTIPLIER);\n    return expr.toUTCString();\n  }\n  /**\n   * Gets the cache object referenced by the browser\n   */\n  getCache() {\n    return this.browserStorage;\n  }\n  /**\n   * interface compat, we cannot overwrite browser cache; Functionality is supported by individual entities in browser\n   */\n  setCache() {\n    // sets nothing\n  }\n  /**\n   * Prepend msal.<client-id> to each key; Skip for any JSON object as Key (defined schemas do not need the key appended: AccessToken Keys or the upcoming schema)\n   * @param key\n   * @param addInstanceId\n   */\n  generateCacheKey(key) {\n    const generatedKey = this.validateAndParseJson(key);\n    if (!generatedKey) {\n      if (StringUtils.startsWith(key, Constants.CACHE_PREFIX) || StringUtils.startsWith(key, PersistentCacheKeys.ADAL_ID_TOKEN)) {\n        return key;\n      }\n      return `${Constants.CACHE_PREFIX}.${this.clientId}.${key}`;\n    }\n    return JSON.stringify(key);\n  }\n  /**\n   * Create authorityKey to cache authority\n   * @param state\n   */\n  generateAuthorityKey(stateString) {\n    const {\n      libraryState: {\n        id: stateId\n      }\n    } = ProtocolUtils.parseRequestState(this.cryptoImpl, stateString);\n    return this.generateCacheKey(`${TemporaryCacheKeys.AUTHORITY}.${stateId}`);\n  }\n  /**\n   * Create Nonce key to cache nonce\n   * @param state\n   */\n  generateNonceKey(stateString) {\n    const {\n      libraryState: {\n        id: stateId\n      }\n    } = ProtocolUtils.parseRequestState(this.cryptoImpl, stateString);\n    return this.generateCacheKey(`${TemporaryCacheKeys.NONCE_IDTOKEN}.${stateId}`);\n  }\n  /**\n   * Creates full cache key for the request state\n   * @param stateString State string for the request\n   */\n  generateStateKey(stateString) {\n    // Use the library state id to key temp storage for uniqueness for multiple concurrent requests\n    const {\n      libraryState: {\n        id: stateId\n      }\n    } = ProtocolUtils.parseRequestState(this.cryptoImpl, stateString);\n    return this.generateCacheKey(`${TemporaryCacheKeys.REQUEST_STATE}.${stateId}`);\n  }\n  /**\n   * Gets the cached authority based on the cached state. Returns empty if no cached state found.\n   */\n  getCachedAuthority(cachedState) {\n    const stateCacheKey = this.generateStateKey(cachedState);\n    const state = this.getTemporaryCache(stateCacheKey);\n    if (!state) {\n      return null;\n    }\n    const authorityCacheKey = this.generateAuthorityKey(state);\n    return this.getTemporaryCache(authorityCacheKey);\n  }\n  /**\n   * Updates account, authority, and state in cache\n   * @param serverAuthenticationRequest\n   * @param account\n   */\n  updateCacheEntries(state, nonce, authorityInstance, loginHint, account) {\n    this.logger.trace(\"BrowserCacheManager.updateCacheEntries called\");\n    // Cache the request state\n    const stateCacheKey = this.generateStateKey(state);\n    this.setTemporaryCache(stateCacheKey, state, false);\n    // Cache the nonce\n    const nonceCacheKey = this.generateNonceKey(state);\n    this.setTemporaryCache(nonceCacheKey, nonce, false);\n    // Cache authorityKey\n    const authorityCacheKey = this.generateAuthorityKey(state);\n    this.setTemporaryCache(authorityCacheKey, authorityInstance, false);\n    if (account) {\n      const ccsCredential = {\n        credential: account.homeAccountId,\n        type: CcsCredentialType.HOME_ACCOUNT_ID\n      };\n      this.setTemporaryCache(TemporaryCacheKeys.CCS_CREDENTIAL, JSON.stringify(ccsCredential), true);\n    } else if (loginHint) {\n      const ccsCredential = {\n        credential: loginHint,\n        type: CcsCredentialType.UPN\n      };\n      this.setTemporaryCache(TemporaryCacheKeys.CCS_CREDENTIAL, JSON.stringify(ccsCredential), true);\n    }\n  }\n  /**\n   * Reset all temporary cache items\n   * @param state\n   */\n  resetRequestCache(state) {\n    this.logger.trace(\"BrowserCacheManager.resetRequestCache called\");\n    // check state and remove associated cache items\n    if (state) {\n      this.getKeys().forEach(key => {\n        if (key.indexOf(state) !== -1) {\n          this.removeItem(key);\n        }\n      });\n      // delete generic interactive request parameters\n      this.removeItem(this.generateStateKey(state));\n      this.removeItem(this.generateNonceKey(state));\n      this.removeItem(this.generateAuthorityKey(state));\n    }\n    this.removeItem(this.generateCacheKey(TemporaryCacheKeys.REQUEST_PARAMS));\n    this.removeItem(this.generateCacheKey(TemporaryCacheKeys.ORIGIN_URI));\n    this.removeItem(this.generateCacheKey(TemporaryCacheKeys.URL_HASH));\n    this.removeItem(this.generateCacheKey(TemporaryCacheKeys.CORRELATION_ID));\n    this.removeItem(this.generateCacheKey(TemporaryCacheKeys.CCS_CREDENTIAL));\n    this.removeItem(this.generateCacheKey(TemporaryCacheKeys.NATIVE_REQUEST));\n    this.setInteractionInProgress(false);\n  }\n  /**\n   * Removes temporary cache for the provided state\n   * @param stateString\n   */\n  cleanRequestByState(stateString) {\n    this.logger.trace(\"BrowserCacheManager.cleanRequestByState called\");\n    // Interaction is completed - remove interaction status.\n    if (stateString) {\n      const stateKey = this.generateStateKey(stateString);\n      const cachedState = this.temporaryCacheStorage.getItem(stateKey);\n      this.logger.infoPii(`BrowserCacheManager.cleanRequestByState: Removing temporary cache items for state: ${cachedState}`);\n      this.resetRequestCache(cachedState || Constants.EMPTY_STRING);\n    }\n    this.clearMsalCookies();\n  }\n  /**\n   * Looks in temporary cache for any state values with the provided interactionType and removes all temporary cache items for that state\n   * Used in scenarios where temp cache needs to be cleaned but state is not known, such as clicking browser back button.\n   * @param interactionType\n   */\n  cleanRequestByInteractionType(interactionType) {\n    this.logger.trace(\"BrowserCacheManager.cleanRequestByInteractionType called\");\n    // Loop through all keys to find state key\n    this.getKeys().forEach(key => {\n      // If this key is not the state key, move on\n      if (key.indexOf(TemporaryCacheKeys.REQUEST_STATE) === -1) {\n        return;\n      }\n      // Retrieve state value, return if not a valid value\n      const stateValue = this.temporaryCacheStorage.getItem(key);\n      if (!stateValue) {\n        return;\n      }\n      // Extract state and ensure it matches given InteractionType, then clean request cache\n      const parsedState = BrowserProtocolUtils.extractBrowserRequestState(this.cryptoImpl, stateValue);\n      if (parsedState && parsedState.interactionType === interactionType) {\n        this.logger.infoPii(`BrowserCacheManager.cleanRequestByInteractionType: Removing temporary cache items for state: ${stateValue}`);\n        this.resetRequestCache(stateValue);\n      }\n    });\n    this.clearMsalCookies();\n    this.setInteractionInProgress(false);\n  }\n  cacheCodeRequest(authCodeRequest) {\n    this.logger.trace(\"BrowserCacheManager.cacheCodeRequest called\");\n    const encodedValue = base64Encode(JSON.stringify(authCodeRequest));\n    this.setTemporaryCache(TemporaryCacheKeys.REQUEST_PARAMS, encodedValue, true);\n  }\n  /**\n   * Gets the token exchange parameters from the cache. Throws an error if nothing is found.\n   */\n  getCachedRequest(state) {\n    this.logger.trace(\"BrowserCacheManager.getCachedRequest called\");\n    // Get token request from cache and parse as TokenExchangeParameters.\n    const encodedTokenRequest = this.getTemporaryCache(TemporaryCacheKeys.REQUEST_PARAMS, true);\n    if (!encodedTokenRequest) {\n      throw createBrowserAuthError(noTokenRequestCacheError);\n    }\n    let parsedRequest;\n    try {\n      parsedRequest = JSON.parse(base64Decode(encodedTokenRequest));\n    } catch (e) {\n      this.logger.errorPii(`Attempted to parse: ${encodedTokenRequest}`);\n      this.logger.error(`Parsing cached token request threw with error: ${e}`);\n      throw createBrowserAuthError(unableToParseTokenRequestCacheError);\n    }\n    this.removeItem(this.generateCacheKey(TemporaryCacheKeys.REQUEST_PARAMS));\n    // Get cached authority and use if no authority is cached with request.\n    if (!parsedRequest.authority) {\n      const authorityCacheKey = this.generateAuthorityKey(state);\n      const cachedAuthority = this.getTemporaryCache(authorityCacheKey);\n      if (!cachedAuthority) {\n        throw createBrowserAuthError(noCachedAuthorityError);\n      }\n      parsedRequest.authority = cachedAuthority;\n    }\n    return parsedRequest;\n  }\n  /**\n   * Gets cached native request for redirect flows\n   */\n  getCachedNativeRequest() {\n    this.logger.trace(\"BrowserCacheManager.getCachedNativeRequest called\");\n    const cachedRequest = this.getTemporaryCache(TemporaryCacheKeys.NATIVE_REQUEST, true);\n    if (!cachedRequest) {\n      this.logger.trace(\"BrowserCacheManager.getCachedNativeRequest: No cached native request found\");\n      return null;\n    }\n    const parsedRequest = this.validateAndParseJson(cachedRequest);\n    if (!parsedRequest) {\n      this.logger.error(\"BrowserCacheManager.getCachedNativeRequest: Unable to parse native request\");\n      return null;\n    }\n    return parsedRequest;\n  }\n  isInteractionInProgress(matchClientId) {\n    const clientId = this.getInteractionInProgress();\n    if (matchClientId) {\n      return clientId === this.clientId;\n    } else {\n      return !!clientId;\n    }\n  }\n  getInteractionInProgress() {\n    const key = `${Constants.CACHE_PREFIX}.${TemporaryCacheKeys.INTERACTION_STATUS_KEY}`;\n    return this.getTemporaryCache(key, false);\n  }\n  setInteractionInProgress(inProgress) {\n    // Ensure we don't overwrite interaction in progress for a different clientId\n    const key = `${Constants.CACHE_PREFIX}.${TemporaryCacheKeys.INTERACTION_STATUS_KEY}`;\n    if (inProgress) {\n      if (this.getInteractionInProgress()) {\n        throw createBrowserAuthError(interactionInProgress);\n      } else {\n        // No interaction is in progress\n        this.setTemporaryCache(key, this.clientId, false);\n      }\n    } else if (!inProgress && this.getInteractionInProgress() === this.clientId) {\n      this.removeItem(key);\n    }\n  }\n  /**\n   * Returns username retrieved from ADAL or MSAL v1 idToken\n   * @deprecated\n   */\n  getLegacyLoginHint() {\n    // Only check for adal/msal token if no SSO params are being used\n    const adalIdTokenString = this.getTemporaryCache(PersistentCacheKeys.ADAL_ID_TOKEN);\n    if (adalIdTokenString) {\n      this.browserStorage.removeItem(PersistentCacheKeys.ADAL_ID_TOKEN);\n      this.logger.verbose(\"Cached ADAL id token retrieved.\");\n    }\n    // Check for cached MSAL v1 id token\n    const msalIdTokenString = this.getTemporaryCache(PersistentCacheKeys.ID_TOKEN, true);\n    if (msalIdTokenString) {\n      this.removeItem(this.generateCacheKey(PersistentCacheKeys.ID_TOKEN));\n      this.logger.verbose(\"Cached MSAL.js v1 id token retrieved\");\n    }\n    const cachedIdTokenString = msalIdTokenString || adalIdTokenString;\n    if (cachedIdTokenString) {\n      const idTokenClaims = AuthToken.extractTokenClaims(cachedIdTokenString, base64Decode);\n      if (idTokenClaims.preferred_username) {\n        this.logger.verbose(\"No SSO params used and ADAL/MSAL v1 token retrieved, setting ADAL/MSAL v1 preferred_username as loginHint\");\n        return idTokenClaims.preferred_username;\n      } else if (idTokenClaims.upn) {\n        this.logger.verbose(\"No SSO params used and ADAL/MSAL v1 token retrieved, setting ADAL/MSAL v1 upn as loginHint\");\n        return idTokenClaims.upn;\n      } else {\n        this.logger.verbose(\"No SSO params used and ADAL/MSAL v1 token retrieved, however, no account hint claim found. Enable preferred_username or upn id token claim to get SSO.\");\n      }\n    }\n    return null;\n  }\n  /**\n   * Updates a credential's cache key if the current cache key is outdated\n   */\n  updateCredentialCacheKey(currentCacheKey, credential) {\n    const updatedCacheKey = credential.generateCredentialKey();\n    if (currentCacheKey !== updatedCacheKey) {\n      const cacheItem = this.getItem(currentCacheKey);\n      if (cacheItem) {\n        this.removeItem(currentCacheKey);\n        this.setItem(updatedCacheKey, cacheItem);\n        this.logger.verbose(`Updated an outdated ${credential.credentialType} cache key`);\n        return updatedCacheKey;\n      } else {\n        this.logger.error(`Attempted to update an outdated ${credential.credentialType} cache key but no item matching the outdated key was found in storage`);\n      }\n    }\n    return currentCacheKey;\n  }\n  /**\n   * Returns application id as redirect context during AcquireTokenRedirect flow.\n   */\n  getRedirectRequestContext() {\n    return this.getTemporaryCache(TemporaryCacheKeys.REDIRECT_CONTEXT, true);\n  }\n  /**\n   * Sets application id as the redirect context during AcquireTokenRedirect flow.\n   * @param value\n   */\n  setRedirectRequestContext(value) {\n    this.setTemporaryCache(TemporaryCacheKeys.REDIRECT_CONTEXT, value, true);\n  }\n  /**\n   * Builds credential entities from AuthenticationResult object and saves the resulting credentials to the cache\n   * @param result\n   * @param request\n   */\n  hydrateCache(result, request) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const idTokenEntity = IdTokenEntity.createIdTokenEntity(result.account?.homeAccountId, result.account?.environment, result.idToken, _this5.clientId, result.tenantId);\n      let claimsHash;\n      if (request.claims) {\n        claimsHash = yield _this5.cryptoImpl.hashString(request.claims);\n      }\n      const accessTokenEntity = AccessTokenEntity.createAccessTokenEntity(result.account?.homeAccountId, result.account.environment, result.accessToken, _this5.clientId, result.tenantId, result.scopes.join(\" \"), result.expiresOn?.getTime() || 0, result.extExpiresOn?.getTime() || 0, _this5.cryptoImpl, undefined,\n      // refreshOn\n      result.tokenType, undefined,\n      // userAssertionHash\n      request.sshKid, request.claims, claimsHash);\n      const cacheRecord = new CacheRecord(undefined, idTokenEntity, accessTokenEntity);\n      return _this5.saveCacheRecord(cacheRecord);\n    })();\n  }\n}\nconst DEFAULT_BROWSER_CACHE_MANAGER = (clientId, logger) => {\n  const cacheOptions = {\n    cacheLocation: BrowserCacheLocation.MemoryStorage,\n    temporaryCacheLocation: BrowserCacheLocation.MemoryStorage,\n    storeAuthStateInCookie: false,\n    secureCookies: false,\n    cacheMigrationEnabled: false,\n    claimsBasedCachingEnabled: false\n  };\n  return new BrowserCacheManager(clientId, cacheOptions, DEFAULT_CRYPTO_IMPLEMENTATION, logger);\n};\nexport { BrowserCacheManager, DEFAULT_BROWSER_CACHE_MANAGER };","map":{"version":3,"names":["_asyncToGenerator","CacheManager","CredentialType","RefreshTokenEntity","AccessTokenEntity","IdTokenEntity","AccountEntity","ClientAuthError","AppMetadataEntity","ServerTelemetryEntity","AuthorityMetadataEntity","Constants","PersistentCacheKeys","ThrottlingEntity","StringUtils","ProtocolUtils","AuthToken","CacheRecord","DEFAULT_CRYPTO_IMPLEMENTATION","CcsCredentialType","createBrowserAuthError","BrowserCacheLocation","StaticCacheKeys","InMemoryCacheKeys","TemporaryCacheKeys","BrowserStorage","MemoryStorage","BrowserProtocolUtils","base64Decode","base64Encode","noTokenRequestCacheError","unableToParseTokenRequestCacheError","noCachedAuthorityError","interactionInProgress","BrowserCacheManager","constructor","clientId","cacheConfig","cryptoImpl","logger","COOKIE_LIFE_MULTIPLIER","internalStorage","browserStorage","setupBrowserStorage","cacheLocation","temporaryCacheStorage","setupTemporaryCacheStorage","temporaryCacheLocation","cacheMigrationEnabled","migrateCacheEntries","createKeyMaps","LocalStorage","SessionStorage","e","verbose","idTokenKey","CACHE_PREFIX","ID_TOKEN","clientInfoKey","CLIENT_INFO","errorKey","ERROR","errorDescKey","ERROR_DESC","idTokenValue","getItem","clientInfoValue","errorValue","errorDescValue","values","keysToMigrate","forEach","cacheKey","index","migrateCacheEntry","newKey","value","setTemporaryCache","trace","accountKeys","ACCOUNT_KEYS","tokenKeys","TOKEN_KEYS","allKeys","getKeys","key","isCredentialKey","credObj","validateAndParseJson","hasOwnProperty","isIdTokenEntity","tracePii","idTokenEntity","toObject","updateCredentialCacheKey","addTokenKey","ACCESS_TOKEN","ACCESS_TOKEN_WITH_AUTH_SCHEME","isAccessTokenEntity","accessTokenEntity","REFRESH_TOKEN","isRefreshTokenEntity","refreshTokenEntity","isAccountKey","accountObj","isAccountEntity","addAccountKeyToMap","jsonValue","parsedJson","JSON","parse","error","setItem","getAccount","accountKey","account","removeAccountKeyFromMap","parsedAccount","setAccount","generateAccountKey","stringify","getAccountKeys","indexOf","push","removalIndex","splice","removeAccount","_superprop_getRemoveAccount","_this","call","removeIdToken","removeTokenKey","removeAccessToken","_superprop_getRemoveAccessToken","_this2","removeRefreshToken","getTokenKeys","item","idToken","accessToken","refreshToken","type","info","createUnexpectedCredentialTypeError","infoPii","idRemoval","accessRemoval","refreshRemoval","getIdTokenCredential","parsedIdToken","setIdTokenCredential","generateCredentialKey","getAccessTokenCredential","accessTokenKey","parsedAccessToken","setAccessTokenCredential","getRefreshTokenCredential","refreshTokenKey","parsedRefreshToken","setRefreshTokenCredential","getAppMetadata","appMetadataKey","parsedMetadata","isAppMetadataEntity","setAppMetadata","appMetadata","generateAppMetadataKey","getServerTelemetry","serverTelemetryKey","isServerTelemetryEntity","setServerTelemetry","serverTelemetry","getAuthorityMetadata","isAuthorityMetadataEntity","getAuthorityMetadataKeys","filter","isAuthorityMetadata","setWrapperMetadata","wrapperSKU","wrapperVersion","WRAPPER_SKU","WRAPPER_VER","getWrapperMetadata","sku","EMPTY_STRING","version","setAuthorityMetadata","entity","getActiveAccount","activeAccountKeyFilters","generateCacheKey","ACTIVE_ACCOUNT_FILTERS","activeAccountValueFilters","activeAccountKeyLocal","ACTIVE_ACCOUNT","activeAccountValueLocal","activeAccount","getAccountInfoByFilter","localAccountId","setActiveAccount","activeAccountValueObj","homeAccountId","activeAccountKey","activeAccountValue","removeItem","accountFilter","allAccounts","getAllAccounts","length","username","toLowerCase","tenantId","environment","getAccountInfoByHints","loginHint","sid","matchingAccounts","accountInfo","accountSid","idTokenClaims","createMultipleMatchingAccountsInCacheError","getThrottlingCache","throttlingCacheKey","parsedThrottlingCache","isThrottlingEntity","setThrottlingCache","throttlingCache","getTemporaryCache","generateKey","storeAuthStateInCookie","itemCookie","getItemCookie","setItemCookie","clearItemCookie","containsKey","clear","_this3","removeAllAccounts","removeAppMetadata","clearTokensAndKeysWithClaims","_this4","removedAccessTokens","credential","requestedClaimsHash","includes","Promise","all","warning","cookieName","cookieValue","expires","cookieStr","encodeURIComponent","expireTime","getCookieExpirationTime","secureCookies","document","cookie","name","cookieList","split","i","charAt","substring","decodeURIComponent","clearMsalCookies","cookiePrefix","cookieKey","cookieLifeDays","today","Date","expr","getTime","toUTCString","getCache","setCache","generatedKey","startsWith","ADAL_ID_TOKEN","generateAuthorityKey","stateString","libraryState","id","stateId","parseRequestState","AUTHORITY","generateNonceKey","NONCE_IDTOKEN","generateStateKey","REQUEST_STATE","getCachedAuthority","cachedState","stateCacheKey","state","authorityCacheKey","updateCacheEntries","nonce","authorityInstance","nonceCacheKey","ccsCredential","HOME_ACCOUNT_ID","CCS_CREDENTIAL","UPN","resetRequestCache","REQUEST_PARAMS","ORIGIN_URI","URL_HASH","CORRELATION_ID","NATIVE_REQUEST","setInteractionInProgress","cleanRequestByState","stateKey","cleanRequestByInteractionType","interactionType","stateValue","parsedState","extractBrowserRequestState","cacheCodeRequest","authCodeRequest","encodedValue","getCachedRequest","encodedTokenRequest","parsedRequest","errorPii","authority","cachedAuthority","getCachedNativeRequest","cachedRequest","isInteractionInProgress","matchClientId","getInteractionInProgress","INTERACTION_STATUS_KEY","inProgress","getLegacyLoginHint","adalIdTokenString","msalIdTokenString","cachedIdTokenString","extractTokenClaims","preferred_username","upn","currentCacheKey","updatedCacheKey","cacheItem","credentialType","getRedirectRequestContext","REDIRECT_CONTEXT","setRedirectRequestContext","hydrateCache","result","request","_this5","createIdTokenEntity","claimsHash","claims","hashString","createAccessTokenEntity","scopes","join","expiresOn","extExpiresOn","undefined","tokenType","sshKid","cacheRecord","saveCacheRecord","DEFAULT_BROWSER_CACHE_MANAGER","cacheOptions","claimsBasedCachingEnabled"],"sources":["C:/Users/v-dkamali/Documents/AngularMSALAD/microsoft-login/node_modules/@azure/msal-browser/dist/cache/BrowserCacheManager.mjs"],"sourcesContent":["/*! @azure/msal-browser v3.1.0 2023-09-05 */\n'use strict';\nimport { CacheManager, CredentialType, RefreshTokenEntity, AccessTokenEntity, IdTokenEntity, AccountEntity, ClientAuthError, AppMetadataEntity, ServerTelemetryEntity, AuthorityMetadataEntity, Constants, PersistentCacheKeys, ThrottlingEntity, StringUtils, ProtocolUtils, AuthToken, CacheRecord, DEFAULT_CRYPTO_IMPLEMENTATION, CcsCredentialType } from '@azure/msal-common';\nimport { createBrowserAuthError } from '../error/BrowserAuthError.mjs';\nimport { BrowserCacheLocation, StaticCacheKeys, InMemoryCacheKeys, TemporaryCacheKeys } from '../utils/BrowserConstants.mjs';\nimport { BrowserStorage } from './BrowserStorage.mjs';\nimport { MemoryStorage } from './MemoryStorage.mjs';\nimport { BrowserProtocolUtils } from '../utils/BrowserProtocolUtils.mjs';\nimport { base64Decode } from '../encode/Base64Decode.mjs';\nimport { base64Encode } from '../encode/Base64Encode.mjs';\nimport { noTokenRequestCacheError, unableToParseTokenRequestCacheError, noCachedAuthorityError, interactionInProgress } from '../error/BrowserAuthErrorCodes.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * This class implements the cache storage interface for MSAL through browser local or session storage.\n * Cookies are only used if storeAuthStateInCookie is true, and are only used for\n * parameters such as state and nonce, generally.\n */\nclass BrowserCacheManager extends CacheManager {\n    constructor(clientId, cacheConfig, cryptoImpl, logger) {\n        super(clientId, cryptoImpl, logger);\n        // Cookie life calculation (hours * minutes * seconds * ms)\n        this.COOKIE_LIFE_MULTIPLIER = 24 * 60 * 60 * 1000;\n        this.cacheConfig = cacheConfig;\n        this.logger = logger;\n        this.internalStorage = new MemoryStorage();\n        this.browserStorage = this.setupBrowserStorage(this.cacheConfig.cacheLocation);\n        this.temporaryCacheStorage = this.setupTemporaryCacheStorage(this.cacheConfig.temporaryCacheLocation, this.cacheConfig.cacheLocation);\n        // Migrate cache entries from older versions of MSAL.\n        if (cacheConfig.cacheMigrationEnabled) {\n            this.migrateCacheEntries();\n            this.createKeyMaps();\n        }\n    }\n    /**\n     * Returns a window storage class implementing the IWindowStorage interface that corresponds to the configured cacheLocation.\n     * @param cacheLocation\n     */\n    setupBrowserStorage(cacheLocation) {\n        switch (cacheLocation) {\n            case BrowserCacheLocation.LocalStorage:\n            case BrowserCacheLocation.SessionStorage:\n                try {\n                    return new BrowserStorage(cacheLocation);\n                }\n                catch (e) {\n                    this.logger.verbose(e);\n                    break;\n                }\n        }\n        this.cacheConfig.cacheLocation = BrowserCacheLocation.MemoryStorage;\n        return new MemoryStorage();\n    }\n    /**\n     * Returns a window storage class implementing the IWindowStorage interface that corresponds to the configured temporaryCacheLocation.\n     * @param temporaryCacheLocation\n     * @param cacheLocation\n     */\n    setupTemporaryCacheStorage(temporaryCacheLocation, cacheLocation) {\n        switch (cacheLocation) {\n            case BrowserCacheLocation.LocalStorage:\n            case BrowserCacheLocation.SessionStorage:\n                try {\n                    // Temporary cache items will always be stored in session storage to mitigate problems caused by multiple tabs\n                    return new BrowserStorage(temporaryCacheLocation ||\n                        BrowserCacheLocation.SessionStorage);\n                }\n                catch (e) {\n                    this.logger.verbose(e);\n                    return this.internalStorage;\n                }\n            case BrowserCacheLocation.MemoryStorage:\n            default:\n                return this.internalStorage;\n        }\n    }\n    /**\n     * Migrate all old cache entries to new schema. No rollback supported.\n     * @param storeAuthStateInCookie\n     */\n    migrateCacheEntries() {\n        const idTokenKey = `${Constants.CACHE_PREFIX}.${PersistentCacheKeys.ID_TOKEN}`;\n        const clientInfoKey = `${Constants.CACHE_PREFIX}.${PersistentCacheKeys.CLIENT_INFO}`;\n        const errorKey = `${Constants.CACHE_PREFIX}.${PersistentCacheKeys.ERROR}`;\n        const errorDescKey = `${Constants.CACHE_PREFIX}.${PersistentCacheKeys.ERROR_DESC}`;\n        const idTokenValue = this.browserStorage.getItem(idTokenKey);\n        const clientInfoValue = this.browserStorage.getItem(clientInfoKey);\n        const errorValue = this.browserStorage.getItem(errorKey);\n        const errorDescValue = this.browserStorage.getItem(errorDescKey);\n        const values = [\n            idTokenValue,\n            clientInfoValue,\n            errorValue,\n            errorDescValue,\n        ];\n        const keysToMigrate = [\n            PersistentCacheKeys.ID_TOKEN,\n            PersistentCacheKeys.CLIENT_INFO,\n            PersistentCacheKeys.ERROR,\n            PersistentCacheKeys.ERROR_DESC,\n        ];\n        keysToMigrate.forEach((cacheKey, index) => this.migrateCacheEntry(cacheKey, values[index]));\n    }\n    /**\n     * Utility function to help with migration.\n     * @param newKey\n     * @param value\n     * @param storeAuthStateInCookie\n     */\n    migrateCacheEntry(newKey, value) {\n        if (value) {\n            this.setTemporaryCache(newKey, value, true);\n        }\n    }\n    /**\n     * Searches all cache entries for MSAL accounts and creates the account key map\n     * This is used to migrate users from older versions of MSAL which did not create the map.\n     * @returns\n     */\n    createKeyMaps() {\n        this.logger.trace(\"BrowserCacheManager - createKeyMaps called.\");\n        const accountKeys = this.getItem(StaticCacheKeys.ACCOUNT_KEYS);\n        const tokenKeys = this.getItem(`${StaticCacheKeys.TOKEN_KEYS}.${this.clientId}`);\n        if (accountKeys && tokenKeys) {\n            this.logger.verbose(\"BrowserCacheManager:createKeyMaps - account and token key maps already exist, skipping migration.\");\n            // Key maps already exist, no need to iterate through cache\n            return;\n        }\n        const allKeys = this.browserStorage.getKeys();\n        allKeys.forEach((key) => {\n            if (this.isCredentialKey(key)) {\n                // Get item, parse, validate and write key to map\n                const value = this.getItem(key);\n                if (value) {\n                    const credObj = this.validateAndParseJson(value);\n                    if (credObj && credObj.hasOwnProperty(\"credentialType\")) {\n                        switch (credObj[\"credentialType\"]) {\n                            case CredentialType.ID_TOKEN:\n                                if (IdTokenEntity.isIdTokenEntity(credObj)) {\n                                    this.logger.trace(\"BrowserCacheManager:createKeyMaps - idToken found, saving key to token key map\");\n                                    this.logger.tracePii(`BrowserCacheManager:createKeyMaps - idToken with key: ${key} found, saving key to token key map`);\n                                    const idTokenEntity = CacheManager.toObject(new IdTokenEntity(), credObj);\n                                    const newKey = this.updateCredentialCacheKey(key, idTokenEntity);\n                                    this.addTokenKey(newKey, CredentialType.ID_TOKEN);\n                                    return;\n                                }\n                                else {\n                                    this.logger.trace(\"BrowserCacheManager:createKeyMaps - key found matching idToken schema with value containing idToken credentialType field but value failed IdTokenEntity validation, skipping.\");\n                                    this.logger.tracePii(`BrowserCacheManager:createKeyMaps - failed idToken validation on key: ${key}`);\n                                }\n                                break;\n                            case CredentialType.ACCESS_TOKEN:\n                            case CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME:\n                                if (AccessTokenEntity.isAccessTokenEntity(credObj)) {\n                                    this.logger.trace(\"BrowserCacheManager:createKeyMaps - accessToken found, saving key to token key map\");\n                                    this.logger.tracePii(`BrowserCacheManager:createKeyMaps - accessToken with key: ${key} found, saving key to token key map`);\n                                    const accessTokenEntity = CacheManager.toObject(new AccessTokenEntity(), credObj);\n                                    const newKey = this.updateCredentialCacheKey(key, accessTokenEntity);\n                                    this.addTokenKey(newKey, CredentialType.ACCESS_TOKEN);\n                                    return;\n                                }\n                                else {\n                                    this.logger.trace(\"BrowserCacheManager:createKeyMaps - key found matching accessToken schema with value containing accessToken credentialType field but value failed AccessTokenEntity validation, skipping.\");\n                                    this.logger.tracePii(`BrowserCacheManager:createKeyMaps - failed accessToken validation on key: ${key}`);\n                                }\n                                break;\n                            case CredentialType.REFRESH_TOKEN:\n                                if (RefreshTokenEntity.isRefreshTokenEntity(credObj)) {\n                                    this.logger.trace(\"BrowserCacheManager:createKeyMaps - refreshToken found, saving key to token key map\");\n                                    this.logger.tracePii(`BrowserCacheManager:createKeyMaps - refreshToken with key: ${key} found, saving key to token key map`);\n                                    const refreshTokenEntity = CacheManager.toObject(new RefreshTokenEntity(), credObj);\n                                    const newKey = this.updateCredentialCacheKey(key, refreshTokenEntity);\n                                    this.addTokenKey(newKey, CredentialType.REFRESH_TOKEN);\n                                    return;\n                                }\n                                else {\n                                    this.logger.trace(\"BrowserCacheManager:createKeyMaps - key found matching refreshToken schema with value containing refreshToken credentialType field but value failed RefreshTokenEntity validation, skipping.\");\n                                    this.logger.tracePii(`BrowserCacheManager:createKeyMaps - failed refreshToken validation on key: ${key}`);\n                                }\n                                break;\n                            // If credentialType isn't one of our predefined ones, it may not be an MSAL cache value. Ignore.\n                        }\n                    }\n                }\n            }\n            if (this.isAccountKey(key)) {\n                const value = this.getItem(key);\n                if (value) {\n                    const accountObj = this.validateAndParseJson(value);\n                    if (accountObj &&\n                        AccountEntity.isAccountEntity(accountObj)) {\n                        this.logger.trace(\"BrowserCacheManager:createKeyMaps - account found, saving key to account key map\");\n                        this.logger.tracePii(`BrowserCacheManager:createKeyMaps - account with key: ${key} found, saving key to account key map`);\n                        this.addAccountKeyToMap(key);\n                    }\n                }\n            }\n        });\n    }\n    /**\n     * Parses passed value as JSON object, JSON.parse() will throw an error.\n     * @param input\n     */\n    validateAndParseJson(jsonValue) {\n        try {\n            const parsedJson = JSON.parse(jsonValue);\n            /**\n             * There are edge cases in which JSON.parse will successfully parse a non-valid JSON object\n             * (e.g. JSON.parse will parse an escaped string into an unescaped string), so adding a type check\n             * of the parsed value is necessary in order to be certain that the string represents a valid JSON object.\n             *\n             */\n            return parsedJson && typeof parsedJson === \"object\"\n                ? parsedJson\n                : null;\n        }\n        catch (error) {\n            return null;\n        }\n    }\n    /**\n     * fetches the entry from the browser storage based off the key\n     * @param key\n     */\n    getItem(key) {\n        return this.browserStorage.getItem(key);\n    }\n    /**\n     * sets the entry in the browser storage\n     * @param key\n     * @param value\n     */\n    setItem(key, value) {\n        this.browserStorage.setItem(key, value);\n    }\n    /**\n     * fetch the account entity from the platform cache\n     * @param accountKey\n     */\n    getAccount(accountKey) {\n        this.logger.trace(\"BrowserCacheManager.getAccount called\");\n        const account = this.getItem(accountKey);\n        if (!account) {\n            this.removeAccountKeyFromMap(accountKey);\n            return null;\n        }\n        const parsedAccount = this.validateAndParseJson(account);\n        if (!parsedAccount || !AccountEntity.isAccountEntity(parsedAccount)) {\n            this.removeAccountKeyFromMap(accountKey);\n            return null;\n        }\n        return CacheManager.toObject(new AccountEntity(), parsedAccount);\n    }\n    /**\n     * set account entity in the platform cache\n     * @param account\n     */\n    setAccount(account) {\n        this.logger.trace(\"BrowserCacheManager.setAccount called\");\n        const key = account.generateAccountKey();\n        this.setItem(key, JSON.stringify(account));\n        this.addAccountKeyToMap(key);\n    }\n    /**\n     * Returns the array of account keys currently cached\n     * @returns\n     */\n    getAccountKeys() {\n        this.logger.trace(\"BrowserCacheManager.getAccountKeys called\");\n        const accountKeys = this.getItem(StaticCacheKeys.ACCOUNT_KEYS);\n        if (accountKeys) {\n            return JSON.parse(accountKeys);\n        }\n        this.logger.verbose(\"BrowserCacheManager.getAccountKeys - No account keys found\");\n        return [];\n    }\n    /**\n     * Add a new account to the key map\n     * @param key\n     */\n    addAccountKeyToMap(key) {\n        this.logger.trace(\"BrowserCacheManager.addAccountKeyToMap called\");\n        this.logger.tracePii(`BrowserCacheManager.addAccountKeyToMap called with key: ${key}`);\n        const accountKeys = this.getAccountKeys();\n        if (accountKeys.indexOf(key) === -1) {\n            // Only add key if it does not already exist in the map\n            accountKeys.push(key);\n            this.setItem(StaticCacheKeys.ACCOUNT_KEYS, JSON.stringify(accountKeys));\n            this.logger.verbose(\"BrowserCacheManager.addAccountKeyToMap account key added\");\n        }\n        else {\n            this.logger.verbose(\"BrowserCacheManager.addAccountKeyToMap account key already exists in map\");\n        }\n    }\n    /**\n     * Remove an account from the key map\n     * @param key\n     */\n    removeAccountKeyFromMap(key) {\n        this.logger.trace(\"BrowserCacheManager.removeAccountKeyFromMap called\");\n        this.logger.tracePii(`BrowserCacheManager.removeAccountKeyFromMap called with key: ${key}`);\n        const accountKeys = this.getAccountKeys();\n        const removalIndex = accountKeys.indexOf(key);\n        if (removalIndex > -1) {\n            accountKeys.splice(removalIndex, 1);\n            this.setItem(StaticCacheKeys.ACCOUNT_KEYS, JSON.stringify(accountKeys));\n            this.logger.trace(\"BrowserCacheManager.removeAccountKeyFromMap account key removed\");\n        }\n        else {\n            this.logger.trace(\"BrowserCacheManager.removeAccountKeyFromMap key not found in existing map\");\n        }\n    }\n    /**\n     * Extends inherited removeAccount function to include removal of the account key from the map\n     * @param key\n     */\n    async removeAccount(key) {\n        void super.removeAccount(key);\n        this.removeAccountKeyFromMap(key);\n    }\n    /**\n     * Removes given idToken from the cache and from the key map\n     * @param key\n     */\n    removeIdToken(key) {\n        super.removeIdToken(key);\n        this.removeTokenKey(key, CredentialType.ID_TOKEN);\n    }\n    /**\n     * Removes given accessToken from the cache and from the key map\n     * @param key\n     */\n    async removeAccessToken(key) {\n        void super.removeAccessToken(key);\n        this.removeTokenKey(key, CredentialType.ACCESS_TOKEN);\n    }\n    /**\n     * Removes given refreshToken from the cache and from the key map\n     * @param key\n     */\n    removeRefreshToken(key) {\n        super.removeRefreshToken(key);\n        this.removeTokenKey(key, CredentialType.REFRESH_TOKEN);\n    }\n    /**\n     * Gets the keys for the cached tokens associated with this clientId\n     * @returns\n     */\n    getTokenKeys() {\n        this.logger.trace(\"BrowserCacheManager.getTokenKeys called\");\n        const item = this.getItem(`${StaticCacheKeys.TOKEN_KEYS}.${this.clientId}`);\n        if (item) {\n            const tokenKeys = this.validateAndParseJson(item);\n            if (tokenKeys &&\n                tokenKeys.hasOwnProperty(\"idToken\") &&\n                tokenKeys.hasOwnProperty(\"accessToken\") &&\n                tokenKeys.hasOwnProperty(\"refreshToken\")) {\n                return tokenKeys;\n            }\n            else {\n                this.logger.error(\"BrowserCacheManager.getTokenKeys - Token keys found but in an unknown format. Returning empty key map.\");\n            }\n        }\n        else {\n            this.logger.verbose(\"BrowserCacheManager.getTokenKeys - No token keys found\");\n        }\n        return {\n            idToken: [],\n            accessToken: [],\n            refreshToken: [],\n        };\n    }\n    /**\n     * Adds the given key to the token key map\n     * @param key\n     * @param type\n     */\n    addTokenKey(key, type) {\n        this.logger.trace(\"BrowserCacheManager addTokenKey called\");\n        const tokenKeys = this.getTokenKeys();\n        switch (type) {\n            case CredentialType.ID_TOKEN:\n                if (tokenKeys.idToken.indexOf(key) === -1) {\n                    this.logger.info(\"BrowserCacheManager: addTokenKey - idToken added to map\");\n                    tokenKeys.idToken.push(key);\n                }\n                break;\n            case CredentialType.ACCESS_TOKEN:\n                if (tokenKeys.accessToken.indexOf(key) === -1) {\n                    this.logger.info(\"BrowserCacheManager: addTokenKey - accessToken added to map\");\n                    tokenKeys.accessToken.push(key);\n                }\n                break;\n            case CredentialType.REFRESH_TOKEN:\n                if (tokenKeys.refreshToken.indexOf(key) === -1) {\n                    this.logger.info(\"BrowserCacheManager: addTokenKey - refreshToken added to map\");\n                    tokenKeys.refreshToken.push(key);\n                }\n                break;\n            default:\n                this.logger.error(`BrowserCacheManager:addTokenKey - CredentialType provided invalid. CredentialType: ${type}`);\n                ClientAuthError.createUnexpectedCredentialTypeError();\n        }\n        this.setItem(`${StaticCacheKeys.TOKEN_KEYS}.${this.clientId}`, JSON.stringify(tokenKeys));\n    }\n    /**\n     * Removes the given key from the token key map\n     * @param key\n     * @param type\n     */\n    removeTokenKey(key, type) {\n        this.logger.trace(\"BrowserCacheManager removeTokenKey called\");\n        const tokenKeys = this.getTokenKeys();\n        switch (type) {\n            case CredentialType.ID_TOKEN:\n                this.logger.infoPii(`BrowserCacheManager: removeTokenKey - attempting to remove idToken with key: ${key} from map`);\n                const idRemoval = tokenKeys.idToken.indexOf(key);\n                if (idRemoval > -1) {\n                    this.logger.info(\"BrowserCacheManager: removeTokenKey - idToken removed from map\");\n                    tokenKeys.idToken.splice(idRemoval, 1);\n                }\n                else {\n                    this.logger.info(\"BrowserCacheManager: removeTokenKey - idToken does not exist in map. Either it was previously removed or it was never added.\");\n                }\n                break;\n            case CredentialType.ACCESS_TOKEN:\n                this.logger.infoPii(`BrowserCacheManager: removeTokenKey - attempting to remove accessToken with key: ${key} from map`);\n                const accessRemoval = tokenKeys.accessToken.indexOf(key);\n                if (accessRemoval > -1) {\n                    this.logger.info(\"BrowserCacheManager: removeTokenKey - accessToken removed from map\");\n                    tokenKeys.accessToken.splice(accessRemoval, 1);\n                }\n                else {\n                    this.logger.info(\"BrowserCacheManager: removeTokenKey - accessToken does not exist in map. Either it was previously removed or it was never added.\");\n                }\n                break;\n            case CredentialType.REFRESH_TOKEN:\n                this.logger.infoPii(`BrowserCacheManager: removeTokenKey - attempting to remove refreshToken with key: ${key} from map`);\n                const refreshRemoval = tokenKeys.refreshToken.indexOf(key);\n                if (refreshRemoval > -1) {\n                    this.logger.info(\"BrowserCacheManager: removeTokenKey - refreshToken removed from map\");\n                    tokenKeys.refreshToken.splice(refreshRemoval, 1);\n                }\n                else {\n                    this.logger.info(\"BrowserCacheManager: removeTokenKey - refreshToken does not exist in map. Either it was previously removed or it was never added.\");\n                }\n                break;\n            default:\n                this.logger.error(`BrowserCacheManager:removeTokenKey - CredentialType provided invalid. CredentialType: ${type}`);\n                ClientAuthError.createUnexpectedCredentialTypeError();\n        }\n        this.setItem(`${StaticCacheKeys.TOKEN_KEYS}.${this.clientId}`, JSON.stringify(tokenKeys));\n    }\n    /**\n     * generates idToken entity from a string\n     * @param idTokenKey\n     */\n    getIdTokenCredential(idTokenKey) {\n        const value = this.getItem(idTokenKey);\n        if (!value) {\n            this.logger.trace(\"BrowserCacheManager.getIdTokenCredential: called, no cache hit\");\n            this.removeTokenKey(idTokenKey, CredentialType.ID_TOKEN);\n            return null;\n        }\n        const parsedIdToken = this.validateAndParseJson(value);\n        if (!parsedIdToken || !IdTokenEntity.isIdTokenEntity(parsedIdToken)) {\n            this.logger.trace(\"BrowserCacheManager.getIdTokenCredential: called, no cache hit\");\n            this.removeTokenKey(idTokenKey, CredentialType.ID_TOKEN);\n            return null;\n        }\n        this.logger.trace(\"BrowserCacheManager.getIdTokenCredential: cache hit\");\n        return CacheManager.toObject(new IdTokenEntity(), parsedIdToken);\n    }\n    /**\n     * set IdToken credential to the platform cache\n     * @param idToken\n     */\n    setIdTokenCredential(idToken) {\n        this.logger.trace(\"BrowserCacheManager.setIdTokenCredential called\");\n        const idTokenKey = idToken.generateCredentialKey();\n        this.setItem(idTokenKey, JSON.stringify(idToken));\n        this.addTokenKey(idTokenKey, CredentialType.ID_TOKEN);\n    }\n    /**\n     * generates accessToken entity from a string\n     * @param key\n     */\n    getAccessTokenCredential(accessTokenKey) {\n        const value = this.getItem(accessTokenKey);\n        if (!value) {\n            this.logger.trace(\"BrowserCacheManager.getAccessTokenCredential: called, no cache hit\");\n            this.removeTokenKey(accessTokenKey, CredentialType.ACCESS_TOKEN);\n            return null;\n        }\n        const parsedAccessToken = this.validateAndParseJson(value);\n        if (!parsedAccessToken ||\n            !AccessTokenEntity.isAccessTokenEntity(parsedAccessToken)) {\n            this.logger.trace(\"BrowserCacheManager.getAccessTokenCredential: called, no cache hit\");\n            this.removeTokenKey(accessTokenKey, CredentialType.ACCESS_TOKEN);\n            return null;\n        }\n        this.logger.trace(\"BrowserCacheManager.getAccessTokenCredential: cache hit\");\n        return CacheManager.toObject(new AccessTokenEntity(), parsedAccessToken);\n    }\n    /**\n     * set accessToken credential to the platform cache\n     * @param accessToken\n     */\n    setAccessTokenCredential(accessToken) {\n        this.logger.trace(\"BrowserCacheManager.setAccessTokenCredential called\");\n        const accessTokenKey = accessToken.generateCredentialKey();\n        this.setItem(accessTokenKey, JSON.stringify(accessToken));\n        this.addTokenKey(accessTokenKey, CredentialType.ACCESS_TOKEN);\n    }\n    /**\n     * generates refreshToken entity from a string\n     * @param refreshTokenKey\n     */\n    getRefreshTokenCredential(refreshTokenKey) {\n        const value = this.getItem(refreshTokenKey);\n        if (!value) {\n            this.logger.trace(\"BrowserCacheManager.getRefreshTokenCredential: called, no cache hit\");\n            this.removeTokenKey(refreshTokenKey, CredentialType.REFRESH_TOKEN);\n            return null;\n        }\n        const parsedRefreshToken = this.validateAndParseJson(value);\n        if (!parsedRefreshToken ||\n            !RefreshTokenEntity.isRefreshTokenEntity(parsedRefreshToken)) {\n            this.logger.trace(\"BrowserCacheManager.getRefreshTokenCredential: called, no cache hit\");\n            this.removeTokenKey(refreshTokenKey, CredentialType.REFRESH_TOKEN);\n            return null;\n        }\n        this.logger.trace(\"BrowserCacheManager.getRefreshTokenCredential: cache hit\");\n        return CacheManager.toObject(new RefreshTokenEntity(), parsedRefreshToken);\n    }\n    /**\n     * set refreshToken credential to the platform cache\n     * @param refreshToken\n     */\n    setRefreshTokenCredential(refreshToken) {\n        this.logger.trace(\"BrowserCacheManager.setRefreshTokenCredential called\");\n        const refreshTokenKey = refreshToken.generateCredentialKey();\n        this.setItem(refreshTokenKey, JSON.stringify(refreshToken));\n        this.addTokenKey(refreshTokenKey, CredentialType.REFRESH_TOKEN);\n    }\n    /**\n     * fetch appMetadata entity from the platform cache\n     * @param appMetadataKey\n     */\n    getAppMetadata(appMetadataKey) {\n        const value = this.getItem(appMetadataKey);\n        if (!value) {\n            this.logger.trace(\"BrowserCacheManager.getAppMetadata: called, no cache hit\");\n            return null;\n        }\n        const parsedMetadata = this.validateAndParseJson(value);\n        if (!parsedMetadata ||\n            !AppMetadataEntity.isAppMetadataEntity(appMetadataKey, parsedMetadata)) {\n            this.logger.trace(\"BrowserCacheManager.getAppMetadata: called, no cache hit\");\n            return null;\n        }\n        this.logger.trace(\"BrowserCacheManager.getAppMetadata: cache hit\");\n        return CacheManager.toObject(new AppMetadataEntity(), parsedMetadata);\n    }\n    /**\n     * set appMetadata entity to the platform cache\n     * @param appMetadata\n     */\n    setAppMetadata(appMetadata) {\n        this.logger.trace(\"BrowserCacheManager.setAppMetadata called\");\n        const appMetadataKey = appMetadata.generateAppMetadataKey();\n        this.setItem(appMetadataKey, JSON.stringify(appMetadata));\n    }\n    /**\n     * fetch server telemetry entity from the platform cache\n     * @param serverTelemetryKey\n     */\n    getServerTelemetry(serverTelemetryKey) {\n        const value = this.getItem(serverTelemetryKey);\n        if (!value) {\n            this.logger.trace(\"BrowserCacheManager.getServerTelemetry: called, no cache hit\");\n            return null;\n        }\n        const parsedMetadata = this.validateAndParseJson(value);\n        if (!parsedMetadata ||\n            !ServerTelemetryEntity.isServerTelemetryEntity(serverTelemetryKey, parsedMetadata)) {\n            this.logger.trace(\"BrowserCacheManager.getServerTelemetry: called, no cache hit\");\n            return null;\n        }\n        this.logger.trace(\"BrowserCacheManager.getServerTelemetry: cache hit\");\n        return CacheManager.toObject(new ServerTelemetryEntity(), parsedMetadata);\n    }\n    /**\n     * set server telemetry entity to the platform cache\n     * @param serverTelemetryKey\n     * @param serverTelemetry\n     */\n    setServerTelemetry(serverTelemetryKey, serverTelemetry) {\n        this.logger.trace(\"BrowserCacheManager.setServerTelemetry called\");\n        this.setItem(serverTelemetryKey, JSON.stringify(serverTelemetry));\n    }\n    /**\n     *\n     */\n    getAuthorityMetadata(key) {\n        const value = this.internalStorage.getItem(key);\n        if (!value) {\n            this.logger.trace(\"BrowserCacheManager.getAuthorityMetadata: called, no cache hit\");\n            return null;\n        }\n        const parsedMetadata = this.validateAndParseJson(value);\n        if (parsedMetadata &&\n            AuthorityMetadataEntity.isAuthorityMetadataEntity(key, parsedMetadata)) {\n            this.logger.trace(\"BrowserCacheManager.getAuthorityMetadata: cache hit\");\n            return CacheManager.toObject(new AuthorityMetadataEntity(), parsedMetadata);\n        }\n        return null;\n    }\n    /**\n     *\n     */\n    getAuthorityMetadataKeys() {\n        const allKeys = this.internalStorage.getKeys();\n        return allKeys.filter((key) => {\n            return this.isAuthorityMetadata(key);\n        });\n    }\n    /**\n     * Sets wrapper metadata in memory\n     * @param wrapperSKU\n     * @param wrapperVersion\n     */\n    setWrapperMetadata(wrapperSKU, wrapperVersion) {\n        this.internalStorage.setItem(InMemoryCacheKeys.WRAPPER_SKU, wrapperSKU);\n        this.internalStorage.setItem(InMemoryCacheKeys.WRAPPER_VER, wrapperVersion);\n    }\n    /**\n     * Returns wrapper metadata from in-memory storage\n     */\n    getWrapperMetadata() {\n        const sku = this.internalStorage.getItem(InMemoryCacheKeys.WRAPPER_SKU) ||\n            Constants.EMPTY_STRING;\n        const version = this.internalStorage.getItem(InMemoryCacheKeys.WRAPPER_VER) ||\n            Constants.EMPTY_STRING;\n        return [sku, version];\n    }\n    /**\n     *\n     * @param entity\n     */\n    setAuthorityMetadata(key, entity) {\n        this.logger.trace(\"BrowserCacheManager.setAuthorityMetadata called\");\n        this.internalStorage.setItem(key, JSON.stringify(entity));\n    }\n    /**\n     * Gets the active account\n     */\n    getActiveAccount() {\n        const activeAccountKeyFilters = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT_FILTERS);\n        const activeAccountValueFilters = this.getItem(activeAccountKeyFilters);\n        if (!activeAccountValueFilters) {\n            // if new active account cache type isn't found, it's an old version, so look for that instead\n            this.logger.trace(\"BrowserCacheManager.getActiveAccount: No active account filters cache schema found, looking for legacy schema\");\n            const activeAccountKeyLocal = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT);\n            const activeAccountValueLocal = this.getItem(activeAccountKeyLocal);\n            if (!activeAccountValueLocal) {\n                this.logger.trace(\"BrowserCacheManager.getActiveAccount: No active account found\");\n                return null;\n            }\n            const activeAccount = this.getAccountInfoByFilter({\n                localAccountId: activeAccountValueLocal,\n            })[0] || null;\n            if (activeAccount) {\n                this.logger.trace(\"BrowserCacheManager.getActiveAccount: Legacy active account cache schema found\");\n                this.logger.trace(\"BrowserCacheManager.getActiveAccount: Adding active account filters cache schema\");\n                this.setActiveAccount(activeAccount);\n                return activeAccount;\n            }\n            return null;\n        }\n        const activeAccountValueObj = this.validateAndParseJson(activeAccountValueFilters);\n        if (activeAccountValueObj) {\n            this.logger.trace(\"BrowserCacheManager.getActiveAccount: Active account filters schema found\");\n            return (this.getAccountInfoByFilter({\n                homeAccountId: activeAccountValueObj.homeAccountId,\n                localAccountId: activeAccountValueObj.localAccountId,\n            })[0] || null);\n        }\n        this.logger.trace(\"BrowserCacheManager.getActiveAccount: No active account found\");\n        return null;\n    }\n    /**\n     * Sets the active account's localAccountId in cache\n     * @param account\n     */\n    setActiveAccount(account) {\n        const activeAccountKey = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT_FILTERS);\n        const activeAccountKeyLocal = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT);\n        if (account) {\n            this.logger.verbose(\"setActiveAccount: Active account set\");\n            const activeAccountValue = {\n                homeAccountId: account.homeAccountId,\n                localAccountId: account.localAccountId,\n            };\n            this.browserStorage.setItem(activeAccountKey, JSON.stringify(activeAccountValue));\n            this.browserStorage.setItem(activeAccountKeyLocal, account.localAccountId);\n        }\n        else {\n            this.logger.verbose(\"setActiveAccount: No account passed, active account not set\");\n            this.browserStorage.removeItem(activeAccountKey);\n            this.browserStorage.removeItem(activeAccountKeyLocal);\n        }\n    }\n    /**\n     * Gets a list of accounts that match all of the filters provided\n     * @param account\n     */\n    getAccountInfoByFilter(accountFilter) {\n        const allAccounts = this.getAllAccounts();\n        this.logger.trace(`BrowserCacheManager.getAccountInfoByFilter: total ${allAccounts.length} accounts found`);\n        return allAccounts.filter((accountObj) => {\n            if (accountFilter.username &&\n                accountFilter.username.toLowerCase() !==\n                    accountObj.username.toLowerCase()) {\n                return false;\n            }\n            if (accountFilter.homeAccountId &&\n                accountFilter.homeAccountId !== accountObj.homeAccountId) {\n                return false;\n            }\n            if (accountFilter.localAccountId &&\n                accountFilter.localAccountId !== accountObj.localAccountId) {\n                return false;\n            }\n            if (accountFilter.tenantId &&\n                accountFilter.tenantId !== accountObj.tenantId) {\n                return false;\n            }\n            if (accountFilter.environment &&\n                accountFilter.environment !== accountObj.environment) {\n                return false;\n            }\n            return true;\n        });\n    }\n    /**\n     * Checks the cache for accounts matching loginHint or SID\n     * @param loginHint\n     * @param sid\n     */\n    getAccountInfoByHints(loginHint, sid) {\n        const matchingAccounts = this.getAllAccounts().filter((accountInfo) => {\n            if (sid) {\n                const accountSid = accountInfo.idTokenClaims &&\n                    accountInfo.idTokenClaims[\"sid\"];\n                return sid === accountSid;\n            }\n            if (loginHint) {\n                return loginHint === accountInfo.username;\n            }\n            return false;\n        });\n        if (matchingAccounts.length === 1) {\n            return matchingAccounts[0];\n        }\n        else if (matchingAccounts.length > 1) {\n            throw ClientAuthError.createMultipleMatchingAccountsInCacheError();\n        }\n        return null;\n    }\n    /**\n     * fetch throttling entity from the platform cache\n     * @param throttlingCacheKey\n     */\n    getThrottlingCache(throttlingCacheKey) {\n        const value = this.getItem(throttlingCacheKey);\n        if (!value) {\n            this.logger.trace(\"BrowserCacheManager.getThrottlingCache: called, no cache hit\");\n            return null;\n        }\n        const parsedThrottlingCache = this.validateAndParseJson(value);\n        if (!parsedThrottlingCache ||\n            !ThrottlingEntity.isThrottlingEntity(throttlingCacheKey, parsedThrottlingCache)) {\n            this.logger.trace(\"BrowserCacheManager.getThrottlingCache: called, no cache hit\");\n            return null;\n        }\n        this.logger.trace(\"BrowserCacheManager.getThrottlingCache: cache hit\");\n        return CacheManager.toObject(new ThrottlingEntity(), parsedThrottlingCache);\n    }\n    /**\n     * set throttling entity to the platform cache\n     * @param throttlingCacheKey\n     * @param throttlingCache\n     */\n    setThrottlingCache(throttlingCacheKey, throttlingCache) {\n        this.logger.trace(\"BrowserCacheManager.setThrottlingCache called\");\n        this.setItem(throttlingCacheKey, JSON.stringify(throttlingCache));\n    }\n    /**\n     * Gets cache item with given key.\n     * Will retrieve from cookies if storeAuthStateInCookie is set to true.\n     * @param key\n     */\n    getTemporaryCache(cacheKey, generateKey) {\n        const key = generateKey ? this.generateCacheKey(cacheKey) : cacheKey;\n        if (this.cacheConfig.storeAuthStateInCookie) {\n            const itemCookie = this.getItemCookie(key);\n            if (itemCookie) {\n                this.logger.trace(\"BrowserCacheManager.getTemporaryCache: storeAuthStateInCookies set to true, retrieving from cookies\");\n                return itemCookie;\n            }\n        }\n        const value = this.temporaryCacheStorage.getItem(key);\n        if (!value) {\n            // If temp cache item not found in session/memory, check local storage for items set by old versions\n            if (this.cacheConfig.cacheLocation ===\n                BrowserCacheLocation.LocalStorage) {\n                const item = this.browserStorage.getItem(key);\n                if (item) {\n                    this.logger.trace(\"BrowserCacheManager.getTemporaryCache: Temporary cache item found in local storage\");\n                    return item;\n                }\n            }\n            this.logger.trace(\"BrowserCacheManager.getTemporaryCache: No cache item found in local storage\");\n            return null;\n        }\n        this.logger.trace(\"BrowserCacheManager.getTemporaryCache: Temporary cache item returned\");\n        return value;\n    }\n    /**\n     * Sets the cache item with the key and value given.\n     * Stores in cookie if storeAuthStateInCookie is set to true.\n     * This can cause cookie overflow if used incorrectly.\n     * @param key\n     * @param value\n     */\n    setTemporaryCache(cacheKey, value, generateKey) {\n        const key = generateKey ? this.generateCacheKey(cacheKey) : cacheKey;\n        this.temporaryCacheStorage.setItem(key, value);\n        if (this.cacheConfig.storeAuthStateInCookie) {\n            this.logger.trace(\"BrowserCacheManager.setTemporaryCache: storeAuthStateInCookie set to true, setting item cookie\");\n            this.setItemCookie(key, value);\n        }\n    }\n    /**\n     * Removes the cache item with the given key.\n     * Will also clear the cookie item if storeAuthStateInCookie is set to true.\n     * @param key\n     */\n    removeItem(key) {\n        this.browserStorage.removeItem(key);\n        this.temporaryCacheStorage.removeItem(key);\n        if (this.cacheConfig.storeAuthStateInCookie) {\n            this.logger.trace(\"BrowserCacheManager.removeItem: storeAuthStateInCookie is true, clearing item cookie\");\n            this.clearItemCookie(key);\n        }\n    }\n    /**\n     * Checks whether key is in cache.\n     * @param key\n     */\n    containsKey(key) {\n        return (this.browserStorage.containsKey(key) ||\n            this.temporaryCacheStorage.containsKey(key));\n    }\n    /**\n     * Gets all keys in window.\n     */\n    getKeys() {\n        return [\n            ...this.browserStorage.getKeys(),\n            ...this.temporaryCacheStorage.getKeys(),\n        ];\n    }\n    /**\n     * Clears all cache entries created by MSAL.\n     */\n    async clear() {\n        // Removes all accounts and their credentials\n        await this.removeAllAccounts();\n        this.removeAppMetadata();\n        // Removes all remaining MSAL cache items\n        this.getKeys().forEach((cacheKey) => {\n            // Check if key contains msal prefix; For now, we are clearing all the cache items created by MSAL.js\n            if ((this.browserStorage.containsKey(cacheKey) ||\n                this.temporaryCacheStorage.containsKey(cacheKey)) &&\n                (cacheKey.indexOf(Constants.CACHE_PREFIX) !== -1 ||\n                    cacheKey.indexOf(this.clientId) !== -1)) {\n                this.removeItem(cacheKey);\n            }\n        });\n        this.internalStorage.clear();\n    }\n    /**\n     * Clears all access tokes that have claims prior to saving the current one\n     * @param credential\n     * @returns\n     */\n    async clearTokensAndKeysWithClaims() {\n        const tokenKeys = this.getTokenKeys();\n        const removedAccessTokens = [];\n        tokenKeys.accessToken.forEach((key) => {\n            // if the access token has claims in its key, remove the token key and the token\n            const credential = this.getAccessTokenCredential(key);\n            if (credential?.requestedClaimsHash &&\n                key.includes(credential.requestedClaimsHash.toLowerCase())) {\n                removedAccessTokens.push(this.removeAccessToken(key));\n            }\n        });\n        await Promise.all(removedAccessTokens);\n        // warn if any access tokens are removed\n        if (removedAccessTokens.length > 0) {\n            this.logger.warning(`${removedAccessTokens.length} access tokens with claims in the cache keys have been removed from the cache.`);\n        }\n    }\n    /**\n     * Add value to cookies\n     * @param cookieName\n     * @param cookieValue\n     * @param expires\n     */\n    setItemCookie(cookieName, cookieValue, expires) {\n        let cookieStr = `${encodeURIComponent(cookieName)}=${encodeURIComponent(cookieValue)};path=/;SameSite=Lax;`;\n        if (expires) {\n            const expireTime = this.getCookieExpirationTime(expires);\n            cookieStr += `expires=${expireTime};`;\n        }\n        if (this.cacheConfig.secureCookies) {\n            cookieStr += \"Secure;\";\n        }\n        document.cookie = cookieStr;\n    }\n    /**\n     * Get one item by key from cookies\n     * @param cookieName\n     */\n    getItemCookie(cookieName) {\n        const name = `${encodeURIComponent(cookieName)}=`;\n        const cookieList = document.cookie.split(\";\");\n        for (let i = 0; i < cookieList.length; i++) {\n            let cookie = cookieList[i];\n            while (cookie.charAt(0) === \" \") {\n                cookie = cookie.substring(1);\n            }\n            if (cookie.indexOf(name) === 0) {\n                return decodeURIComponent(cookie.substring(name.length, cookie.length));\n            }\n        }\n        return Constants.EMPTY_STRING;\n    }\n    /**\n     * Clear all msal-related cookies currently set in the browser. Should only be used to clear temporary cache items.\n     */\n    clearMsalCookies() {\n        const cookiePrefix = `${Constants.CACHE_PREFIX}.${this.clientId}`;\n        const cookieList = document.cookie.split(\";\");\n        cookieList.forEach((cookie) => {\n            while (cookie.charAt(0) === \" \") {\n                // eslint-disable-next-line no-param-reassign\n                cookie = cookie.substring(1);\n            }\n            if (cookie.indexOf(cookiePrefix) === 0) {\n                const cookieKey = cookie.split(\"=\")[0];\n                this.clearItemCookie(cookieKey);\n            }\n        });\n    }\n    /**\n     * Clear an item in the cookies by key\n     * @param cookieName\n     */\n    clearItemCookie(cookieName) {\n        this.setItemCookie(cookieName, Constants.EMPTY_STRING, -1);\n    }\n    /**\n     * Get cookie expiration time\n     * @param cookieLifeDays\n     */\n    getCookieExpirationTime(cookieLifeDays) {\n        const today = new Date();\n        const expr = new Date(today.getTime() + cookieLifeDays * this.COOKIE_LIFE_MULTIPLIER);\n        return expr.toUTCString();\n    }\n    /**\n     * Gets the cache object referenced by the browser\n     */\n    getCache() {\n        return this.browserStorage;\n    }\n    /**\n     * interface compat, we cannot overwrite browser cache; Functionality is supported by individual entities in browser\n     */\n    setCache() {\n        // sets nothing\n    }\n    /**\n     * Prepend msal.<client-id> to each key; Skip for any JSON object as Key (defined schemas do not need the key appended: AccessToken Keys or the upcoming schema)\n     * @param key\n     * @param addInstanceId\n     */\n    generateCacheKey(key) {\n        const generatedKey = this.validateAndParseJson(key);\n        if (!generatedKey) {\n            if (StringUtils.startsWith(key, Constants.CACHE_PREFIX) ||\n                StringUtils.startsWith(key, PersistentCacheKeys.ADAL_ID_TOKEN)) {\n                return key;\n            }\n            return `${Constants.CACHE_PREFIX}.${this.clientId}.${key}`;\n        }\n        return JSON.stringify(key);\n    }\n    /**\n     * Create authorityKey to cache authority\n     * @param state\n     */\n    generateAuthorityKey(stateString) {\n        const { libraryState: { id: stateId }, } = ProtocolUtils.parseRequestState(this.cryptoImpl, stateString);\n        return this.generateCacheKey(`${TemporaryCacheKeys.AUTHORITY}.${stateId}`);\n    }\n    /**\n     * Create Nonce key to cache nonce\n     * @param state\n     */\n    generateNonceKey(stateString) {\n        const { libraryState: { id: stateId }, } = ProtocolUtils.parseRequestState(this.cryptoImpl, stateString);\n        return this.generateCacheKey(`${TemporaryCacheKeys.NONCE_IDTOKEN}.${stateId}`);\n    }\n    /**\n     * Creates full cache key for the request state\n     * @param stateString State string for the request\n     */\n    generateStateKey(stateString) {\n        // Use the library state id to key temp storage for uniqueness for multiple concurrent requests\n        const { libraryState: { id: stateId }, } = ProtocolUtils.parseRequestState(this.cryptoImpl, stateString);\n        return this.generateCacheKey(`${TemporaryCacheKeys.REQUEST_STATE}.${stateId}`);\n    }\n    /**\n     * Gets the cached authority based on the cached state. Returns empty if no cached state found.\n     */\n    getCachedAuthority(cachedState) {\n        const stateCacheKey = this.generateStateKey(cachedState);\n        const state = this.getTemporaryCache(stateCacheKey);\n        if (!state) {\n            return null;\n        }\n        const authorityCacheKey = this.generateAuthorityKey(state);\n        return this.getTemporaryCache(authorityCacheKey);\n    }\n    /**\n     * Updates account, authority, and state in cache\n     * @param serverAuthenticationRequest\n     * @param account\n     */\n    updateCacheEntries(state, nonce, authorityInstance, loginHint, account) {\n        this.logger.trace(\"BrowserCacheManager.updateCacheEntries called\");\n        // Cache the request state\n        const stateCacheKey = this.generateStateKey(state);\n        this.setTemporaryCache(stateCacheKey, state, false);\n        // Cache the nonce\n        const nonceCacheKey = this.generateNonceKey(state);\n        this.setTemporaryCache(nonceCacheKey, nonce, false);\n        // Cache authorityKey\n        const authorityCacheKey = this.generateAuthorityKey(state);\n        this.setTemporaryCache(authorityCacheKey, authorityInstance, false);\n        if (account) {\n            const ccsCredential = {\n                credential: account.homeAccountId,\n                type: CcsCredentialType.HOME_ACCOUNT_ID,\n            };\n            this.setTemporaryCache(TemporaryCacheKeys.CCS_CREDENTIAL, JSON.stringify(ccsCredential), true);\n        }\n        else if (loginHint) {\n            const ccsCredential = {\n                credential: loginHint,\n                type: CcsCredentialType.UPN,\n            };\n            this.setTemporaryCache(TemporaryCacheKeys.CCS_CREDENTIAL, JSON.stringify(ccsCredential), true);\n        }\n    }\n    /**\n     * Reset all temporary cache items\n     * @param state\n     */\n    resetRequestCache(state) {\n        this.logger.trace(\"BrowserCacheManager.resetRequestCache called\");\n        // check state and remove associated cache items\n        if (state) {\n            this.getKeys().forEach((key) => {\n                if (key.indexOf(state) !== -1) {\n                    this.removeItem(key);\n                }\n            });\n            // delete generic interactive request parameters\n            this.removeItem(this.generateStateKey(state));\n            this.removeItem(this.generateNonceKey(state));\n            this.removeItem(this.generateAuthorityKey(state));\n        }\n        this.removeItem(this.generateCacheKey(TemporaryCacheKeys.REQUEST_PARAMS));\n        this.removeItem(this.generateCacheKey(TemporaryCacheKeys.ORIGIN_URI));\n        this.removeItem(this.generateCacheKey(TemporaryCacheKeys.URL_HASH));\n        this.removeItem(this.generateCacheKey(TemporaryCacheKeys.CORRELATION_ID));\n        this.removeItem(this.generateCacheKey(TemporaryCacheKeys.CCS_CREDENTIAL));\n        this.removeItem(this.generateCacheKey(TemporaryCacheKeys.NATIVE_REQUEST));\n        this.setInteractionInProgress(false);\n    }\n    /**\n     * Removes temporary cache for the provided state\n     * @param stateString\n     */\n    cleanRequestByState(stateString) {\n        this.logger.trace(\"BrowserCacheManager.cleanRequestByState called\");\n        // Interaction is completed - remove interaction status.\n        if (stateString) {\n            const stateKey = this.generateStateKey(stateString);\n            const cachedState = this.temporaryCacheStorage.getItem(stateKey);\n            this.logger.infoPii(`BrowserCacheManager.cleanRequestByState: Removing temporary cache items for state: ${cachedState}`);\n            this.resetRequestCache(cachedState || Constants.EMPTY_STRING);\n        }\n        this.clearMsalCookies();\n    }\n    /**\n     * Looks in temporary cache for any state values with the provided interactionType and removes all temporary cache items for that state\n     * Used in scenarios where temp cache needs to be cleaned but state is not known, such as clicking browser back button.\n     * @param interactionType\n     */\n    cleanRequestByInteractionType(interactionType) {\n        this.logger.trace(\"BrowserCacheManager.cleanRequestByInteractionType called\");\n        // Loop through all keys to find state key\n        this.getKeys().forEach((key) => {\n            // If this key is not the state key, move on\n            if (key.indexOf(TemporaryCacheKeys.REQUEST_STATE) === -1) {\n                return;\n            }\n            // Retrieve state value, return if not a valid value\n            const stateValue = this.temporaryCacheStorage.getItem(key);\n            if (!stateValue) {\n                return;\n            }\n            // Extract state and ensure it matches given InteractionType, then clean request cache\n            const parsedState = BrowserProtocolUtils.extractBrowserRequestState(this.cryptoImpl, stateValue);\n            if (parsedState &&\n                parsedState.interactionType === interactionType) {\n                this.logger.infoPii(`BrowserCacheManager.cleanRequestByInteractionType: Removing temporary cache items for state: ${stateValue}`);\n                this.resetRequestCache(stateValue);\n            }\n        });\n        this.clearMsalCookies();\n        this.setInteractionInProgress(false);\n    }\n    cacheCodeRequest(authCodeRequest) {\n        this.logger.trace(\"BrowserCacheManager.cacheCodeRequest called\");\n        const encodedValue = base64Encode(JSON.stringify(authCodeRequest));\n        this.setTemporaryCache(TemporaryCacheKeys.REQUEST_PARAMS, encodedValue, true);\n    }\n    /**\n     * Gets the token exchange parameters from the cache. Throws an error if nothing is found.\n     */\n    getCachedRequest(state) {\n        this.logger.trace(\"BrowserCacheManager.getCachedRequest called\");\n        // Get token request from cache and parse as TokenExchangeParameters.\n        const encodedTokenRequest = this.getTemporaryCache(TemporaryCacheKeys.REQUEST_PARAMS, true);\n        if (!encodedTokenRequest) {\n            throw createBrowserAuthError(noTokenRequestCacheError);\n        }\n        let parsedRequest;\n        try {\n            parsedRequest = JSON.parse(base64Decode(encodedTokenRequest));\n        }\n        catch (e) {\n            this.logger.errorPii(`Attempted to parse: ${encodedTokenRequest}`);\n            this.logger.error(`Parsing cached token request threw with error: ${e}`);\n            throw createBrowserAuthError(unableToParseTokenRequestCacheError);\n        }\n        this.removeItem(this.generateCacheKey(TemporaryCacheKeys.REQUEST_PARAMS));\n        // Get cached authority and use if no authority is cached with request.\n        if (!parsedRequest.authority) {\n            const authorityCacheKey = this.generateAuthorityKey(state);\n            const cachedAuthority = this.getTemporaryCache(authorityCacheKey);\n            if (!cachedAuthority) {\n                throw createBrowserAuthError(noCachedAuthorityError);\n            }\n            parsedRequest.authority = cachedAuthority;\n        }\n        return parsedRequest;\n    }\n    /**\n     * Gets cached native request for redirect flows\n     */\n    getCachedNativeRequest() {\n        this.logger.trace(\"BrowserCacheManager.getCachedNativeRequest called\");\n        const cachedRequest = this.getTemporaryCache(TemporaryCacheKeys.NATIVE_REQUEST, true);\n        if (!cachedRequest) {\n            this.logger.trace(\"BrowserCacheManager.getCachedNativeRequest: No cached native request found\");\n            return null;\n        }\n        const parsedRequest = this.validateAndParseJson(cachedRequest);\n        if (!parsedRequest) {\n            this.logger.error(\"BrowserCacheManager.getCachedNativeRequest: Unable to parse native request\");\n            return null;\n        }\n        return parsedRequest;\n    }\n    isInteractionInProgress(matchClientId) {\n        const clientId = this.getInteractionInProgress();\n        if (matchClientId) {\n            return clientId === this.clientId;\n        }\n        else {\n            return !!clientId;\n        }\n    }\n    getInteractionInProgress() {\n        const key = `${Constants.CACHE_PREFIX}.${TemporaryCacheKeys.INTERACTION_STATUS_KEY}`;\n        return this.getTemporaryCache(key, false);\n    }\n    setInteractionInProgress(inProgress) {\n        // Ensure we don't overwrite interaction in progress for a different clientId\n        const key = `${Constants.CACHE_PREFIX}.${TemporaryCacheKeys.INTERACTION_STATUS_KEY}`;\n        if (inProgress) {\n            if (this.getInteractionInProgress()) {\n                throw createBrowserAuthError(interactionInProgress);\n            }\n            else {\n                // No interaction is in progress\n                this.setTemporaryCache(key, this.clientId, false);\n            }\n        }\n        else if (!inProgress &&\n            this.getInteractionInProgress() === this.clientId) {\n            this.removeItem(key);\n        }\n    }\n    /**\n     * Returns username retrieved from ADAL or MSAL v1 idToken\n     * @deprecated\n     */\n    getLegacyLoginHint() {\n        // Only check for adal/msal token if no SSO params are being used\n        const adalIdTokenString = this.getTemporaryCache(PersistentCacheKeys.ADAL_ID_TOKEN);\n        if (adalIdTokenString) {\n            this.browserStorage.removeItem(PersistentCacheKeys.ADAL_ID_TOKEN);\n            this.logger.verbose(\"Cached ADAL id token retrieved.\");\n        }\n        // Check for cached MSAL v1 id token\n        const msalIdTokenString = this.getTemporaryCache(PersistentCacheKeys.ID_TOKEN, true);\n        if (msalIdTokenString) {\n            this.removeItem(this.generateCacheKey(PersistentCacheKeys.ID_TOKEN));\n            this.logger.verbose(\"Cached MSAL.js v1 id token retrieved\");\n        }\n        const cachedIdTokenString = msalIdTokenString || adalIdTokenString;\n        if (cachedIdTokenString) {\n            const idTokenClaims = AuthToken.extractTokenClaims(cachedIdTokenString, base64Decode);\n            if (idTokenClaims.preferred_username) {\n                this.logger.verbose(\"No SSO params used and ADAL/MSAL v1 token retrieved, setting ADAL/MSAL v1 preferred_username as loginHint\");\n                return idTokenClaims.preferred_username;\n            }\n            else if (idTokenClaims.upn) {\n                this.logger.verbose(\"No SSO params used and ADAL/MSAL v1 token retrieved, setting ADAL/MSAL v1 upn as loginHint\");\n                return idTokenClaims.upn;\n            }\n            else {\n                this.logger.verbose(\"No SSO params used and ADAL/MSAL v1 token retrieved, however, no account hint claim found. Enable preferred_username or upn id token claim to get SSO.\");\n            }\n        }\n        return null;\n    }\n    /**\n     * Updates a credential's cache key if the current cache key is outdated\n     */\n    updateCredentialCacheKey(currentCacheKey, credential) {\n        const updatedCacheKey = credential.generateCredentialKey();\n        if (currentCacheKey !== updatedCacheKey) {\n            const cacheItem = this.getItem(currentCacheKey);\n            if (cacheItem) {\n                this.removeItem(currentCacheKey);\n                this.setItem(updatedCacheKey, cacheItem);\n                this.logger.verbose(`Updated an outdated ${credential.credentialType} cache key`);\n                return updatedCacheKey;\n            }\n            else {\n                this.logger.error(`Attempted to update an outdated ${credential.credentialType} cache key but no item matching the outdated key was found in storage`);\n            }\n        }\n        return currentCacheKey;\n    }\n    /**\n     * Returns application id as redirect context during AcquireTokenRedirect flow.\n     */\n    getRedirectRequestContext() {\n        return this.getTemporaryCache(TemporaryCacheKeys.REDIRECT_CONTEXT, true);\n    }\n    /**\n     * Sets application id as the redirect context during AcquireTokenRedirect flow.\n     * @param value\n     */\n    setRedirectRequestContext(value) {\n        this.setTemporaryCache(TemporaryCacheKeys.REDIRECT_CONTEXT, value, true);\n    }\n    /**\n     * Builds credential entities from AuthenticationResult object and saves the resulting credentials to the cache\n     * @param result\n     * @param request\n     */\n    async hydrateCache(result, request) {\n        const idTokenEntity = IdTokenEntity.createIdTokenEntity(result.account?.homeAccountId, result.account?.environment, result.idToken, this.clientId, result.tenantId);\n        let claimsHash;\n        if (request.claims) {\n            claimsHash = await this.cryptoImpl.hashString(request.claims);\n        }\n        const accessTokenEntity = AccessTokenEntity.createAccessTokenEntity(result.account?.homeAccountId, result.account.environment, result.accessToken, this.clientId, result.tenantId, result.scopes.join(\" \"), result.expiresOn?.getTime() || 0, result.extExpiresOn?.getTime() || 0, this.cryptoImpl, undefined, // refreshOn\n        result.tokenType, undefined, // userAssertionHash\n        request.sshKid, request.claims, claimsHash);\n        const cacheRecord = new CacheRecord(undefined, idTokenEntity, accessTokenEntity);\n        return this.saveCacheRecord(cacheRecord);\n    }\n}\nconst DEFAULT_BROWSER_CACHE_MANAGER = (clientId, logger) => {\n    const cacheOptions = {\n        cacheLocation: BrowserCacheLocation.MemoryStorage,\n        temporaryCacheLocation: BrowserCacheLocation.MemoryStorage,\n        storeAuthStateInCookie: false,\n        secureCookies: false,\n        cacheMigrationEnabled: false,\n        claimsBasedCachingEnabled: false,\n    };\n    return new BrowserCacheManager(clientId, cacheOptions, DEFAULT_CRYPTO_IMPLEMENTATION, logger);\n};\n\nexport { BrowserCacheManager, DEFAULT_BROWSER_CACHE_MANAGER };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}