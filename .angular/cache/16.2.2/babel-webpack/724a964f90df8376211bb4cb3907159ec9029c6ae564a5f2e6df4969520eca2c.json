{"ast":null,"code":"/*! @azure/msal-browser v3.1.0 2023-09-05 */\n'use strict';\n\nimport _asyncToGenerator from \"C:/Users/v-dkamali/Documents/AngularMSALAD/microsoft-login/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { PerformanceEvents, ClientAuthError, ServerError, invokeAsync, AuthorityFactory } from '@azure/msal-common';\nimport { createBrowserAuthError } from '../error/BrowserAuthError.mjs';\nimport { TemporaryCacheKeys } from '../utils/BrowserConstants.mjs';\nimport { hashEmptyError, userCancelled } from '../error/BrowserAuthErrorCodes.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * Abstract class which defines operations for a browser interaction handling class.\n */\nclass InteractionHandler {\n  constructor(authCodeModule, storageImpl, authCodeRequest, logger, performanceClient) {\n    this.authModule = authCodeModule;\n    this.browserStorage = storageImpl;\n    this.authCodeRequest = authCodeRequest;\n    this.logger = logger;\n    this.performanceClient = performanceClient;\n  }\n  /**\n   * Function to handle response parameters from hash.\n   * @param locationHash\n   */\n  handleCodeResponseFromHash(locationHash, state, authority, networkModule) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      _this.performanceClient.addQueueMeasurement(PerformanceEvents.HandleCodeResponseFromHash, _this.authCodeRequest.correlationId);\n      _this.logger.verbose(\"InteractionHandler.handleCodeResponse called\");\n      // Check that location hash isn't empty.\n      if (!locationHash) {\n        throw createBrowserAuthError(hashEmptyError);\n      }\n      // Handle code response.\n      const stateKey = _this.browserStorage.generateStateKey(state);\n      const requestState = _this.browserStorage.getTemporaryCache(stateKey);\n      if (!requestState) {\n        throw ClientAuthError.createStateNotFoundError(\"Cached State\");\n      }\n      let authCodeResponse;\n      try {\n        authCodeResponse = _this.authModule.handleFragmentResponse(locationHash, requestState);\n      } catch (e) {\n        if (e instanceof ServerError && e.subError === userCancelled) {\n          // Translate server error caused by user closing native prompt to corresponding first class MSAL error\n          throw createBrowserAuthError(userCancelled);\n        } else {\n          throw e;\n        }\n      }\n      _this.performanceClient.setPreQueueTime(PerformanceEvents.HandleCodeResponseFromServer, _this.authCodeRequest.correlationId);\n      return _this.handleCodeResponseFromServer(authCodeResponse, state, authority, networkModule);\n    })();\n  }\n  /**\n   * Process auth code response from AAD\n   * @param authCodeResponse\n   * @param state\n   * @param authority\n   * @param networkModule\n   * @returns\n   */\n  handleCodeResponseFromServer(authCodeResponse, state, authority, networkModule, validateNonce = true) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      _this2.performanceClient.addQueueMeasurement(PerformanceEvents.HandleCodeResponseFromServer, _this2.authCodeRequest.correlationId);\n      _this2.logger.trace(\"InteractionHandler.handleCodeResponseFromServer called\");\n      // Handle code response.\n      const stateKey = _this2.browserStorage.generateStateKey(state);\n      const requestState = _this2.browserStorage.getTemporaryCache(stateKey);\n      if (!requestState) {\n        throw ClientAuthError.createStateNotFoundError(\"Cached State\");\n      }\n      // Get cached items\n      const nonceKey = _this2.browserStorage.generateNonceKey(requestState);\n      const cachedNonce = _this2.browserStorage.getTemporaryCache(nonceKey);\n      // Assign code to request\n      _this2.authCodeRequest.code = authCodeResponse.code;\n      // Check for new cloud instance\n      if (authCodeResponse.cloud_instance_host_name) {\n        _this2.performanceClient.setPreQueueTime(PerformanceEvents.UpdateTokenEndpointAuthority, _this2.authCodeRequest.correlationId);\n        yield _this2.updateTokenEndpointAuthority(authCodeResponse.cloud_instance_host_name, authority, networkModule);\n      }\n      // Nonce validation not needed when redirect not involved (e.g. hybrid spa, renewing token via rt)\n      if (validateNonce) {\n        authCodeResponse.nonce = cachedNonce || undefined;\n      }\n      authCodeResponse.state = requestState;\n      // Add CCS parameters if available\n      if (authCodeResponse.client_info) {\n        _this2.authCodeRequest.clientInfo = authCodeResponse.client_info;\n      } else {\n        const cachedCcsCred = _this2.checkCcsCredentials();\n        if (cachedCcsCred) {\n          _this2.authCodeRequest.ccsCredential = cachedCcsCred;\n        }\n      }\n      // Acquire token with retrieved code.\n      const tokenResponse = yield invokeAsync(_this2.authModule.acquireToken.bind(_this2.authModule), PerformanceEvents.AuthClientAcquireToken, _this2.logger, _this2.performanceClient, _this2.authCodeRequest.correlationId)(_this2.authCodeRequest, authCodeResponse);\n      _this2.browserStorage.cleanRequestByState(state);\n      return tokenResponse;\n    })();\n  }\n  /**\n   * Updates authority based on cloudInstanceHostname\n   * @param cloudInstanceHostname\n   * @param authority\n   * @param networkModule\n   */\n  updateTokenEndpointAuthority(cloudInstanceHostname, authority, networkModule) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      _this3.performanceClient.addQueueMeasurement(PerformanceEvents.UpdateTokenEndpointAuthority, _this3.authCodeRequest.correlationId);\n      const cloudInstanceAuthorityUri = `https://${cloudInstanceHostname}/${authority.tenant}/`;\n      const cloudInstanceAuthority = yield AuthorityFactory.createDiscoveredInstance(cloudInstanceAuthorityUri, networkModule, _this3.browserStorage, authority.options, _this3.logger, _this3.performanceClient, _this3.authCodeRequest.correlationId);\n      _this3.authModule.updateAuthority(cloudInstanceAuthority);\n    })();\n  }\n  /**\n   * Looks up ccs creds in the cache\n   */\n  checkCcsCredentials() {\n    // Look up ccs credential in temp cache\n    const cachedCcsCred = this.browserStorage.getTemporaryCache(TemporaryCacheKeys.CCS_CREDENTIAL, true);\n    if (cachedCcsCred) {\n      try {\n        return JSON.parse(cachedCcsCred);\n      } catch (e) {\n        this.authModule.logger.error(\"Cache credential could not be parsed\");\n        this.authModule.logger.errorPii(`Cache credential could not be parsed: ${cachedCcsCred}`);\n      }\n    }\n    return null;\n  }\n}\nexport { InteractionHandler };","map":{"version":3,"names":["_asyncToGenerator","PerformanceEvents","ClientAuthError","ServerError","invokeAsync","AuthorityFactory","createBrowserAuthError","TemporaryCacheKeys","hashEmptyError","userCancelled","InteractionHandler","constructor","authCodeModule","storageImpl","authCodeRequest","logger","performanceClient","authModule","browserStorage","handleCodeResponseFromHash","locationHash","state","authority","networkModule","_this","addQueueMeasurement","HandleCodeResponseFromHash","correlationId","verbose","stateKey","generateStateKey","requestState","getTemporaryCache","createStateNotFoundError","authCodeResponse","handleFragmentResponse","e","subError","setPreQueueTime","HandleCodeResponseFromServer","handleCodeResponseFromServer","validateNonce","_this2","trace","nonceKey","generateNonceKey","cachedNonce","code","cloud_instance_host_name","UpdateTokenEndpointAuthority","updateTokenEndpointAuthority","nonce","undefined","client_info","clientInfo","cachedCcsCred","checkCcsCredentials","ccsCredential","tokenResponse","acquireToken","bind","AuthClientAcquireToken","cleanRequestByState","cloudInstanceHostname","_this3","cloudInstanceAuthorityUri","tenant","cloudInstanceAuthority","createDiscoveredInstance","options","updateAuthority","CCS_CREDENTIAL","JSON","parse","error","errorPii"],"sources":["C:/Users/v-dkamali/Documents/AngularMSALAD/microsoft-login/node_modules/@azure/msal-browser/dist/interaction_handler/InteractionHandler.mjs"],"sourcesContent":["/*! @azure/msal-browser v3.1.0 2023-09-05 */\n'use strict';\nimport { PerformanceEvents, ClientAuthError, ServerError, invokeAsync, AuthorityFactory } from '@azure/msal-common';\nimport { createBrowserAuthError } from '../error/BrowserAuthError.mjs';\nimport { TemporaryCacheKeys } from '../utils/BrowserConstants.mjs';\nimport { hashEmptyError, userCancelled } from '../error/BrowserAuthErrorCodes.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * Abstract class which defines operations for a browser interaction handling class.\n */\nclass InteractionHandler {\n    constructor(authCodeModule, storageImpl, authCodeRequest, logger, performanceClient) {\n        this.authModule = authCodeModule;\n        this.browserStorage = storageImpl;\n        this.authCodeRequest = authCodeRequest;\n        this.logger = logger;\n        this.performanceClient = performanceClient;\n    }\n    /**\n     * Function to handle response parameters from hash.\n     * @param locationHash\n     */\n    async handleCodeResponseFromHash(locationHash, state, authority, networkModule) {\n        this.performanceClient.addQueueMeasurement(PerformanceEvents.HandleCodeResponseFromHash, this.authCodeRequest.correlationId);\n        this.logger.verbose(\"InteractionHandler.handleCodeResponse called\");\n        // Check that location hash isn't empty.\n        if (!locationHash) {\n            throw createBrowserAuthError(hashEmptyError);\n        }\n        // Handle code response.\n        const stateKey = this.browserStorage.generateStateKey(state);\n        const requestState = this.browserStorage.getTemporaryCache(stateKey);\n        if (!requestState) {\n            throw ClientAuthError.createStateNotFoundError(\"Cached State\");\n        }\n        let authCodeResponse;\n        try {\n            authCodeResponse = this.authModule.handleFragmentResponse(locationHash, requestState);\n        }\n        catch (e) {\n            if (e instanceof ServerError &&\n                e.subError === userCancelled) {\n                // Translate server error caused by user closing native prompt to corresponding first class MSAL error\n                throw createBrowserAuthError(userCancelled);\n            }\n            else {\n                throw e;\n            }\n        }\n        this.performanceClient.setPreQueueTime(PerformanceEvents.HandleCodeResponseFromServer, this.authCodeRequest.correlationId);\n        return this.handleCodeResponseFromServer(authCodeResponse, state, authority, networkModule);\n    }\n    /**\n     * Process auth code response from AAD\n     * @param authCodeResponse\n     * @param state\n     * @param authority\n     * @param networkModule\n     * @returns\n     */\n    async handleCodeResponseFromServer(authCodeResponse, state, authority, networkModule, validateNonce = true) {\n        this.performanceClient.addQueueMeasurement(PerformanceEvents.HandleCodeResponseFromServer, this.authCodeRequest.correlationId);\n        this.logger.trace(\"InteractionHandler.handleCodeResponseFromServer called\");\n        // Handle code response.\n        const stateKey = this.browserStorage.generateStateKey(state);\n        const requestState = this.browserStorage.getTemporaryCache(stateKey);\n        if (!requestState) {\n            throw ClientAuthError.createStateNotFoundError(\"Cached State\");\n        }\n        // Get cached items\n        const nonceKey = this.browserStorage.generateNonceKey(requestState);\n        const cachedNonce = this.browserStorage.getTemporaryCache(nonceKey);\n        // Assign code to request\n        this.authCodeRequest.code = authCodeResponse.code;\n        // Check for new cloud instance\n        if (authCodeResponse.cloud_instance_host_name) {\n            this.performanceClient.setPreQueueTime(PerformanceEvents.UpdateTokenEndpointAuthority, this.authCodeRequest.correlationId);\n            await this.updateTokenEndpointAuthority(authCodeResponse.cloud_instance_host_name, authority, networkModule);\n        }\n        // Nonce validation not needed when redirect not involved (e.g. hybrid spa, renewing token via rt)\n        if (validateNonce) {\n            authCodeResponse.nonce = cachedNonce || undefined;\n        }\n        authCodeResponse.state = requestState;\n        // Add CCS parameters if available\n        if (authCodeResponse.client_info) {\n            this.authCodeRequest.clientInfo = authCodeResponse.client_info;\n        }\n        else {\n            const cachedCcsCred = this.checkCcsCredentials();\n            if (cachedCcsCred) {\n                this.authCodeRequest.ccsCredential = cachedCcsCred;\n            }\n        }\n        // Acquire token with retrieved code.\n        const tokenResponse = (await invokeAsync(this.authModule.acquireToken.bind(this.authModule), PerformanceEvents.AuthClientAcquireToken, this.logger, this.performanceClient, this.authCodeRequest.correlationId)(this.authCodeRequest, authCodeResponse));\n        this.browserStorage.cleanRequestByState(state);\n        return tokenResponse;\n    }\n    /**\n     * Updates authority based on cloudInstanceHostname\n     * @param cloudInstanceHostname\n     * @param authority\n     * @param networkModule\n     */\n    async updateTokenEndpointAuthority(cloudInstanceHostname, authority, networkModule) {\n        this.performanceClient.addQueueMeasurement(PerformanceEvents.UpdateTokenEndpointAuthority, this.authCodeRequest.correlationId);\n        const cloudInstanceAuthorityUri = `https://${cloudInstanceHostname}/${authority.tenant}/`;\n        const cloudInstanceAuthority = await AuthorityFactory.createDiscoveredInstance(cloudInstanceAuthorityUri, networkModule, this.browserStorage, authority.options, this.logger, this.performanceClient, this.authCodeRequest.correlationId);\n        this.authModule.updateAuthority(cloudInstanceAuthority);\n    }\n    /**\n     * Looks up ccs creds in the cache\n     */\n    checkCcsCredentials() {\n        // Look up ccs credential in temp cache\n        const cachedCcsCred = this.browserStorage.getTemporaryCache(TemporaryCacheKeys.CCS_CREDENTIAL, true);\n        if (cachedCcsCred) {\n            try {\n                return JSON.parse(cachedCcsCred);\n            }\n            catch (e) {\n                this.authModule.logger.error(\"Cache credential could not be parsed\");\n                this.authModule.logger.errorPii(`Cache credential could not be parsed: ${cachedCcsCred}`);\n            }\n        }\n        return null;\n    }\n}\n\nexport { InteractionHandler };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}