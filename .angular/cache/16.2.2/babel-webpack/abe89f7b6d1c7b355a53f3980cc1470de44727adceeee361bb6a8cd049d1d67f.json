{"ast":null,"code":"/*! @azure/msal-browser v3.1.0 2023-09-05 */\n'use strict';\n\nimport _asyncToGenerator from \"C:/Users/v-dkamali/Documents/AngularMSALAD/microsoft-login/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { PerformanceEvents, Constants, AuthError, UrlString, ProtocolUtils, ThrottlingUtils, ProtocolMode } from '@azure/msal-common';\nimport { StandardInteractionClient } from './StandardInteractionClient.mjs';\nimport { InteractionType, ApiId, TemporaryCacheKeys } from '../utils/BrowserConstants.mjs';\nimport { RedirectHandler } from '../interaction_handler/RedirectHandler.mjs';\nimport { BrowserUtils } from '../utils/BrowserUtils.mjs';\nimport { EventType } from '../event/EventType.mjs';\nimport { createBrowserAuthError } from '../error/BrowserAuthError.mjs';\nimport { NativeInteractionClient } from './NativeInteractionClient.mjs';\nimport { NativeMessageHandler } from '../broker/nativeBroker/NativeMessageHandler.mjs';\nimport { nativeConnectionNotEstablished, noCachedAuthorityError } from '../error/BrowserAuthErrorCodes.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nclass RedirectClient extends StandardInteractionClient {\n  constructor(config, storageImpl, browserCrypto, logger, eventHandler, navigationClient, performanceClient, nativeStorageImpl, nativeMessageHandler, correlationId) {\n    super(config, storageImpl, browserCrypto, logger, eventHandler, navigationClient, performanceClient, nativeMessageHandler, correlationId);\n    this.nativeStorage = nativeStorageImpl;\n  }\n  /**\n   * Redirects the page to the /authorize endpoint of the IDP\n   * @param request\n   */\n  acquireToken(request) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      _this.performanceClient.setPreQueueTime(PerformanceEvents.StandardInteractionClientInitializeAuthorizationRequest, request.correlationId);\n      const validRequest = yield _this.initializeAuthorizationRequest(request, InteractionType.Redirect);\n      _this.browserStorage.updateCacheEntries(validRequest.state, validRequest.nonce, validRequest.authority, validRequest.loginHint || Constants.EMPTY_STRING, validRequest.account || null);\n      const serverTelemetryManager = _this.initializeServerTelemetryManager(ApiId.acquireTokenRedirect);\n      const handleBackButton = event => {\n        // Clear temporary cache if the back button is clicked during the redirect flow.\n        if (event.persisted) {\n          _this.logger.verbose(\"Page was restored from back/forward cache. Clearing temporary cache.\");\n          _this.browserStorage.cleanRequestByState(validRequest.state);\n          _this.eventHandler.emitEvent(EventType.RESTORE_FROM_BFCACHE, InteractionType.Redirect);\n        }\n      };\n      try {\n        // Create auth code request and generate PKCE params\n        _this.performanceClient.setPreQueueTime(PerformanceEvents.StandardInteractionClientInitializeAuthorizationCodeRequest, request.correlationId);\n        const authCodeRequest = yield _this.initializeAuthorizationCodeRequest(validRequest);\n        // Initialize the client\n        _this.performanceClient.setPreQueueTime(PerformanceEvents.StandardInteractionClientCreateAuthCodeClient, request.correlationId);\n        const authClient = yield _this.createAuthCodeClient(serverTelemetryManager, validRequest.authority, validRequest.azureCloudOptions);\n        _this.logger.verbose(\"Auth code client created\");\n        // Create redirect interaction handler.\n        const interactionHandler = new RedirectHandler(authClient, _this.browserStorage, authCodeRequest, _this.logger, _this.browserCrypto, _this.performanceClient);\n        // Create acquire token url.\n        const navigateUrl = yield authClient.getAuthCodeUrl({\n          ...validRequest,\n          nativeBroker: NativeMessageHandler.isNativeAvailable(_this.config, _this.logger, _this.nativeMessageHandler, request.authenticationScheme)\n        });\n        const redirectStartPage = _this.getRedirectStartPage(request.redirectStartPage);\n        _this.logger.verbosePii(`Redirect start page: ${redirectStartPage}`);\n        // Clear temporary cache if the back button is clicked during the redirect flow.\n        window.addEventListener(\"pageshow\", handleBackButton);\n        // Show the UI once the url has been created. Response will come back in the hash, which will be handled in the handleRedirectCallback function.\n        return yield interactionHandler.initiateAuthRequest(navigateUrl, {\n          navigationClient: _this.navigationClient,\n          redirectTimeout: _this.config.system.redirectNavigationTimeout,\n          redirectStartPage: redirectStartPage,\n          onRedirectNavigate: request.onRedirectNavigate\n        });\n      } catch (e) {\n        if (e instanceof AuthError) {\n          e.setCorrelationId(_this.correlationId);\n          serverTelemetryManager.cacheFailedRequest(e);\n        }\n        window.removeEventListener(\"pageshow\", handleBackButton);\n        _this.browserStorage.cleanRequestByState(validRequest.state);\n        throw e;\n      }\n    })();\n  }\n  /**\n   * Checks if navigateToLoginRequestUrl is set, and:\n   * - if true, performs logic to cache and navigate\n   * - if false, handles hash string and parses response\n   * @param hash\n   */\n  handleRedirectPromise(hash) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const serverTelemetryManager = _this2.initializeServerTelemetryManager(ApiId.handleRedirectPromise);\n      try {\n        if (!_this2.browserStorage.isInteractionInProgress(true)) {\n          _this2.logger.info(\"handleRedirectPromise called but there is no interaction in progress, returning null.\");\n          return null;\n        }\n        const responseHash = _this2.getRedirectResponseHash(hash || window.location.hash);\n        if (!responseHash) {\n          // Not a recognized server response hash or hash not associated with a redirect request\n          _this2.logger.info(\"handleRedirectPromise did not detect a response hash as a result of a redirect. Cleaning temporary cache.\");\n          _this2.browserStorage.cleanRequestByInteractionType(InteractionType.Redirect);\n          return null;\n        }\n        let state;\n        try {\n          // Deserialize hash fragment response parameters.\n          const serverParams = UrlString.getDeserializedHash(responseHash);\n          state = _this2.validateAndExtractStateFromHash(serverParams, InteractionType.Redirect);\n          _this2.logger.verbose(\"State extracted from hash\");\n        } catch (e) {\n          _this2.logger.info(`handleRedirectPromise was unable to extract state due to: ${e}`);\n          _this2.browserStorage.cleanRequestByInteractionType(InteractionType.Redirect);\n          return null;\n        }\n        // If navigateToLoginRequestUrl is true, get the url where the redirect request was initiated\n        const loginRequestUrl = _this2.browserStorage.getTemporaryCache(TemporaryCacheKeys.ORIGIN_URI, true) || Constants.EMPTY_STRING;\n        const loginRequestUrlNormalized = UrlString.removeHashFromUrl(loginRequestUrl);\n        const currentUrlNormalized = UrlString.removeHashFromUrl(window.location.href);\n        if (loginRequestUrlNormalized === currentUrlNormalized && _this2.config.auth.navigateToLoginRequestUrl) {\n          // We are on the page we need to navigate to - handle hash\n          _this2.logger.verbose(\"Current page is loginRequestUrl, handling hash\");\n          const handleHashResult = yield _this2.handleHash(responseHash, state, serverTelemetryManager);\n          if (loginRequestUrl.indexOf(\"#\") > -1) {\n            // Replace current hash with non-msal hash, if present\n            BrowserUtils.replaceHash(loginRequestUrl);\n          }\n          return handleHashResult;\n        } else if (!_this2.config.auth.navigateToLoginRequestUrl) {\n          _this2.logger.verbose(\"NavigateToLoginRequestUrl set to false, handling hash\");\n          return _this2.handleHash(responseHash, state, serverTelemetryManager);\n        } else if (!BrowserUtils.isInIframe() || _this2.config.system.allowRedirectInIframe) {\n          /*\n           * Returned from authority using redirect - need to perform navigation before processing response\n           * Cache the hash to be retrieved after the next redirect\n           */\n          _this2.browserStorage.setTemporaryCache(TemporaryCacheKeys.URL_HASH, responseHash, true);\n          const navigationOptions = {\n            apiId: ApiId.handleRedirectPromise,\n            timeout: _this2.config.system.redirectNavigationTimeout,\n            noHistory: true\n          };\n          /**\n           * Default behavior is to redirect to the start page and not process the hash now.\n           * The start page is expected to also call handleRedirectPromise which will process the hash in one of the checks above.\n           */\n          let processHashOnRedirect = true;\n          if (!loginRequestUrl || loginRequestUrl === \"null\") {\n            // Redirect to home page if login request url is null (real null or the string null)\n            const homepage = BrowserUtils.getHomepage();\n            // Cache the homepage under ORIGIN_URI to ensure cached hash is processed on homepage\n            _this2.browserStorage.setTemporaryCache(TemporaryCacheKeys.ORIGIN_URI, homepage, true);\n            _this2.logger.warning(\"Unable to get valid login request url from cache, redirecting to home page\");\n            processHashOnRedirect = yield _this2.navigationClient.navigateInternal(homepage, navigationOptions);\n          } else {\n            // Navigate to page that initiated the redirect request\n            _this2.logger.verbose(`Navigating to loginRequestUrl: ${loginRequestUrl}`);\n            processHashOnRedirect = yield _this2.navigationClient.navigateInternal(loginRequestUrl, navigationOptions);\n          }\n          // If navigateInternal implementation returns false, handle the hash now\n          if (!processHashOnRedirect) {\n            return _this2.handleHash(responseHash, state, serverTelemetryManager);\n          }\n        }\n        return null;\n      } catch (e) {\n        if (e instanceof AuthError) {\n          e.setCorrelationId(_this2.correlationId);\n          serverTelemetryManager.cacheFailedRequest(e);\n        }\n        _this2.browserStorage.cleanRequestByInteractionType(InteractionType.Redirect);\n        throw e;\n      }\n    })();\n  }\n  /**\n   * Gets the response hash for a redirect request\n   * Returns null if interactionType in the state value is not \"redirect\" or the hash does not contain known properties\n   * @param hash\n   */\n  getRedirectResponseHash(hash) {\n    this.logger.verbose(\"getRedirectResponseHash called\");\n    // Get current location hash from window or cache.\n    const isResponseHash = UrlString.hashContainsKnownProperties(hash);\n    if (isResponseHash) {\n      BrowserUtils.clearHash(window);\n      this.logger.verbose(\"Hash contains known properties, returning response hash\");\n      return hash;\n    }\n    const cachedHash = this.browserStorage.getTemporaryCache(TemporaryCacheKeys.URL_HASH, true);\n    this.browserStorage.removeItem(this.browserStorage.generateCacheKey(TemporaryCacheKeys.URL_HASH));\n    this.logger.verbose(\"Hash does not contain known properties, returning cached hash\");\n    return cachedHash;\n  }\n  /**\n   * Checks if hash exists and handles in window.\n   * @param hash\n   * @param state\n   */\n  handleHash(hash, state, serverTelemetryManager) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const cachedRequest = _this3.browserStorage.getCachedRequest(state);\n      _this3.logger.verbose(\"handleHash called, retrieved cached request\");\n      const serverParams = UrlString.getDeserializedHash(hash);\n      if (serverParams.accountId) {\n        _this3.logger.verbose(\"Account id found in hash, calling WAM for token\");\n        if (!_this3.nativeMessageHandler) {\n          throw createBrowserAuthError(nativeConnectionNotEstablished);\n        }\n        const nativeInteractionClient = new NativeInteractionClient(_this3.config, _this3.browserStorage, _this3.browserCrypto, _this3.logger, _this3.eventHandler, _this3.navigationClient, ApiId.acquireTokenPopup, _this3.performanceClient, _this3.nativeMessageHandler, serverParams.accountId, _this3.nativeStorage, cachedRequest.correlationId);\n        const {\n          userRequestState\n        } = ProtocolUtils.parseRequestState(_this3.browserCrypto, state);\n        return nativeInteractionClient.acquireToken({\n          ...cachedRequest,\n          state: userRequestState,\n          prompt: undefined // Server should handle the prompt, ideally native broker can do this part silently\n        }).finally(() => {\n          _this3.browserStorage.cleanRequestByState(state);\n        });\n      }\n      // Hash contains known properties - handle and return in callback\n      const currentAuthority = _this3.browserStorage.getCachedAuthority(state);\n      if (!currentAuthority) {\n        throw createBrowserAuthError(noCachedAuthorityError);\n      }\n      _this3.performanceClient.setPreQueueTime(PerformanceEvents.StandardInteractionClientCreateAuthCodeClient, cachedRequest.correlationId);\n      const authClient = yield _this3.createAuthCodeClient(serverTelemetryManager, currentAuthority);\n      _this3.logger.verbose(\"Auth code client created\");\n      ThrottlingUtils.removeThrottle(_this3.browserStorage, _this3.config.auth.clientId, cachedRequest);\n      const interactionHandler = new RedirectHandler(authClient, _this3.browserStorage, cachedRequest, _this3.logger, _this3.browserCrypto, _this3.performanceClient);\n      return yield interactionHandler.handleCodeResponseFromHash(hash, state, authClient.authority, _this3.networkClient);\n    })();\n  }\n  /**\n   * Use to log out the current user, and redirect the user to the postLogoutRedirectUri.\n   * Default behaviour is to redirect the user to `window.location.href`.\n   * @param logoutRequest\n   */\n  logout(logoutRequest) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      _this4.logger.verbose(\"logoutRedirect called\");\n      const validLogoutRequest = _this4.initializeLogoutRequest(logoutRequest);\n      const serverTelemetryManager = _this4.initializeServerTelemetryManager(ApiId.logout);\n      try {\n        _this4.eventHandler.emitEvent(EventType.LOGOUT_START, InteractionType.Redirect, logoutRequest);\n        // Clear cache on logout\n        yield _this4.clearCacheOnLogout(validLogoutRequest.account);\n        const navigationOptions = {\n          apiId: ApiId.logout,\n          timeout: _this4.config.system.redirectNavigationTimeout,\n          noHistory: false\n        };\n        _this4.performanceClient.setPreQueueTime(PerformanceEvents.StandardInteractionClientCreateAuthCodeClient, validLogoutRequest.correlationId);\n        const authClient = yield _this4.createAuthCodeClient(serverTelemetryManager, logoutRequest && logoutRequest.authority);\n        _this4.logger.verbose(\"Auth code client created\");\n        if (authClient.authority.protocolMode === ProtocolMode.OIDC) {\n          try {\n            authClient.authority.endSessionEndpoint;\n          } catch {\n            if (validLogoutRequest.account?.homeAccountId) {\n              void _this4.browserStorage.removeAccount(validLogoutRequest.account?.homeAccountId);\n              _this4.eventHandler.emitEvent(EventType.LOGOUT_SUCCESS, InteractionType.Redirect, validLogoutRequest);\n              return;\n            }\n          }\n        }\n        // Create logout string and navigate user window to logout.\n        const logoutUri = authClient.getLogoutUri(validLogoutRequest);\n        _this4.eventHandler.emitEvent(EventType.LOGOUT_SUCCESS, InteractionType.Redirect, validLogoutRequest);\n        // Check if onRedirectNavigate is implemented, and invoke it if so\n        if (logoutRequest && typeof logoutRequest.onRedirectNavigate === \"function\") {\n          const navigate = logoutRequest.onRedirectNavigate(logoutUri);\n          if (navigate !== false) {\n            _this4.logger.verbose(\"Logout onRedirectNavigate did not return false, navigating\");\n            // Ensure interaction is in progress\n            if (!_this4.browserStorage.getInteractionInProgress()) {\n              _this4.browserStorage.setInteractionInProgress(true);\n            }\n            yield _this4.navigationClient.navigateExternal(logoutUri, navigationOptions);\n            return;\n          } else {\n            // Ensure interaction is not in progress\n            _this4.browserStorage.setInteractionInProgress(false);\n            _this4.logger.verbose(\"Logout onRedirectNavigate returned false, stopping navigation\");\n          }\n        } else {\n          // Ensure interaction is in progress\n          if (!_this4.browserStorage.getInteractionInProgress()) {\n            _this4.browserStorage.setInteractionInProgress(true);\n          }\n          yield _this4.navigationClient.navigateExternal(logoutUri, navigationOptions);\n          return;\n        }\n      } catch (e) {\n        if (e instanceof AuthError) {\n          e.setCorrelationId(_this4.correlationId);\n          serverTelemetryManager.cacheFailedRequest(e);\n        }\n        _this4.eventHandler.emitEvent(EventType.LOGOUT_FAILURE, InteractionType.Redirect, null, e);\n        _this4.eventHandler.emitEvent(EventType.LOGOUT_END, InteractionType.Redirect);\n        throw e;\n      }\n      _this4.eventHandler.emitEvent(EventType.LOGOUT_END, InteractionType.Redirect);\n    })();\n  }\n  /**\n   * Use to get the redirectStartPage either from request or use current window\n   * @param requestStartPage\n   */\n  getRedirectStartPage(requestStartPage) {\n    const redirectStartPage = requestStartPage || window.location.href;\n    return UrlString.getAbsoluteUrl(redirectStartPage, BrowserUtils.getCurrentUri());\n  }\n}\nexport { RedirectClient };","map":{"version":3,"names":["_asyncToGenerator","PerformanceEvents","Constants","AuthError","UrlString","ProtocolUtils","ThrottlingUtils","ProtocolMode","StandardInteractionClient","InteractionType","ApiId","TemporaryCacheKeys","RedirectHandler","BrowserUtils","EventType","createBrowserAuthError","NativeInteractionClient","NativeMessageHandler","nativeConnectionNotEstablished","noCachedAuthorityError","RedirectClient","constructor","config","storageImpl","browserCrypto","logger","eventHandler","navigationClient","performanceClient","nativeStorageImpl","nativeMessageHandler","correlationId","nativeStorage","acquireToken","request","_this","setPreQueueTime","StandardInteractionClientInitializeAuthorizationRequest","validRequest","initializeAuthorizationRequest","Redirect","browserStorage","updateCacheEntries","state","nonce","authority","loginHint","EMPTY_STRING","account","serverTelemetryManager","initializeServerTelemetryManager","acquireTokenRedirect","handleBackButton","event","persisted","verbose","cleanRequestByState","emitEvent","RESTORE_FROM_BFCACHE","StandardInteractionClientInitializeAuthorizationCodeRequest","authCodeRequest","initializeAuthorizationCodeRequest","StandardInteractionClientCreateAuthCodeClient","authClient","createAuthCodeClient","azureCloudOptions","interactionHandler","navigateUrl","getAuthCodeUrl","nativeBroker","isNativeAvailable","authenticationScheme","redirectStartPage","getRedirectStartPage","verbosePii","window","addEventListener","initiateAuthRequest","redirectTimeout","system","redirectNavigationTimeout","onRedirectNavigate","e","setCorrelationId","cacheFailedRequest","removeEventListener","handleRedirectPromise","hash","_this2","isInteractionInProgress","info","responseHash","getRedirectResponseHash","location","cleanRequestByInteractionType","serverParams","getDeserializedHash","validateAndExtractStateFromHash","loginRequestUrl","getTemporaryCache","ORIGIN_URI","loginRequestUrlNormalized","removeHashFromUrl","currentUrlNormalized","href","auth","navigateToLoginRequestUrl","handleHashResult","handleHash","indexOf","replaceHash","isInIframe","allowRedirectInIframe","setTemporaryCache","URL_HASH","navigationOptions","apiId","timeout","noHistory","processHashOnRedirect","homepage","getHomepage","warning","navigateInternal","isResponseHash","hashContainsKnownProperties","clearHash","cachedHash","removeItem","generateCacheKey","_this3","cachedRequest","getCachedRequest","accountId","nativeInteractionClient","acquireTokenPopup","userRequestState","parseRequestState","prompt","undefined","finally","currentAuthority","getCachedAuthority","removeThrottle","clientId","handleCodeResponseFromHash","networkClient","logout","logoutRequest","_this4","validLogoutRequest","initializeLogoutRequest","LOGOUT_START","clearCacheOnLogout","protocolMode","OIDC","endSessionEndpoint","homeAccountId","removeAccount","LOGOUT_SUCCESS","logoutUri","getLogoutUri","navigate","getInteractionInProgress","setInteractionInProgress","navigateExternal","LOGOUT_FAILURE","LOGOUT_END","requestStartPage","getAbsoluteUrl","getCurrentUri"],"sources":["C:/Users/v-dkamali/Documents/AngularMSALAD/microsoft-login/node_modules/@azure/msal-browser/dist/interaction_client/RedirectClient.mjs"],"sourcesContent":["/*! @azure/msal-browser v3.1.0 2023-09-05 */\n'use strict';\nimport { PerformanceEvents, Constants, AuthError, UrlString, ProtocolUtils, ThrottlingUtils, ProtocolMode } from '@azure/msal-common';\nimport { StandardInteractionClient } from './StandardInteractionClient.mjs';\nimport { InteractionType, ApiId, TemporaryCacheKeys } from '../utils/BrowserConstants.mjs';\nimport { RedirectHandler } from '../interaction_handler/RedirectHandler.mjs';\nimport { BrowserUtils } from '../utils/BrowserUtils.mjs';\nimport { EventType } from '../event/EventType.mjs';\nimport { createBrowserAuthError } from '../error/BrowserAuthError.mjs';\nimport { NativeInteractionClient } from './NativeInteractionClient.mjs';\nimport { NativeMessageHandler } from '../broker/nativeBroker/NativeMessageHandler.mjs';\nimport { nativeConnectionNotEstablished, noCachedAuthorityError } from '../error/BrowserAuthErrorCodes.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nclass RedirectClient extends StandardInteractionClient {\n    constructor(config, storageImpl, browserCrypto, logger, eventHandler, navigationClient, performanceClient, nativeStorageImpl, nativeMessageHandler, correlationId) {\n        super(config, storageImpl, browserCrypto, logger, eventHandler, navigationClient, performanceClient, nativeMessageHandler, correlationId);\n        this.nativeStorage = nativeStorageImpl;\n    }\n    /**\n     * Redirects the page to the /authorize endpoint of the IDP\n     * @param request\n     */\n    async acquireToken(request) {\n        this.performanceClient.setPreQueueTime(PerformanceEvents.StandardInteractionClientInitializeAuthorizationRequest, request.correlationId);\n        const validRequest = await this.initializeAuthorizationRequest(request, InteractionType.Redirect);\n        this.browserStorage.updateCacheEntries(validRequest.state, validRequest.nonce, validRequest.authority, validRequest.loginHint || Constants.EMPTY_STRING, validRequest.account || null);\n        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenRedirect);\n        const handleBackButton = (event) => {\n            // Clear temporary cache if the back button is clicked during the redirect flow.\n            if (event.persisted) {\n                this.logger.verbose(\"Page was restored from back/forward cache. Clearing temporary cache.\");\n                this.browserStorage.cleanRequestByState(validRequest.state);\n                this.eventHandler.emitEvent(EventType.RESTORE_FROM_BFCACHE, InteractionType.Redirect);\n            }\n        };\n        try {\n            // Create auth code request and generate PKCE params\n            this.performanceClient.setPreQueueTime(PerformanceEvents.StandardInteractionClientInitializeAuthorizationCodeRequest, request.correlationId);\n            const authCodeRequest = await this.initializeAuthorizationCodeRequest(validRequest);\n            // Initialize the client\n            this.performanceClient.setPreQueueTime(PerformanceEvents.StandardInteractionClientCreateAuthCodeClient, request.correlationId);\n            const authClient = await this.createAuthCodeClient(serverTelemetryManager, validRequest.authority, validRequest.azureCloudOptions);\n            this.logger.verbose(\"Auth code client created\");\n            // Create redirect interaction handler.\n            const interactionHandler = new RedirectHandler(authClient, this.browserStorage, authCodeRequest, this.logger, this.browserCrypto, this.performanceClient);\n            // Create acquire token url.\n            const navigateUrl = await authClient.getAuthCodeUrl({\n                ...validRequest,\n                nativeBroker: NativeMessageHandler.isNativeAvailable(this.config, this.logger, this.nativeMessageHandler, request.authenticationScheme),\n            });\n            const redirectStartPage = this.getRedirectStartPage(request.redirectStartPage);\n            this.logger.verbosePii(`Redirect start page: ${redirectStartPage}`);\n            // Clear temporary cache if the back button is clicked during the redirect flow.\n            window.addEventListener(\"pageshow\", handleBackButton);\n            // Show the UI once the url has been created. Response will come back in the hash, which will be handled in the handleRedirectCallback function.\n            return await interactionHandler.initiateAuthRequest(navigateUrl, {\n                navigationClient: this.navigationClient,\n                redirectTimeout: this.config.system.redirectNavigationTimeout,\n                redirectStartPage: redirectStartPage,\n                onRedirectNavigate: request.onRedirectNavigate,\n            });\n        }\n        catch (e) {\n            if (e instanceof AuthError) {\n                e.setCorrelationId(this.correlationId);\n                serverTelemetryManager.cacheFailedRequest(e);\n            }\n            window.removeEventListener(\"pageshow\", handleBackButton);\n            this.browserStorage.cleanRequestByState(validRequest.state);\n            throw e;\n        }\n    }\n    /**\n     * Checks if navigateToLoginRequestUrl is set, and:\n     * - if true, performs logic to cache and navigate\n     * - if false, handles hash string and parses response\n     * @param hash\n     */\n    async handleRedirectPromise(hash) {\n        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.handleRedirectPromise);\n        try {\n            if (!this.browserStorage.isInteractionInProgress(true)) {\n                this.logger.info(\"handleRedirectPromise called but there is no interaction in progress, returning null.\");\n                return null;\n            }\n            const responseHash = this.getRedirectResponseHash(hash || window.location.hash);\n            if (!responseHash) {\n                // Not a recognized server response hash or hash not associated with a redirect request\n                this.logger.info(\"handleRedirectPromise did not detect a response hash as a result of a redirect. Cleaning temporary cache.\");\n                this.browserStorage.cleanRequestByInteractionType(InteractionType.Redirect);\n                return null;\n            }\n            let state;\n            try {\n                // Deserialize hash fragment response parameters.\n                const serverParams = UrlString.getDeserializedHash(responseHash);\n                state = this.validateAndExtractStateFromHash(serverParams, InteractionType.Redirect);\n                this.logger.verbose(\"State extracted from hash\");\n            }\n            catch (e) {\n                this.logger.info(`handleRedirectPromise was unable to extract state due to: ${e}`);\n                this.browserStorage.cleanRequestByInteractionType(InteractionType.Redirect);\n                return null;\n            }\n            // If navigateToLoginRequestUrl is true, get the url where the redirect request was initiated\n            const loginRequestUrl = this.browserStorage.getTemporaryCache(TemporaryCacheKeys.ORIGIN_URI, true) || Constants.EMPTY_STRING;\n            const loginRequestUrlNormalized = UrlString.removeHashFromUrl(loginRequestUrl);\n            const currentUrlNormalized = UrlString.removeHashFromUrl(window.location.href);\n            if (loginRequestUrlNormalized === currentUrlNormalized &&\n                this.config.auth.navigateToLoginRequestUrl) {\n                // We are on the page we need to navigate to - handle hash\n                this.logger.verbose(\"Current page is loginRequestUrl, handling hash\");\n                const handleHashResult = await this.handleHash(responseHash, state, serverTelemetryManager);\n                if (loginRequestUrl.indexOf(\"#\") > -1) {\n                    // Replace current hash with non-msal hash, if present\n                    BrowserUtils.replaceHash(loginRequestUrl);\n                }\n                return handleHashResult;\n            }\n            else if (!this.config.auth.navigateToLoginRequestUrl) {\n                this.logger.verbose(\"NavigateToLoginRequestUrl set to false, handling hash\");\n                return this.handleHash(responseHash, state, serverTelemetryManager);\n            }\n            else if (!BrowserUtils.isInIframe() ||\n                this.config.system.allowRedirectInIframe) {\n                /*\n                 * Returned from authority using redirect - need to perform navigation before processing response\n                 * Cache the hash to be retrieved after the next redirect\n                 */\n                this.browserStorage.setTemporaryCache(TemporaryCacheKeys.URL_HASH, responseHash, true);\n                const navigationOptions = {\n                    apiId: ApiId.handleRedirectPromise,\n                    timeout: this.config.system.redirectNavigationTimeout,\n                    noHistory: true,\n                };\n                /**\n                 * Default behavior is to redirect to the start page and not process the hash now.\n                 * The start page is expected to also call handleRedirectPromise which will process the hash in one of the checks above.\n                 */\n                let processHashOnRedirect = true;\n                if (!loginRequestUrl || loginRequestUrl === \"null\") {\n                    // Redirect to home page if login request url is null (real null or the string null)\n                    const homepage = BrowserUtils.getHomepage();\n                    // Cache the homepage under ORIGIN_URI to ensure cached hash is processed on homepage\n                    this.browserStorage.setTemporaryCache(TemporaryCacheKeys.ORIGIN_URI, homepage, true);\n                    this.logger.warning(\"Unable to get valid login request url from cache, redirecting to home page\");\n                    processHashOnRedirect =\n                        await this.navigationClient.navigateInternal(homepage, navigationOptions);\n                }\n                else {\n                    // Navigate to page that initiated the redirect request\n                    this.logger.verbose(`Navigating to loginRequestUrl: ${loginRequestUrl}`);\n                    processHashOnRedirect =\n                        await this.navigationClient.navigateInternal(loginRequestUrl, navigationOptions);\n                }\n                // If navigateInternal implementation returns false, handle the hash now\n                if (!processHashOnRedirect) {\n                    return this.handleHash(responseHash, state, serverTelemetryManager);\n                }\n            }\n            return null;\n        }\n        catch (e) {\n            if (e instanceof AuthError) {\n                e.setCorrelationId(this.correlationId);\n                serverTelemetryManager.cacheFailedRequest(e);\n            }\n            this.browserStorage.cleanRequestByInteractionType(InteractionType.Redirect);\n            throw e;\n        }\n    }\n    /**\n     * Gets the response hash for a redirect request\n     * Returns null if interactionType in the state value is not \"redirect\" or the hash does not contain known properties\n     * @param hash\n     */\n    getRedirectResponseHash(hash) {\n        this.logger.verbose(\"getRedirectResponseHash called\");\n        // Get current location hash from window or cache.\n        const isResponseHash = UrlString.hashContainsKnownProperties(hash);\n        if (isResponseHash) {\n            BrowserUtils.clearHash(window);\n            this.logger.verbose(\"Hash contains known properties, returning response hash\");\n            return hash;\n        }\n        const cachedHash = this.browserStorage.getTemporaryCache(TemporaryCacheKeys.URL_HASH, true);\n        this.browserStorage.removeItem(this.browserStorage.generateCacheKey(TemporaryCacheKeys.URL_HASH));\n        this.logger.verbose(\"Hash does not contain known properties, returning cached hash\");\n        return cachedHash;\n    }\n    /**\n     * Checks if hash exists and handles in window.\n     * @param hash\n     * @param state\n     */\n    async handleHash(hash, state, serverTelemetryManager) {\n        const cachedRequest = this.browserStorage.getCachedRequest(state);\n        this.logger.verbose(\"handleHash called, retrieved cached request\");\n        const serverParams = UrlString.getDeserializedHash(hash);\n        if (serverParams.accountId) {\n            this.logger.verbose(\"Account id found in hash, calling WAM for token\");\n            if (!this.nativeMessageHandler) {\n                throw createBrowserAuthError(nativeConnectionNotEstablished);\n            }\n            const nativeInteractionClient = new NativeInteractionClient(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, ApiId.acquireTokenPopup, this.performanceClient, this.nativeMessageHandler, serverParams.accountId, this.nativeStorage, cachedRequest.correlationId);\n            const { userRequestState } = ProtocolUtils.parseRequestState(this.browserCrypto, state);\n            return nativeInteractionClient\n                .acquireToken({\n                ...cachedRequest,\n                state: userRequestState,\n                prompt: undefined, // Server should handle the prompt, ideally native broker can do this part silently\n            })\n                .finally(() => {\n                this.browserStorage.cleanRequestByState(state);\n            });\n        }\n        // Hash contains known properties - handle and return in callback\n        const currentAuthority = this.browserStorage.getCachedAuthority(state);\n        if (!currentAuthority) {\n            throw createBrowserAuthError(noCachedAuthorityError);\n        }\n        this.performanceClient.setPreQueueTime(PerformanceEvents.StandardInteractionClientCreateAuthCodeClient, cachedRequest.correlationId);\n        const authClient = await this.createAuthCodeClient(serverTelemetryManager, currentAuthority);\n        this.logger.verbose(\"Auth code client created\");\n        ThrottlingUtils.removeThrottle(this.browserStorage, this.config.auth.clientId, cachedRequest);\n        const interactionHandler = new RedirectHandler(authClient, this.browserStorage, cachedRequest, this.logger, this.browserCrypto, this.performanceClient);\n        return await interactionHandler.handleCodeResponseFromHash(hash, state, authClient.authority, this.networkClient);\n    }\n    /**\n     * Use to log out the current user, and redirect the user to the postLogoutRedirectUri.\n     * Default behaviour is to redirect the user to `window.location.href`.\n     * @param logoutRequest\n     */\n    async logout(logoutRequest) {\n        this.logger.verbose(\"logoutRedirect called\");\n        const validLogoutRequest = this.initializeLogoutRequest(logoutRequest);\n        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.logout);\n        try {\n            this.eventHandler.emitEvent(EventType.LOGOUT_START, InteractionType.Redirect, logoutRequest);\n            // Clear cache on logout\n            await this.clearCacheOnLogout(validLogoutRequest.account);\n            const navigationOptions = {\n                apiId: ApiId.logout,\n                timeout: this.config.system.redirectNavigationTimeout,\n                noHistory: false,\n            };\n            this.performanceClient.setPreQueueTime(PerformanceEvents.StandardInteractionClientCreateAuthCodeClient, validLogoutRequest.correlationId);\n            const authClient = await this.createAuthCodeClient(serverTelemetryManager, logoutRequest && logoutRequest.authority);\n            this.logger.verbose(\"Auth code client created\");\n            if (authClient.authority.protocolMode === ProtocolMode.OIDC) {\n                try {\n                    authClient.authority.endSessionEndpoint;\n                }\n                catch {\n                    if (validLogoutRequest.account?.homeAccountId) {\n                        void this.browserStorage.removeAccount(validLogoutRequest.account?.homeAccountId);\n                        this.eventHandler.emitEvent(EventType.LOGOUT_SUCCESS, InteractionType.Redirect, validLogoutRequest);\n                        return;\n                    }\n                }\n            }\n            // Create logout string and navigate user window to logout.\n            const logoutUri = authClient.getLogoutUri(validLogoutRequest);\n            this.eventHandler.emitEvent(EventType.LOGOUT_SUCCESS, InteractionType.Redirect, validLogoutRequest);\n            // Check if onRedirectNavigate is implemented, and invoke it if so\n            if (logoutRequest &&\n                typeof logoutRequest.onRedirectNavigate === \"function\") {\n                const navigate = logoutRequest.onRedirectNavigate(logoutUri);\n                if (navigate !== false) {\n                    this.logger.verbose(\"Logout onRedirectNavigate did not return false, navigating\");\n                    // Ensure interaction is in progress\n                    if (!this.browserStorage.getInteractionInProgress()) {\n                        this.browserStorage.setInteractionInProgress(true);\n                    }\n                    await this.navigationClient.navigateExternal(logoutUri, navigationOptions);\n                    return;\n                }\n                else {\n                    // Ensure interaction is not in progress\n                    this.browserStorage.setInteractionInProgress(false);\n                    this.logger.verbose(\"Logout onRedirectNavigate returned false, stopping navigation\");\n                }\n            }\n            else {\n                // Ensure interaction is in progress\n                if (!this.browserStorage.getInteractionInProgress()) {\n                    this.browserStorage.setInteractionInProgress(true);\n                }\n                await this.navigationClient.navigateExternal(logoutUri, navigationOptions);\n                return;\n            }\n        }\n        catch (e) {\n            if (e instanceof AuthError) {\n                e.setCorrelationId(this.correlationId);\n                serverTelemetryManager.cacheFailedRequest(e);\n            }\n            this.eventHandler.emitEvent(EventType.LOGOUT_FAILURE, InteractionType.Redirect, null, e);\n            this.eventHandler.emitEvent(EventType.LOGOUT_END, InteractionType.Redirect);\n            throw e;\n        }\n        this.eventHandler.emitEvent(EventType.LOGOUT_END, InteractionType.Redirect);\n    }\n    /**\n     * Use to get the redirectStartPage either from request or use current window\n     * @param requestStartPage\n     */\n    getRedirectStartPage(requestStartPage) {\n        const redirectStartPage = requestStartPage || window.location.href;\n        return UrlString.getAbsoluteUrl(redirectStartPage, BrowserUtils.getCurrentUri());\n    }\n}\n\nexport { RedirectClient };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}