{"ast":null,"code":"/*! @azure/msal-common v14.0.3 2023-09-05 */\n'use strict';\n\nimport { ClientConfigurationError } from '../error/ClientConfigurationError.mjs';\nimport { ClientAuthError } from '../error/ClientAuthError.mjs';\nimport { StringUtils } from '../utils/StringUtils.mjs';\nimport { AADAuthorityConstants, Constants, ServerResponseType } from '../utils/Constants.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * Url object class which can perform various transformations on url strings.\n */\nclass UrlString {\n  get urlString() {\n    return this._urlString;\n  }\n  constructor(url) {\n    this._urlString = url;\n    if (!this._urlString) {\n      // Throws error if url is empty\n      throw ClientConfigurationError.createUrlEmptyError();\n    }\n    if (!this.getHash()) {\n      this._urlString = UrlString.canonicalizeUri(url);\n    }\n  }\n  /**\n   * Ensure urls are lower case and end with a / character.\n   * @param url\n   */\n  static canonicalizeUri(url) {\n    if (url) {\n      let lowerCaseUrl = url.toLowerCase();\n      if (StringUtils.endsWith(lowerCaseUrl, \"?\")) {\n        lowerCaseUrl = lowerCaseUrl.slice(0, -1);\n      } else if (StringUtils.endsWith(lowerCaseUrl, \"?/\")) {\n        lowerCaseUrl = lowerCaseUrl.slice(0, -2);\n      }\n      if (!StringUtils.endsWith(lowerCaseUrl, \"/\")) {\n        lowerCaseUrl += \"/\";\n      }\n      return lowerCaseUrl;\n    }\n    return url;\n  }\n  /**\n   * Throws if urlString passed is not a valid authority URI string.\n   */\n  validateAsUri() {\n    // Attempts to parse url for uri components\n    let components;\n    try {\n      components = this.getUrlComponents();\n    } catch (e) {\n      throw ClientConfigurationError.createUrlParseError(e);\n    }\n    // Throw error if URI or path segments are not parseable.\n    if (!components.HostNameAndPort || !components.PathSegments) {\n      throw ClientConfigurationError.createUrlParseError(`Given url string: ${this.urlString}`);\n    }\n    // Throw error if uri is insecure.\n    if (!components.Protocol || components.Protocol.toLowerCase() !== \"https:\") {\n      throw ClientConfigurationError.createInsecureAuthorityUriError(this.urlString);\n    }\n  }\n  /**\n   * Given a url and a query string return the url with provided query string appended\n   * @param url\n   * @param queryString\n   */\n  static appendQueryString(url, queryString) {\n    if (!queryString) {\n      return url;\n    }\n    return url.indexOf(\"?\") < 0 ? `${url}?${queryString}` : `${url}&${queryString}`;\n  }\n  /**\n   * Returns a url with the hash removed\n   * @param url\n   */\n  static removeHashFromUrl(url) {\n    return UrlString.canonicalizeUri(url.split(\"#\")[0]);\n  }\n  /**\n   * Given a url like https://a:b/common/d?e=f#g, and a tenantId, returns https://a:b/tenantId/d\n   * @param href The url\n   * @param tenantId The tenant id to replace\n   */\n  replaceTenantPath(tenantId) {\n    const urlObject = this.getUrlComponents();\n    const pathArray = urlObject.PathSegments;\n    if (tenantId && pathArray.length !== 0 && (pathArray[0] === AADAuthorityConstants.COMMON || pathArray[0] === AADAuthorityConstants.ORGANIZATIONS)) {\n      pathArray[0] = tenantId;\n    }\n    return UrlString.constructAuthorityUriFromObject(urlObject);\n  }\n  /**\n   * Returns the anchor part(#) of the URL\n   */\n  getHash() {\n    return UrlString.parseHash(this.urlString);\n  }\n  /**\n   * Parses out the components from a url string.\n   * @returns An object with the various components. Please cache this value insted of calling this multiple times on the same url.\n   */\n  getUrlComponents() {\n    // https://gist.github.com/curtisz/11139b2cfcaef4a261e0\n    const regEx = RegExp(\"^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\\\?([^#]*))?(#(.*))?\");\n    // If url string does not match regEx, we throw an error\n    const match = this.urlString.match(regEx);\n    if (!match) {\n      throw ClientConfigurationError.createUrlParseError(`Given url string: ${this.urlString}`);\n    }\n    // Url component object\n    const urlComponents = {\n      Protocol: match[1],\n      HostNameAndPort: match[4],\n      AbsolutePath: match[5],\n      QueryString: match[7]\n    };\n    let pathSegments = urlComponents.AbsolutePath.split(\"/\");\n    pathSegments = pathSegments.filter(val => val && val.length > 0); // remove empty elements\n    urlComponents.PathSegments = pathSegments;\n    if (urlComponents.QueryString && urlComponents.QueryString.endsWith(\"/\")) {\n      urlComponents.QueryString = urlComponents.QueryString.substring(0, urlComponents.QueryString.length - 1);\n    }\n    return urlComponents;\n  }\n  static getDomainFromUrl(url) {\n    const regEx = RegExp(\"^([^:/?#]+://)?([^/?#]*)\");\n    const match = url.match(regEx);\n    if (!match) {\n      throw ClientConfigurationError.createUrlParseError(`Given url string: ${url}`);\n    }\n    return match[2];\n  }\n  static getAbsoluteUrl(relativeUrl, baseUrl) {\n    if (relativeUrl[0] === Constants.FORWARD_SLASH) {\n      const url = new UrlString(baseUrl);\n      const baseComponents = url.getUrlComponents();\n      return baseComponents.Protocol + \"//\" + baseComponents.HostNameAndPort + relativeUrl;\n    }\n    return relativeUrl;\n  }\n  /**\n   * Parses hash string from given string. Returns empty string if no hash symbol is found.\n   * @param hashString\n   */\n  static parseHash(hashString) {\n    const hashIndex1 = hashString.indexOf(\"#\");\n    const hashIndex2 = hashString.indexOf(\"#/\");\n    if (hashIndex2 > -1) {\n      return hashString.substring(hashIndex2 + 2);\n    } else if (hashIndex1 > -1) {\n      return hashString.substring(hashIndex1 + 1);\n    }\n    return Constants.EMPTY_STRING;\n  }\n  /**\n   * Parses query string from given string. Returns empty string if no query symbol is found.\n   * @param queryString\n   */\n  static parseQueryString(queryString) {\n    const queryIndex1 = queryString.indexOf(\"?\");\n    const queryIndex2 = queryString.indexOf(\"/?\");\n    if (queryIndex2 > -1) {\n      return queryString.substring(queryIndex2 + 2);\n    } else if (queryIndex1 > -1) {\n      return queryString.substring(queryIndex1 + 1);\n    }\n    return Constants.EMPTY_STRING;\n  }\n  /**\n   * Parses query server response string from given string.\n   * Extract hash between '?code=' and '#' if trailing '# is present.\n   * Returns empty string if no query symbol is found.\n   * @param queryString\n   */\n  static parseQueryServerResponse(queryString) {\n    const queryIndex1 = queryString.indexOf(\"?code\");\n    const queryIndex2 = queryString.indexOf(\"/?code\");\n    const hashIndex = queryString.indexOf(\"#\");\n    if (queryIndex2 > -1 && hashIndex > -1) {\n      return queryString.substring(queryIndex2 + 2, hashIndex);\n    } else if (queryIndex2 > -1) {\n      return queryString.substring(queryIndex2 + 2);\n    } else if (queryIndex1 > -1 && hashIndex > -1) {\n      return queryString.substring(queryIndex1 + 1, hashIndex);\n    } else if (queryIndex1 > -1) {\n      return queryString.substring(queryIndex1 + 1);\n    }\n    return Constants.EMPTY_STRING;\n  }\n  static constructAuthorityUriFromObject(urlObject) {\n    return new UrlString(urlObject.Protocol + \"//\" + urlObject.HostNameAndPort + \"/\" + urlObject.PathSegments.join(\"/\"));\n  }\n  /**\n   * Returns URL hash as server auth code response object.\n   */\n  static getDeserializedHash(hash) {\n    // Check if given hash is empty\n    if (!hash) {\n      return {};\n    }\n    // Strip the # symbol if present\n    const parsedHash = UrlString.parseHash(hash);\n    // If # symbol was not present, above will return empty string, so give original hash value\n    const deserializedHash = StringUtils.queryStringToObject(parsedHash || hash);\n    // Check if deserialization didn't work\n    if (!deserializedHash) {\n      throw ClientAuthError.createHashNotDeserializedError(JSON.stringify(deserializedHash));\n    }\n    return deserializedHash;\n  }\n  /**\n   * Returns URL query string as server auth code response object.\n   */\n  static getDeserializedQueryString(query) {\n    // Check if given query is empty\n    if (!query) {\n      return {};\n    }\n    // Strip the ? symbol if present\n    const parsedQueryString = UrlString.parseQueryString(query);\n    // If ? symbol was not present, above will return empty string, so give original query value\n    const deserializedQueryString = StringUtils.queryStringToObject(parsedQueryString || query);\n    // Check if deserialization didn't work\n    if (!deserializedQueryString) {\n      throw ClientAuthError.createHashNotDeserializedError(JSON.stringify(deserializedQueryString));\n    }\n    return deserializedQueryString;\n  }\n  /**\n   * Returns either deserialized query string or deserialized hash, depending on the serverResponseType\n   * as a server auth code response object.\n   */\n  static getDeserializedCodeResponse(serverResponseType, hashFragment) {\n    const hashUrlString = new UrlString(hashFragment);\n    let serverParams;\n    if (serverResponseType === ServerResponseType.QUERY) {\n      serverParams = UrlString.getDeserializedQueryString(hashFragment);\n    } else {\n      serverParams = UrlString.getDeserializedHash(hashUrlString.getHash());\n    }\n    return serverParams;\n  }\n  /**\n   * Check if the hash of the URL string contains known properties\n   */\n  static hashContainsKnownProperties(hash) {\n    if (!hash || hash.indexOf(\"=\") < 0) {\n      // Hash doesn't contain key/value pairs\n      return false;\n    }\n    const parameters = UrlString.getDeserializedHash(hash);\n    return !!(parameters.code || parameters.error_description || parameters.error || parameters.state);\n  }\n}\nexport { UrlString };","map":{"version":3,"names":["ClientConfigurationError","ClientAuthError","StringUtils","AADAuthorityConstants","Constants","ServerResponseType","UrlString","urlString","_urlString","constructor","url","createUrlEmptyError","getHash","canonicalizeUri","lowerCaseUrl","toLowerCase","endsWith","slice","validateAsUri","components","getUrlComponents","e","createUrlParseError","HostNameAndPort","PathSegments","Protocol","createInsecureAuthorityUriError","appendQueryString","queryString","indexOf","removeHashFromUrl","split","replaceTenantPath","tenantId","urlObject","pathArray","length","COMMON","ORGANIZATIONS","constructAuthorityUriFromObject","parseHash","regEx","RegExp","match","urlComponents","AbsolutePath","QueryString","pathSegments","filter","val","substring","getDomainFromUrl","getAbsoluteUrl","relativeUrl","baseUrl","FORWARD_SLASH","baseComponents","hashString","hashIndex1","hashIndex2","EMPTY_STRING","parseQueryString","queryIndex1","queryIndex2","parseQueryServerResponse","hashIndex","join","getDeserializedHash","hash","parsedHash","deserializedHash","queryStringToObject","createHashNotDeserializedError","JSON","stringify","getDeserializedQueryString","query","parsedQueryString","deserializedQueryString","getDeserializedCodeResponse","serverResponseType","hashFragment","hashUrlString","serverParams","QUERY","hashContainsKnownProperties","parameters","code","error_description","error","state"],"sources":["C:/Users/v-dkamali/Documents/AngularMSALAD/microsoft-login/node_modules/@azure/msal-common/dist/url/UrlString.mjs"],"sourcesContent":["/*! @azure/msal-common v14.0.3 2023-09-05 */\n'use strict';\nimport { ClientConfigurationError } from '../error/ClientConfigurationError.mjs';\nimport { ClientAuthError } from '../error/ClientAuthError.mjs';\nimport { StringUtils } from '../utils/StringUtils.mjs';\nimport { AADAuthorityConstants, Constants, ServerResponseType } from '../utils/Constants.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * Url object class which can perform various transformations on url strings.\n */\nclass UrlString {\n    get urlString() {\n        return this._urlString;\n    }\n    constructor(url) {\n        this._urlString = url;\n        if (!this._urlString) {\n            // Throws error if url is empty\n            throw ClientConfigurationError.createUrlEmptyError();\n        }\n        if (!this.getHash()) {\n            this._urlString = UrlString.canonicalizeUri(url);\n        }\n    }\n    /**\n     * Ensure urls are lower case and end with a / character.\n     * @param url\n     */\n    static canonicalizeUri(url) {\n        if (url) {\n            let lowerCaseUrl = url.toLowerCase();\n            if (StringUtils.endsWith(lowerCaseUrl, \"?\")) {\n                lowerCaseUrl = lowerCaseUrl.slice(0, -1);\n            }\n            else if (StringUtils.endsWith(lowerCaseUrl, \"?/\")) {\n                lowerCaseUrl = lowerCaseUrl.slice(0, -2);\n            }\n            if (!StringUtils.endsWith(lowerCaseUrl, \"/\")) {\n                lowerCaseUrl += \"/\";\n            }\n            return lowerCaseUrl;\n        }\n        return url;\n    }\n    /**\n     * Throws if urlString passed is not a valid authority URI string.\n     */\n    validateAsUri() {\n        // Attempts to parse url for uri components\n        let components;\n        try {\n            components = this.getUrlComponents();\n        }\n        catch (e) {\n            throw ClientConfigurationError.createUrlParseError(e);\n        }\n        // Throw error if URI or path segments are not parseable.\n        if (!components.HostNameAndPort || !components.PathSegments) {\n            throw ClientConfigurationError.createUrlParseError(`Given url string: ${this.urlString}`);\n        }\n        // Throw error if uri is insecure.\n        if (!components.Protocol ||\n            components.Protocol.toLowerCase() !== \"https:\") {\n            throw ClientConfigurationError.createInsecureAuthorityUriError(this.urlString);\n        }\n    }\n    /**\n     * Given a url and a query string return the url with provided query string appended\n     * @param url\n     * @param queryString\n     */\n    static appendQueryString(url, queryString) {\n        if (!queryString) {\n            return url;\n        }\n        return url.indexOf(\"?\") < 0\n            ? `${url}?${queryString}`\n            : `${url}&${queryString}`;\n    }\n    /**\n     * Returns a url with the hash removed\n     * @param url\n     */\n    static removeHashFromUrl(url) {\n        return UrlString.canonicalizeUri(url.split(\"#\")[0]);\n    }\n    /**\n     * Given a url like https://a:b/common/d?e=f#g, and a tenantId, returns https://a:b/tenantId/d\n     * @param href The url\n     * @param tenantId The tenant id to replace\n     */\n    replaceTenantPath(tenantId) {\n        const urlObject = this.getUrlComponents();\n        const pathArray = urlObject.PathSegments;\n        if (tenantId &&\n            pathArray.length !== 0 &&\n            (pathArray[0] === AADAuthorityConstants.COMMON ||\n                pathArray[0] === AADAuthorityConstants.ORGANIZATIONS)) {\n            pathArray[0] = tenantId;\n        }\n        return UrlString.constructAuthorityUriFromObject(urlObject);\n    }\n    /**\n     * Returns the anchor part(#) of the URL\n     */\n    getHash() {\n        return UrlString.parseHash(this.urlString);\n    }\n    /**\n     * Parses out the components from a url string.\n     * @returns An object with the various components. Please cache this value insted of calling this multiple times on the same url.\n     */\n    getUrlComponents() {\n        // https://gist.github.com/curtisz/11139b2cfcaef4a261e0\n        const regEx = RegExp(\"^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\\\?([^#]*))?(#(.*))?\");\n        // If url string does not match regEx, we throw an error\n        const match = this.urlString.match(regEx);\n        if (!match) {\n            throw ClientConfigurationError.createUrlParseError(`Given url string: ${this.urlString}`);\n        }\n        // Url component object\n        const urlComponents = {\n            Protocol: match[1],\n            HostNameAndPort: match[4],\n            AbsolutePath: match[5],\n            QueryString: match[7],\n        };\n        let pathSegments = urlComponents.AbsolutePath.split(\"/\");\n        pathSegments = pathSegments.filter((val) => val && val.length > 0); // remove empty elements\n        urlComponents.PathSegments = pathSegments;\n        if (urlComponents.QueryString &&\n            urlComponents.QueryString.endsWith(\"/\")) {\n            urlComponents.QueryString = urlComponents.QueryString.substring(0, urlComponents.QueryString.length - 1);\n        }\n        return urlComponents;\n    }\n    static getDomainFromUrl(url) {\n        const regEx = RegExp(\"^([^:/?#]+://)?([^/?#]*)\");\n        const match = url.match(regEx);\n        if (!match) {\n            throw ClientConfigurationError.createUrlParseError(`Given url string: ${url}`);\n        }\n        return match[2];\n    }\n    static getAbsoluteUrl(relativeUrl, baseUrl) {\n        if (relativeUrl[0] === Constants.FORWARD_SLASH) {\n            const url = new UrlString(baseUrl);\n            const baseComponents = url.getUrlComponents();\n            return (baseComponents.Protocol +\n                \"//\" +\n                baseComponents.HostNameAndPort +\n                relativeUrl);\n        }\n        return relativeUrl;\n    }\n    /**\n     * Parses hash string from given string. Returns empty string if no hash symbol is found.\n     * @param hashString\n     */\n    static parseHash(hashString) {\n        const hashIndex1 = hashString.indexOf(\"#\");\n        const hashIndex2 = hashString.indexOf(\"#/\");\n        if (hashIndex2 > -1) {\n            return hashString.substring(hashIndex2 + 2);\n        }\n        else if (hashIndex1 > -1) {\n            return hashString.substring(hashIndex1 + 1);\n        }\n        return Constants.EMPTY_STRING;\n    }\n    /**\n     * Parses query string from given string. Returns empty string if no query symbol is found.\n     * @param queryString\n     */\n    static parseQueryString(queryString) {\n        const queryIndex1 = queryString.indexOf(\"?\");\n        const queryIndex2 = queryString.indexOf(\"/?\");\n        if (queryIndex2 > -1) {\n            return queryString.substring(queryIndex2 + 2);\n        }\n        else if (queryIndex1 > -1) {\n            return queryString.substring(queryIndex1 + 1);\n        }\n        return Constants.EMPTY_STRING;\n    }\n    /**\n     * Parses query server response string from given string.\n     * Extract hash between '?code=' and '#' if trailing '# is present.\n     * Returns empty string if no query symbol is found.\n     * @param queryString\n     */\n    static parseQueryServerResponse(queryString) {\n        const queryIndex1 = queryString.indexOf(\"?code\");\n        const queryIndex2 = queryString.indexOf(\"/?code\");\n        const hashIndex = queryString.indexOf(\"#\");\n        if (queryIndex2 > -1 && hashIndex > -1) {\n            return queryString.substring(queryIndex2 + 2, hashIndex);\n        }\n        else if (queryIndex2 > -1) {\n            return queryString.substring(queryIndex2 + 2);\n        }\n        else if (queryIndex1 > -1 && hashIndex > -1) {\n            return queryString.substring(queryIndex1 + 1, hashIndex);\n        }\n        else if (queryIndex1 > -1) {\n            return queryString.substring(queryIndex1 + 1);\n        }\n        return Constants.EMPTY_STRING;\n    }\n    static constructAuthorityUriFromObject(urlObject) {\n        return new UrlString(urlObject.Protocol +\n            \"//\" +\n            urlObject.HostNameAndPort +\n            \"/\" +\n            urlObject.PathSegments.join(\"/\"));\n    }\n    /**\n     * Returns URL hash as server auth code response object.\n     */\n    static getDeserializedHash(hash) {\n        // Check if given hash is empty\n        if (!hash) {\n            return {};\n        }\n        // Strip the # symbol if present\n        const parsedHash = UrlString.parseHash(hash);\n        // If # symbol was not present, above will return empty string, so give original hash value\n        const deserializedHash = StringUtils.queryStringToObject(parsedHash || hash);\n        // Check if deserialization didn't work\n        if (!deserializedHash) {\n            throw ClientAuthError.createHashNotDeserializedError(JSON.stringify(deserializedHash));\n        }\n        return deserializedHash;\n    }\n    /**\n     * Returns URL query string as server auth code response object.\n     */\n    static getDeserializedQueryString(query) {\n        // Check if given query is empty\n        if (!query) {\n            return {};\n        }\n        // Strip the ? symbol if present\n        const parsedQueryString = UrlString.parseQueryString(query);\n        // If ? symbol was not present, above will return empty string, so give original query value\n        const deserializedQueryString = StringUtils.queryStringToObject(parsedQueryString || query);\n        // Check if deserialization didn't work\n        if (!deserializedQueryString) {\n            throw ClientAuthError.createHashNotDeserializedError(JSON.stringify(deserializedQueryString));\n        }\n        return deserializedQueryString;\n    }\n    /**\n     * Returns either deserialized query string or deserialized hash, depending on the serverResponseType\n     * as a server auth code response object.\n     */\n    static getDeserializedCodeResponse(serverResponseType, hashFragment) {\n        const hashUrlString = new UrlString(hashFragment);\n        let serverParams;\n        if (serverResponseType === ServerResponseType.QUERY) {\n            serverParams = UrlString.getDeserializedQueryString(hashFragment);\n        }\n        else {\n            serverParams = UrlString.getDeserializedHash(hashUrlString.getHash());\n        }\n        return serverParams;\n    }\n    /**\n     * Check if the hash of the URL string contains known properties\n     */\n    static hashContainsKnownProperties(hash) {\n        if (!hash || hash.indexOf(\"=\") < 0) {\n            // Hash doesn't contain key/value pairs\n            return false;\n        }\n        const parameters = UrlString.getDeserializedHash(hash);\n        return !!(parameters.code ||\n            parameters.error_description ||\n            parameters.error ||\n            parameters.state);\n    }\n}\n\nexport { UrlString };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}