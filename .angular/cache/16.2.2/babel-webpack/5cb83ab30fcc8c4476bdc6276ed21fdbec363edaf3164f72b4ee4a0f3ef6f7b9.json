{"ast":null,"code":"/*! @azure/msal-browser v3.1.0 2023-09-05 */\n'use strict';\n\nimport _asyncToGenerator from \"C:/Users/v-dkamali/Documents/AngularMSALAD/microsoft-login/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { OIDC_DEFAULT_SCOPES, PerformanceEvents, Constants, UrlString, ThrottlingUtils, ProtocolUtils, AuthError, ProtocolMode, ServerResponseType } from '@azure/msal-common';\nimport { StandardInteractionClient } from './StandardInteractionClient.mjs';\nimport { EventType } from '../event/EventType.mjs';\nimport { ApiId, InteractionType, BrowserConstants } from '../utils/BrowserConstants.mjs';\nimport { BrowserUtils } from '../utils/BrowserUtils.mjs';\nimport { NativeInteractionClient } from './NativeInteractionClient.mjs';\nimport { NativeMessageHandler } from '../broker/nativeBroker/NativeMessageHandler.mjs';\nimport { createBrowserAuthError } from '../error/BrowserAuthError.mjs';\nimport { InteractionHandler } from '../interaction_handler/InteractionHandler.mjs';\nimport { nativeConnectionNotEstablished, emptyNavigateUri, userCancelled, hashDoesNotContainKnownProperties, monitorPopupTimeout, emptyWindowError, popupWindowError } from '../error/BrowserAuthErrorCodes.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nclass PopupClient extends StandardInteractionClient {\n  constructor(config, storageImpl, browserCrypto, logger, eventHandler, navigationClient, performanceClient, nativeStorageImpl, nativeMessageHandler, correlationId) {\n    super(config, storageImpl, browserCrypto, logger, eventHandler, navigationClient, performanceClient, nativeMessageHandler, correlationId);\n    // Properly sets this reference for the unload event.\n    this.unloadWindow = this.unloadWindow.bind(this);\n    this.nativeStorage = nativeStorageImpl;\n  }\n  /**\n   * Acquires tokens by opening a popup window to the /authorize endpoint of the authority\n   * @param request\n   */\n  acquireToken(request) {\n    try {\n      const popupName = this.generatePopupName(request.scopes || OIDC_DEFAULT_SCOPES, request.authority || this.config.auth.authority);\n      const popupWindowAttributes = request.popupWindowAttributes || {};\n      // asyncPopups flag is true. Acquires token without first opening popup. Popup will be opened later asynchronously.\n      if (this.config.system.asyncPopups) {\n        this.logger.verbose(\"asyncPopups set to true, acquiring token\");\n        // Passes on popup position and dimensions if in request\n        return this.acquireTokenPopupAsync(request, popupName, popupWindowAttributes);\n      } else {\n        // asyncPopups flag is set to false. Opens popup before acquiring token.\n        this.logger.verbose(\"asyncPopup set to false, opening popup before acquiring token\");\n        const popup = this.openSizedPopup(\"about:blank\", popupName, popupWindowAttributes);\n        return this.acquireTokenPopupAsync(request, popupName, popupWindowAttributes, popup);\n      }\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }\n  /**\n   * Clears local cache for the current user then opens a popup window prompting the user to sign-out of the server\n   * @param logoutRequest\n   */\n  logout(logoutRequest) {\n    try {\n      this.logger.verbose(\"logoutPopup called\");\n      const validLogoutRequest = this.initializeLogoutRequest(logoutRequest);\n      const popupName = this.generateLogoutPopupName(validLogoutRequest);\n      const authority = logoutRequest && logoutRequest.authority;\n      const mainWindowRedirectUri = logoutRequest && logoutRequest.mainWindowRedirectUri;\n      const popupWindowAttributes = logoutRequest?.popupWindowAttributes || {};\n      // asyncPopups flag is true. Acquires token without first opening popup. Popup will be opened later asynchronously.\n      if (this.config.system.asyncPopups) {\n        this.logger.verbose(\"asyncPopups set to true\");\n        // Passes on popup position and dimensions if in request\n        return this.logoutPopupAsync(validLogoutRequest, popupName, popupWindowAttributes, authority, undefined, mainWindowRedirectUri);\n      } else {\n        // asyncPopups flag is set to false. Opens popup before logging out.\n        this.logger.verbose(\"asyncPopup set to false, opening popup\");\n        const popup = this.openSizedPopup(\"about:blank\", popupName, popupWindowAttributes);\n        return this.logoutPopupAsync(validLogoutRequest, popupName, popupWindowAttributes, authority, popup, mainWindowRedirectUri);\n      }\n    } catch (e) {\n      // Since this function is synchronous we need to reject\n      return Promise.reject(e);\n    }\n  }\n  /**\n   * Helper which obtains an access_token for your API via opening a popup window in the user's browser\n   * @param validRequest\n   * @param popupName\n   * @param popup\n   * @param popupWindowAttributes\n   *\n   * @returns A promise that is fulfilled when this function has completed, or rejected if an error was raised.\n   */\n  acquireTokenPopupAsync(request, popupName, popupWindowAttributes, popup) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      _this.logger.verbose(\"acquireTokenPopupAsync called\");\n      const serverTelemetryManager = _this.initializeServerTelemetryManager(ApiId.acquireTokenPopup);\n      _this.performanceClient.setPreQueueTime(PerformanceEvents.StandardInteractionClientInitializeAuthorizationRequest, request.correlationId);\n      const validRequest = yield _this.initializeAuthorizationRequest(request, InteractionType.Popup);\n      _this.browserStorage.updateCacheEntries(validRequest.state, validRequest.nonce, validRequest.authority, validRequest.loginHint || Constants.EMPTY_STRING, validRequest.account || null);\n      try {\n        // Create auth code request and generate PKCE params\n        _this.performanceClient.setPreQueueTime(PerformanceEvents.StandardInteractionClientInitializeAuthorizationCodeRequest, request.correlationId);\n        const authCodeRequest = yield _this.initializeAuthorizationCodeRequest(validRequest);\n        // Initialize the client\n        _this.performanceClient.setPreQueueTime(PerformanceEvents.StandardInteractionClientCreateAuthCodeClient, request.correlationId);\n        const authClient = yield _this.createAuthCodeClient(serverTelemetryManager, validRequest.authority, validRequest.azureCloudOptions);\n        _this.logger.verbose(\"Auth code client created\");\n        const isNativeBroker = NativeMessageHandler.isNativeAvailable(_this.config, _this.logger, _this.nativeMessageHandler, request.authenticationScheme);\n        // Start measurement for server calls with native brokering enabled\n        let fetchNativeAccountIdMeasurement;\n        if (isNativeBroker) {\n          fetchNativeAccountIdMeasurement = _this.performanceClient.startMeasurement(PerformanceEvents.FetchAccountIdWithNativeBroker, request.correlationId);\n        }\n        // Create acquire token url.\n        const navigateUrl = yield authClient.getAuthCodeUrl({\n          ...validRequest,\n          nativeBroker: isNativeBroker\n        });\n        // Create popup interaction handler.\n        const interactionHandler = new InteractionHandler(authClient, _this.browserStorage, authCodeRequest, _this.logger, _this.performanceClient);\n        // Show the UI once the url has been created. Get the window handle for the popup.\n        const popupParameters = {\n          popup,\n          popupName,\n          popupWindowAttributes\n        };\n        const popupWindow = _this.initiateAuthRequest(navigateUrl, popupParameters);\n        _this.eventHandler.emitEvent(EventType.POPUP_OPENED, InteractionType.Popup, {\n          popupWindow\n        }, null);\n        // Monitor the window for the hash. Return the string value and close the popup when the hash is received. Default timeout is 60 seconds.\n        const hash = yield _this.monitorPopupForHash(popupWindow);\n        // Deserialize hash fragment response parameters.\n        const serverParams = UrlString.getDeserializedHash(hash);\n        const state = _this.validateAndExtractStateFromHash(serverParams, InteractionType.Popup, validRequest.correlationId);\n        // Remove throttle if it exists\n        ThrottlingUtils.removeThrottle(_this.browserStorage, _this.config.auth.clientId, authCodeRequest);\n        if (serverParams.accountId) {\n          _this.logger.verbose(\"Account id found in hash, calling WAM for token\");\n          // end measurement for server call with native brokering enabled\n          if (fetchNativeAccountIdMeasurement) {\n            fetchNativeAccountIdMeasurement.end({\n              success: true,\n              isNativeBroker: true\n            });\n          }\n          if (!_this.nativeMessageHandler) {\n            throw createBrowserAuthError(nativeConnectionNotEstablished);\n          }\n          const nativeInteractionClient = new NativeInteractionClient(_this.config, _this.browserStorage, _this.browserCrypto, _this.logger, _this.eventHandler, _this.navigationClient, ApiId.acquireTokenPopup, _this.performanceClient, _this.nativeMessageHandler, serverParams.accountId, _this.nativeStorage, validRequest.correlationId);\n          const {\n            userRequestState\n          } = ProtocolUtils.parseRequestState(_this.browserCrypto, state);\n          return nativeInteractionClient.acquireToken({\n            ...validRequest,\n            state: userRequestState,\n            prompt: undefined // Server should handle the prompt, ideally native broker can do this part silently\n          }).finally(() => {\n            _this.browserStorage.cleanRequestByState(state);\n          });\n        }\n        // Handle response from hash string.\n        const result = yield interactionHandler.handleCodeResponseFromHash(hash, state, authClient.authority, _this.networkClient);\n        return result;\n      } catch (e) {\n        if (popup) {\n          // Close the synchronous popup if an error is thrown before the window unload event is registered\n          popup.close();\n        }\n        if (e instanceof AuthError) {\n          e.setCorrelationId(_this.correlationId);\n          serverTelemetryManager.cacheFailedRequest(e);\n        }\n        _this.browserStorage.cleanRequestByState(validRequest.state);\n        throw e;\n      }\n    })();\n  }\n  /**\n   *\n   * @param validRequest\n   * @param popupName\n   * @param requestAuthority\n   * @param popup\n   * @param mainWindowRedirectUri\n   * @param popupWindowAttributes\n   */\n  logoutPopupAsync(validRequest, popupName, popupWindowAttributes, requestAuthority, popup, mainWindowRedirectUri) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      _this2.logger.verbose(\"logoutPopupAsync called\");\n      _this2.eventHandler.emitEvent(EventType.LOGOUT_START, InteractionType.Popup, validRequest);\n      const serverTelemetryManager = _this2.initializeServerTelemetryManager(ApiId.logoutPopup);\n      try {\n        // Clear cache on logout\n        yield _this2.clearCacheOnLogout(validRequest.account);\n        // Initialize the client\n        _this2.performanceClient.setPreQueueTime(PerformanceEvents.StandardInteractionClientCreateAuthCodeClient, validRequest.correlationId);\n        const authClient = yield _this2.createAuthCodeClient(serverTelemetryManager, requestAuthority);\n        _this2.logger.verbose(\"Auth code client created\");\n        try {\n          authClient.authority.endSessionEndpoint;\n        } catch {\n          if (validRequest.account?.homeAccountId && validRequest.postLogoutRedirectUri && authClient.authority.protocolMode === ProtocolMode.OIDC) {\n            void _this2.browserStorage.removeAccount(validRequest.account?.homeAccountId);\n            _this2.eventHandler.emitEvent(EventType.LOGOUT_SUCCESS, InteractionType.Popup, validRequest);\n            if (mainWindowRedirectUri) {\n              const navigationOptions = {\n                apiId: ApiId.logoutPopup,\n                timeout: _this2.config.system.redirectNavigationTimeout,\n                noHistory: false\n              };\n              const absoluteUrl = UrlString.getAbsoluteUrl(mainWindowRedirectUri, BrowserUtils.getCurrentUri());\n              yield _this2.navigationClient.navigateInternal(absoluteUrl, navigationOptions);\n            }\n            if (popup) {\n              popup.close();\n            }\n            return;\n          }\n        }\n        // Create logout string and navigate user window to logout.\n        const logoutUri = authClient.getLogoutUri(validRequest);\n        _this2.eventHandler.emitEvent(EventType.LOGOUT_SUCCESS, InteractionType.Popup, validRequest);\n        // Open the popup window to requestUrl.\n        const popupWindow = _this2.openPopup(logoutUri, {\n          popupName,\n          popupWindowAttributes,\n          popup\n        });\n        _this2.eventHandler.emitEvent(EventType.POPUP_OPENED, InteractionType.Popup, {\n          popupWindow\n        }, null);\n        yield _this2.waitForLogoutPopup(popupWindow);\n        if (mainWindowRedirectUri) {\n          const navigationOptions = {\n            apiId: ApiId.logoutPopup,\n            timeout: _this2.config.system.redirectNavigationTimeout,\n            noHistory: false\n          };\n          const absoluteUrl = UrlString.getAbsoluteUrl(mainWindowRedirectUri, BrowserUtils.getCurrentUri());\n          _this2.logger.verbose(\"Redirecting main window to url specified in the request\");\n          _this2.logger.verbosePii(`Redirecting main window to: ${absoluteUrl}`);\n          yield _this2.navigationClient.navigateInternal(absoluteUrl, navigationOptions);\n        } else {\n          _this2.logger.verbose(\"No main window navigation requested\");\n        }\n      } catch (e) {\n        if (popup) {\n          // Close the synchronous popup if an error is thrown before the window unload event is registered\n          popup.close();\n        }\n        if (e instanceof AuthError) {\n          e.setCorrelationId(_this2.correlationId);\n          serverTelemetryManager.cacheFailedRequest(e);\n        }\n        _this2.browserStorage.setInteractionInProgress(false);\n        _this2.eventHandler.emitEvent(EventType.LOGOUT_FAILURE, InteractionType.Popup, null, e);\n        _this2.eventHandler.emitEvent(EventType.LOGOUT_END, InteractionType.Popup);\n        throw e;\n      }\n      _this2.eventHandler.emitEvent(EventType.LOGOUT_END, InteractionType.Popup);\n    })();\n  }\n  /**\n   * Opens a popup window with given request Url.\n   * @param requestUrl\n   */\n  initiateAuthRequest(requestUrl, params) {\n    // Check that request url is not empty.\n    if (requestUrl) {\n      this.logger.infoPii(`Navigate to: ${requestUrl}`);\n      // Open the popup window to requestUrl.\n      return this.openPopup(requestUrl, params);\n    } else {\n      // Throw error if request URL is empty.\n      this.logger.error(\"Navigate url is empty\");\n      throw createBrowserAuthError(emptyNavigateUri);\n    }\n  }\n  /**\n   * Monitors a window until it loads a url with the same origin.\n   * @param popupWindow - window that is being monitored\n   * @param timeout - timeout for processing hash once popup is redirected back to application\n   */\n  monitorPopupForHash(popupWindow) {\n    return new Promise((resolve, reject) => {\n      /*\n       * Polling for popups needs to be tick-based,\n       * since a non-trivial amount of time can be spent on interaction (which should not count against the timeout).\n       */\n      const maxTicks = this.config.system.windowHashTimeout / this.config.system.pollIntervalMilliseconds;\n      let ticks = 0;\n      this.logger.verbose(\"PopupHandler.monitorPopupForHash - polling started\");\n      const intervalId = setInterval(() => {\n        // Window is closed\n        if (popupWindow.closed) {\n          this.logger.error(\"PopupHandler.monitorPopupForHash - window closed\");\n          this.cleanPopup();\n          clearInterval(intervalId);\n          reject(createBrowserAuthError(userCancelled));\n          return;\n        }\n        let href = Constants.EMPTY_STRING;\n        let serverResponseString = Constants.EMPTY_STRING;\n        try {\n          /*\n           * Will throw if cross origin,\n           * which should be caught and ignored\n           * since we need the interval to keep running while on STS UI.\n           */\n          href = popupWindow.location.href;\n          serverResponseString = this.extractServerResponseStringFromPopup(popupWindow, href);\n        } catch (e) {}\n        // Don't process blank pages or cross domain\n        if (!href || href === \"about:blank\") {\n          return;\n        }\n        this.logger.verbose(\"PopupHandler.monitorPopupForHash - popup window is on same origin as caller\");\n        /*\n         * Only run clock when we are on same domain for popups\n         * as popup operations can take a long time.\n         */\n        ticks++;\n        if (serverResponseString) {\n          this.logger.verbose(\"PopupHandler.monitorPopupForHash - found hash in url\");\n          clearInterval(intervalId);\n          this.cleanPopup(popupWindow);\n          if (UrlString.hashContainsKnownProperties(serverResponseString)) {\n            this.logger.verbose(\"PopupHandler.monitorPopupForHash - hash contains known properties, returning.\");\n            resolve(serverResponseString);\n          } else {\n            this.logger.error(\"PopupHandler.monitorPopupForHash - found hash in url but it does not contain known properties. Check that your router is not changing the hash prematurely.\");\n            this.logger.errorPii(`PopupHandler.monitorPopupForHash - hash found: ${serverResponseString}`);\n            reject(createBrowserAuthError(hashDoesNotContainKnownProperties));\n          }\n        } else if (ticks > maxTicks) {\n          this.logger.error(\"PopupHandler.monitorPopupForHash - unable to find hash in url, timing out\");\n          clearInterval(intervalId);\n          reject(createBrowserAuthError(monitorPopupTimeout));\n        }\n      }, this.config.system.pollIntervalMilliseconds);\n    });\n  }\n  /**\n   * Waits for user interaction in logout popup window\n   * @param popupWindow\n   * @returns\n   */\n  waitForLogoutPopup(popupWindow) {\n    return new Promise(resolve => {\n      this.logger.verbose(\"PopupHandler.waitForLogoutPopup - polling started\");\n      const intervalId = setInterval(() => {\n        // Window is closed\n        if (popupWindow.closed) {\n          this.logger.error(\"PopupHandler.waitForLogoutPopup - window closed\");\n          this.cleanPopup();\n          clearInterval(intervalId);\n          resolve();\n        }\n        let href = Constants.EMPTY_STRING;\n        try {\n          /*\n           * Will throw if cross origin,\n           * which should be caught and ignored\n           * since we need the interval to keep running while on STS UI.\n           */\n          href = popupWindow.location.href;\n        } catch (e) {}\n        // Don't process blank pages or cross domain\n        if (!href || href === \"about:blank\") {\n          return;\n        }\n        this.logger.verbose(\"PopupHandler.waitForLogoutPopup - popup window is on same origin as caller, closing.\");\n        clearInterval(intervalId);\n        this.cleanPopup(popupWindow);\n        resolve();\n      }, this.config.system.pollIntervalMilliseconds);\n    });\n  }\n  /**\n   * @hidden\n   *\n   * Configures popup window for login.\n   *\n   * @param urlNavigate\n   * @param title\n   * @param popUpWidth\n   * @param popUpHeight\n   * @param popupWindowAttributes\n   * @ignore\n   * @hidden\n   */\n  openPopup(urlNavigate, popupParams) {\n    try {\n      let popupWindow;\n      // Popup window passed in, setting url to navigate to\n      if (popupParams.popup) {\n        popupWindow = popupParams.popup;\n        this.logger.verbosePii(`Navigating popup window to: ${urlNavigate}`);\n        popupWindow.location.assign(urlNavigate);\n      } else if (typeof popupParams.popup === \"undefined\") {\n        // Popup will be undefined if it was not passed in\n        this.logger.verbosePii(`Opening popup window to: ${urlNavigate}`);\n        popupWindow = this.openSizedPopup(urlNavigate, popupParams.popupName, popupParams.popupWindowAttributes);\n      }\n      // Popup will be null if popups are blocked\n      if (!popupWindow) {\n        throw createBrowserAuthError(emptyWindowError);\n      }\n      if (popupWindow.focus) {\n        popupWindow.focus();\n      }\n      this.currentWindow = popupWindow;\n      window.addEventListener(\"beforeunload\", this.unloadWindow);\n      return popupWindow;\n    } catch (e) {\n      this.logger.error(\"error opening popup \" + e.message);\n      this.browserStorage.setInteractionInProgress(false);\n      throw createBrowserAuthError(popupWindowError);\n    }\n  }\n  /**\n   * Helper function to set popup window dimensions and position\n   * @param urlNavigate\n   * @param popupName\n   * @param popupWindowAttributes\n   * @returns\n   */\n  openSizedPopup(urlNavigate, popupName, popupWindowAttributes) {\n    /**\n     * adding winLeft and winTop to account for dual monitor\n     * using screenLeft and screenTop for IE8 and earlier\n     */\n    const winLeft = window.screenLeft ? window.screenLeft : window.screenX;\n    const winTop = window.screenTop ? window.screenTop : window.screenY;\n    /**\n     * window.innerWidth displays browser window\"s height and width excluding toolbars\n     * using document.documentElement.clientWidth for IE8 and earlier\n     */\n    const winWidth = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;\n    const winHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;\n    let width = popupWindowAttributes.popupSize?.width;\n    let height = popupWindowAttributes.popupSize?.height;\n    let top = popupWindowAttributes.popupPosition?.top;\n    let left = popupWindowAttributes.popupPosition?.left;\n    if (!width || width < 0 || width > winWidth) {\n      this.logger.verbose(\"Default popup window width used. Window width not configured or invalid.\");\n      width = BrowserConstants.POPUP_WIDTH;\n    }\n    if (!height || height < 0 || height > winHeight) {\n      this.logger.verbose(\"Default popup window height used. Window height not configured or invalid.\");\n      height = BrowserConstants.POPUP_HEIGHT;\n    }\n    if (!top || top < 0 || top > winHeight) {\n      this.logger.verbose(\"Default popup window top position used. Window top not configured or invalid.\");\n      top = Math.max(0, winHeight / 2 - BrowserConstants.POPUP_HEIGHT / 2 + winTop);\n    }\n    if (!left || left < 0 || left > winWidth) {\n      this.logger.verbose(\"Default popup window left position used. Window left not configured or invalid.\");\n      left = Math.max(0, winWidth / 2 - BrowserConstants.POPUP_WIDTH / 2 + winLeft);\n    }\n    return window.open(urlNavigate, popupName, `width=${width}, height=${height}, top=${top}, left=${left}, scrollbars=yes`);\n  }\n  /**\n   * Event callback to unload main window.\n   */\n  unloadWindow(e) {\n    this.browserStorage.cleanRequestByInteractionType(InteractionType.Popup);\n    if (this.currentWindow) {\n      this.currentWindow.close();\n    }\n    // Guarantees browser unload will happen, so no other errors will be thrown.\n    e.preventDefault();\n  }\n  /**\n   * Closes popup, removes any state vars created during popup calls.\n   * @param popupWindow\n   */\n  cleanPopup(popupWindow) {\n    if (popupWindow) {\n      // Close window.\n      popupWindow.close();\n    }\n    // Remove window unload function\n    window.removeEventListener(\"beforeunload\", this.unloadWindow);\n    // Interaction is completed - remove interaction status.\n    this.browserStorage.setInteractionInProgress(false);\n  }\n  /**\n   * Generates the name for the popup based on the client id and request\n   * @param clientId\n   * @param request\n   */\n  generatePopupName(scopes, authority) {\n    return `${BrowserConstants.POPUP_NAME_PREFIX}.${this.config.auth.clientId}.${scopes.join(\"-\")}.${authority}.${this.correlationId}`;\n  }\n  /**\n   * Generates the name for the popup based on the client id and request for logouts\n   * @param clientId\n   * @param request\n   */\n  generateLogoutPopupName(request) {\n    const homeAccountId = request.account && request.account.homeAccountId;\n    return `${BrowserConstants.POPUP_NAME_PREFIX}.${this.config.auth.clientId}.${homeAccountId}.${this.correlationId}`;\n  }\n  /**\n   * Extracts the server response from the popup window\n   */\n  extractServerResponseStringFromPopup(popupWindow, href) {\n    let serverResponseString;\n    if (this.config.auth.OIDCOptions?.serverResponseType === ServerResponseType.QUERY) {\n      serverResponseString = UrlString.parseQueryServerResponse(href);\n    } else {\n      serverResponseString = popupWindow.location.hash;\n    }\n    return serverResponseString;\n  }\n}\nexport { PopupClient };","map":{"version":3,"names":["_asyncToGenerator","OIDC_DEFAULT_SCOPES","PerformanceEvents","Constants","UrlString","ThrottlingUtils","ProtocolUtils","AuthError","ProtocolMode","ServerResponseType","StandardInteractionClient","EventType","ApiId","InteractionType","BrowserConstants","BrowserUtils","NativeInteractionClient","NativeMessageHandler","createBrowserAuthError","InteractionHandler","nativeConnectionNotEstablished","emptyNavigateUri","userCancelled","hashDoesNotContainKnownProperties","monitorPopupTimeout","emptyWindowError","popupWindowError","PopupClient","constructor","config","storageImpl","browserCrypto","logger","eventHandler","navigationClient","performanceClient","nativeStorageImpl","nativeMessageHandler","correlationId","unloadWindow","bind","nativeStorage","acquireToken","request","popupName","generatePopupName","scopes","authority","auth","popupWindowAttributes","system","asyncPopups","verbose","acquireTokenPopupAsync","popup","openSizedPopup","e","Promise","reject","logout","logoutRequest","validLogoutRequest","initializeLogoutRequest","generateLogoutPopupName","mainWindowRedirectUri","logoutPopupAsync","undefined","_this","serverTelemetryManager","initializeServerTelemetryManager","acquireTokenPopup","setPreQueueTime","StandardInteractionClientInitializeAuthorizationRequest","validRequest","initializeAuthorizationRequest","Popup","browserStorage","updateCacheEntries","state","nonce","loginHint","EMPTY_STRING","account","StandardInteractionClientInitializeAuthorizationCodeRequest","authCodeRequest","initializeAuthorizationCodeRequest","StandardInteractionClientCreateAuthCodeClient","authClient","createAuthCodeClient","azureCloudOptions","isNativeBroker","isNativeAvailable","authenticationScheme","fetchNativeAccountIdMeasurement","startMeasurement","FetchAccountIdWithNativeBroker","navigateUrl","getAuthCodeUrl","nativeBroker","interactionHandler","popupParameters","popupWindow","initiateAuthRequest","emitEvent","POPUP_OPENED","hash","monitorPopupForHash","serverParams","getDeserializedHash","validateAndExtractStateFromHash","removeThrottle","clientId","accountId","end","success","nativeInteractionClient","userRequestState","parseRequestState","prompt","finally","cleanRequestByState","result","handleCodeResponseFromHash","networkClient","close","setCorrelationId","cacheFailedRequest","requestAuthority","_this2","LOGOUT_START","logoutPopup","clearCacheOnLogout","endSessionEndpoint","homeAccountId","postLogoutRedirectUri","protocolMode","OIDC","removeAccount","LOGOUT_SUCCESS","navigationOptions","apiId","timeout","redirectNavigationTimeout","noHistory","absoluteUrl","getAbsoluteUrl","getCurrentUri","navigateInternal","logoutUri","getLogoutUri","openPopup","waitForLogoutPopup","verbosePii","setInteractionInProgress","LOGOUT_FAILURE","LOGOUT_END","requestUrl","params","infoPii","error","resolve","maxTicks","windowHashTimeout","pollIntervalMilliseconds","ticks","intervalId","setInterval","closed","cleanPopup","clearInterval","href","serverResponseString","location","extractServerResponseStringFromPopup","hashContainsKnownProperties","errorPii","urlNavigate","popupParams","assign","focus","currentWindow","window","addEventListener","message","winLeft","screenLeft","screenX","winTop","screenTop","screenY","winWidth","innerWidth","document","documentElement","clientWidth","body","winHeight","innerHeight","clientHeight","width","popupSize","height","top","popupPosition","left","POPUP_WIDTH","POPUP_HEIGHT","Math","max","open","cleanRequestByInteractionType","preventDefault","removeEventListener","POPUP_NAME_PREFIX","join","OIDCOptions","serverResponseType","QUERY","parseQueryServerResponse"],"sources":["C:/Users/v-dkamali/Documents/AngularMSALAD/microsoft-login/node_modules/@azure/msal-browser/dist/interaction_client/PopupClient.mjs"],"sourcesContent":["/*! @azure/msal-browser v3.1.0 2023-09-05 */\n'use strict';\nimport { OIDC_DEFAULT_SCOPES, PerformanceEvents, Constants, UrlString, ThrottlingUtils, ProtocolUtils, AuthError, ProtocolMode, ServerResponseType } from '@azure/msal-common';\nimport { StandardInteractionClient } from './StandardInteractionClient.mjs';\nimport { EventType } from '../event/EventType.mjs';\nimport { ApiId, InteractionType, BrowserConstants } from '../utils/BrowserConstants.mjs';\nimport { BrowserUtils } from '../utils/BrowserUtils.mjs';\nimport { NativeInteractionClient } from './NativeInteractionClient.mjs';\nimport { NativeMessageHandler } from '../broker/nativeBroker/NativeMessageHandler.mjs';\nimport { createBrowserAuthError } from '../error/BrowserAuthError.mjs';\nimport { InteractionHandler } from '../interaction_handler/InteractionHandler.mjs';\nimport { nativeConnectionNotEstablished, emptyNavigateUri, userCancelled, hashDoesNotContainKnownProperties, monitorPopupTimeout, emptyWindowError, popupWindowError } from '../error/BrowserAuthErrorCodes.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nclass PopupClient extends StandardInteractionClient {\n    constructor(config, storageImpl, browserCrypto, logger, eventHandler, navigationClient, performanceClient, nativeStorageImpl, nativeMessageHandler, correlationId) {\n        super(config, storageImpl, browserCrypto, logger, eventHandler, navigationClient, performanceClient, nativeMessageHandler, correlationId);\n        // Properly sets this reference for the unload event.\n        this.unloadWindow = this.unloadWindow.bind(this);\n        this.nativeStorage = nativeStorageImpl;\n    }\n    /**\n     * Acquires tokens by opening a popup window to the /authorize endpoint of the authority\n     * @param request\n     */\n    acquireToken(request) {\n        try {\n            const popupName = this.generatePopupName(request.scopes || OIDC_DEFAULT_SCOPES, request.authority || this.config.auth.authority);\n            const popupWindowAttributes = request.popupWindowAttributes || {};\n            // asyncPopups flag is true. Acquires token without first opening popup. Popup will be opened later asynchronously.\n            if (this.config.system.asyncPopups) {\n                this.logger.verbose(\"asyncPopups set to true, acquiring token\");\n                // Passes on popup position and dimensions if in request\n                return this.acquireTokenPopupAsync(request, popupName, popupWindowAttributes);\n            }\n            else {\n                // asyncPopups flag is set to false. Opens popup before acquiring token.\n                this.logger.verbose(\"asyncPopup set to false, opening popup before acquiring token\");\n                const popup = this.openSizedPopup(\"about:blank\", popupName, popupWindowAttributes);\n                return this.acquireTokenPopupAsync(request, popupName, popupWindowAttributes, popup);\n            }\n        }\n        catch (e) {\n            return Promise.reject(e);\n        }\n    }\n    /**\n     * Clears local cache for the current user then opens a popup window prompting the user to sign-out of the server\n     * @param logoutRequest\n     */\n    logout(logoutRequest) {\n        try {\n            this.logger.verbose(\"logoutPopup called\");\n            const validLogoutRequest = this.initializeLogoutRequest(logoutRequest);\n            const popupName = this.generateLogoutPopupName(validLogoutRequest);\n            const authority = logoutRequest && logoutRequest.authority;\n            const mainWindowRedirectUri = logoutRequest && logoutRequest.mainWindowRedirectUri;\n            const popupWindowAttributes = logoutRequest?.popupWindowAttributes || {};\n            // asyncPopups flag is true. Acquires token without first opening popup. Popup will be opened later asynchronously.\n            if (this.config.system.asyncPopups) {\n                this.logger.verbose(\"asyncPopups set to true\");\n                // Passes on popup position and dimensions if in request\n                return this.logoutPopupAsync(validLogoutRequest, popupName, popupWindowAttributes, authority, undefined, mainWindowRedirectUri);\n            }\n            else {\n                // asyncPopups flag is set to false. Opens popup before logging out.\n                this.logger.verbose(\"asyncPopup set to false, opening popup\");\n                const popup = this.openSizedPopup(\"about:blank\", popupName, popupWindowAttributes);\n                return this.logoutPopupAsync(validLogoutRequest, popupName, popupWindowAttributes, authority, popup, mainWindowRedirectUri);\n            }\n        }\n        catch (e) {\n            // Since this function is synchronous we need to reject\n            return Promise.reject(e);\n        }\n    }\n    /**\n     * Helper which obtains an access_token for your API via opening a popup window in the user's browser\n     * @param validRequest\n     * @param popupName\n     * @param popup\n     * @param popupWindowAttributes\n     *\n     * @returns A promise that is fulfilled when this function has completed, or rejected if an error was raised.\n     */\n    async acquireTokenPopupAsync(request, popupName, popupWindowAttributes, popup) {\n        this.logger.verbose(\"acquireTokenPopupAsync called\");\n        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenPopup);\n        this.performanceClient.setPreQueueTime(PerformanceEvents.StandardInteractionClientInitializeAuthorizationRequest, request.correlationId);\n        const validRequest = await this.initializeAuthorizationRequest(request, InteractionType.Popup);\n        this.browserStorage.updateCacheEntries(validRequest.state, validRequest.nonce, validRequest.authority, validRequest.loginHint || Constants.EMPTY_STRING, validRequest.account || null);\n        try {\n            // Create auth code request and generate PKCE params\n            this.performanceClient.setPreQueueTime(PerformanceEvents.StandardInteractionClientInitializeAuthorizationCodeRequest, request.correlationId);\n            const authCodeRequest = await this.initializeAuthorizationCodeRequest(validRequest);\n            // Initialize the client\n            this.performanceClient.setPreQueueTime(PerformanceEvents.StandardInteractionClientCreateAuthCodeClient, request.correlationId);\n            const authClient = await this.createAuthCodeClient(serverTelemetryManager, validRequest.authority, validRequest.azureCloudOptions);\n            this.logger.verbose(\"Auth code client created\");\n            const isNativeBroker = NativeMessageHandler.isNativeAvailable(this.config, this.logger, this.nativeMessageHandler, request.authenticationScheme);\n            // Start measurement for server calls with native brokering enabled\n            let fetchNativeAccountIdMeasurement;\n            if (isNativeBroker) {\n                fetchNativeAccountIdMeasurement =\n                    this.performanceClient.startMeasurement(PerformanceEvents.FetchAccountIdWithNativeBroker, request.correlationId);\n            }\n            // Create acquire token url.\n            const navigateUrl = await authClient.getAuthCodeUrl({\n                ...validRequest,\n                nativeBroker: isNativeBroker,\n            });\n            // Create popup interaction handler.\n            const interactionHandler = new InteractionHandler(authClient, this.browserStorage, authCodeRequest, this.logger, this.performanceClient);\n            // Show the UI once the url has been created. Get the window handle for the popup.\n            const popupParameters = {\n                popup,\n                popupName,\n                popupWindowAttributes,\n            };\n            const popupWindow = this.initiateAuthRequest(navigateUrl, popupParameters);\n            this.eventHandler.emitEvent(EventType.POPUP_OPENED, InteractionType.Popup, { popupWindow }, null);\n            // Monitor the window for the hash. Return the string value and close the popup when the hash is received. Default timeout is 60 seconds.\n            const hash = await this.monitorPopupForHash(popupWindow);\n            // Deserialize hash fragment response parameters.\n            const serverParams = UrlString.getDeserializedHash(hash);\n            const state = this.validateAndExtractStateFromHash(serverParams, InteractionType.Popup, validRequest.correlationId);\n            // Remove throttle if it exists\n            ThrottlingUtils.removeThrottle(this.browserStorage, this.config.auth.clientId, authCodeRequest);\n            if (serverParams.accountId) {\n                this.logger.verbose(\"Account id found in hash, calling WAM for token\");\n                // end measurement for server call with native brokering enabled\n                if (fetchNativeAccountIdMeasurement) {\n                    fetchNativeAccountIdMeasurement.end({\n                        success: true,\n                        isNativeBroker: true,\n                    });\n                }\n                if (!this.nativeMessageHandler) {\n                    throw createBrowserAuthError(nativeConnectionNotEstablished);\n                }\n                const nativeInteractionClient = new NativeInteractionClient(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, ApiId.acquireTokenPopup, this.performanceClient, this.nativeMessageHandler, serverParams.accountId, this.nativeStorage, validRequest.correlationId);\n                const { userRequestState } = ProtocolUtils.parseRequestState(this.browserCrypto, state);\n                return nativeInteractionClient\n                    .acquireToken({\n                    ...validRequest,\n                    state: userRequestState,\n                    prompt: undefined, // Server should handle the prompt, ideally native broker can do this part silently\n                })\n                    .finally(() => {\n                    this.browserStorage.cleanRequestByState(state);\n                });\n            }\n            // Handle response from hash string.\n            const result = await interactionHandler.handleCodeResponseFromHash(hash, state, authClient.authority, this.networkClient);\n            return result;\n        }\n        catch (e) {\n            if (popup) {\n                // Close the synchronous popup if an error is thrown before the window unload event is registered\n                popup.close();\n            }\n            if (e instanceof AuthError) {\n                e.setCorrelationId(this.correlationId);\n                serverTelemetryManager.cacheFailedRequest(e);\n            }\n            this.browserStorage.cleanRequestByState(validRequest.state);\n            throw e;\n        }\n    }\n    /**\n     *\n     * @param validRequest\n     * @param popupName\n     * @param requestAuthority\n     * @param popup\n     * @param mainWindowRedirectUri\n     * @param popupWindowAttributes\n     */\n    async logoutPopupAsync(validRequest, popupName, popupWindowAttributes, requestAuthority, popup, mainWindowRedirectUri) {\n        this.logger.verbose(\"logoutPopupAsync called\");\n        this.eventHandler.emitEvent(EventType.LOGOUT_START, InteractionType.Popup, validRequest);\n        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.logoutPopup);\n        try {\n            // Clear cache on logout\n            await this.clearCacheOnLogout(validRequest.account);\n            // Initialize the client\n            this.performanceClient.setPreQueueTime(PerformanceEvents.StandardInteractionClientCreateAuthCodeClient, validRequest.correlationId);\n            const authClient = await this.createAuthCodeClient(serverTelemetryManager, requestAuthority);\n            this.logger.verbose(\"Auth code client created\");\n            try {\n                authClient.authority.endSessionEndpoint;\n            }\n            catch {\n                if (validRequest.account?.homeAccountId &&\n                    validRequest.postLogoutRedirectUri &&\n                    authClient.authority.protocolMode === ProtocolMode.OIDC) {\n                    void this.browserStorage.removeAccount(validRequest.account?.homeAccountId);\n                    this.eventHandler.emitEvent(EventType.LOGOUT_SUCCESS, InteractionType.Popup, validRequest);\n                    if (mainWindowRedirectUri) {\n                        const navigationOptions = {\n                            apiId: ApiId.logoutPopup,\n                            timeout: this.config.system.redirectNavigationTimeout,\n                            noHistory: false,\n                        };\n                        const absoluteUrl = UrlString.getAbsoluteUrl(mainWindowRedirectUri, BrowserUtils.getCurrentUri());\n                        await this.navigationClient.navigateInternal(absoluteUrl, navigationOptions);\n                    }\n                    if (popup) {\n                        popup.close();\n                    }\n                    return;\n                }\n            }\n            // Create logout string and navigate user window to logout.\n            const logoutUri = authClient.getLogoutUri(validRequest);\n            this.eventHandler.emitEvent(EventType.LOGOUT_SUCCESS, InteractionType.Popup, validRequest);\n            // Open the popup window to requestUrl.\n            const popupWindow = this.openPopup(logoutUri, {\n                popupName,\n                popupWindowAttributes,\n                popup,\n            });\n            this.eventHandler.emitEvent(EventType.POPUP_OPENED, InteractionType.Popup, { popupWindow }, null);\n            await this.waitForLogoutPopup(popupWindow);\n            if (mainWindowRedirectUri) {\n                const navigationOptions = {\n                    apiId: ApiId.logoutPopup,\n                    timeout: this.config.system.redirectNavigationTimeout,\n                    noHistory: false,\n                };\n                const absoluteUrl = UrlString.getAbsoluteUrl(mainWindowRedirectUri, BrowserUtils.getCurrentUri());\n                this.logger.verbose(\"Redirecting main window to url specified in the request\");\n                this.logger.verbosePii(`Redirecting main window to: ${absoluteUrl}`);\n                await this.navigationClient.navigateInternal(absoluteUrl, navigationOptions);\n            }\n            else {\n                this.logger.verbose(\"No main window navigation requested\");\n            }\n        }\n        catch (e) {\n            if (popup) {\n                // Close the synchronous popup if an error is thrown before the window unload event is registered\n                popup.close();\n            }\n            if (e instanceof AuthError) {\n                e.setCorrelationId(this.correlationId);\n                serverTelemetryManager.cacheFailedRequest(e);\n            }\n            this.browserStorage.setInteractionInProgress(false);\n            this.eventHandler.emitEvent(EventType.LOGOUT_FAILURE, InteractionType.Popup, null, e);\n            this.eventHandler.emitEvent(EventType.LOGOUT_END, InteractionType.Popup);\n            throw e;\n        }\n        this.eventHandler.emitEvent(EventType.LOGOUT_END, InteractionType.Popup);\n    }\n    /**\n     * Opens a popup window with given request Url.\n     * @param requestUrl\n     */\n    initiateAuthRequest(requestUrl, params) {\n        // Check that request url is not empty.\n        if (requestUrl) {\n            this.logger.infoPii(`Navigate to: ${requestUrl}`);\n            // Open the popup window to requestUrl.\n            return this.openPopup(requestUrl, params);\n        }\n        else {\n            // Throw error if request URL is empty.\n            this.logger.error(\"Navigate url is empty\");\n            throw createBrowserAuthError(emptyNavigateUri);\n        }\n    }\n    /**\n     * Monitors a window until it loads a url with the same origin.\n     * @param popupWindow - window that is being monitored\n     * @param timeout - timeout for processing hash once popup is redirected back to application\n     */\n    monitorPopupForHash(popupWindow) {\n        return new Promise((resolve, reject) => {\n            /*\n             * Polling for popups needs to be tick-based,\n             * since a non-trivial amount of time can be spent on interaction (which should not count against the timeout).\n             */\n            const maxTicks = this.config.system.windowHashTimeout /\n                this.config.system.pollIntervalMilliseconds;\n            let ticks = 0;\n            this.logger.verbose(\"PopupHandler.monitorPopupForHash - polling started\");\n            const intervalId = setInterval(() => {\n                // Window is closed\n                if (popupWindow.closed) {\n                    this.logger.error(\"PopupHandler.monitorPopupForHash - window closed\");\n                    this.cleanPopup();\n                    clearInterval(intervalId);\n                    reject(createBrowserAuthError(userCancelled));\n                    return;\n                }\n                let href = Constants.EMPTY_STRING;\n                let serverResponseString = Constants.EMPTY_STRING;\n                try {\n                    /*\n                     * Will throw if cross origin,\n                     * which should be caught and ignored\n                     * since we need the interval to keep running while on STS UI.\n                     */\n                    href = popupWindow.location.href;\n                    serverResponseString =\n                        this.extractServerResponseStringFromPopup(popupWindow, href);\n                }\n                catch (e) { }\n                // Don't process blank pages or cross domain\n                if (!href || href === \"about:blank\") {\n                    return;\n                }\n                this.logger.verbose(\"PopupHandler.monitorPopupForHash - popup window is on same origin as caller\");\n                /*\n                 * Only run clock when we are on same domain for popups\n                 * as popup operations can take a long time.\n                 */\n                ticks++;\n                if (serverResponseString) {\n                    this.logger.verbose(\"PopupHandler.monitorPopupForHash - found hash in url\");\n                    clearInterval(intervalId);\n                    this.cleanPopup(popupWindow);\n                    if (UrlString.hashContainsKnownProperties(serverResponseString)) {\n                        this.logger.verbose(\"PopupHandler.monitorPopupForHash - hash contains known properties, returning.\");\n                        resolve(serverResponseString);\n                    }\n                    else {\n                        this.logger.error(\"PopupHandler.monitorPopupForHash - found hash in url but it does not contain known properties. Check that your router is not changing the hash prematurely.\");\n                        this.logger.errorPii(`PopupHandler.monitorPopupForHash - hash found: ${serverResponseString}`);\n                        reject(createBrowserAuthError(hashDoesNotContainKnownProperties));\n                    }\n                }\n                else if (ticks > maxTicks) {\n                    this.logger.error(\"PopupHandler.monitorPopupForHash - unable to find hash in url, timing out\");\n                    clearInterval(intervalId);\n                    reject(createBrowserAuthError(monitorPopupTimeout));\n                }\n            }, this.config.system.pollIntervalMilliseconds);\n        });\n    }\n    /**\n     * Waits for user interaction in logout popup window\n     * @param popupWindow\n     * @returns\n     */\n    waitForLogoutPopup(popupWindow) {\n        return new Promise((resolve) => {\n            this.logger.verbose(\"PopupHandler.waitForLogoutPopup - polling started\");\n            const intervalId = setInterval(() => {\n                // Window is closed\n                if (popupWindow.closed) {\n                    this.logger.error(\"PopupHandler.waitForLogoutPopup - window closed\");\n                    this.cleanPopup();\n                    clearInterval(intervalId);\n                    resolve();\n                }\n                let href = Constants.EMPTY_STRING;\n                try {\n                    /*\n                     * Will throw if cross origin,\n                     * which should be caught and ignored\n                     * since we need the interval to keep running while on STS UI.\n                     */\n                    href = popupWindow.location.href;\n                }\n                catch (e) { }\n                // Don't process blank pages or cross domain\n                if (!href || href === \"about:blank\") {\n                    return;\n                }\n                this.logger.verbose(\"PopupHandler.waitForLogoutPopup - popup window is on same origin as caller, closing.\");\n                clearInterval(intervalId);\n                this.cleanPopup(popupWindow);\n                resolve();\n            }, this.config.system.pollIntervalMilliseconds);\n        });\n    }\n    /**\n     * @hidden\n     *\n     * Configures popup window for login.\n     *\n     * @param urlNavigate\n     * @param title\n     * @param popUpWidth\n     * @param popUpHeight\n     * @param popupWindowAttributes\n     * @ignore\n     * @hidden\n     */\n    openPopup(urlNavigate, popupParams) {\n        try {\n            let popupWindow;\n            // Popup window passed in, setting url to navigate to\n            if (popupParams.popup) {\n                popupWindow = popupParams.popup;\n                this.logger.verbosePii(`Navigating popup window to: ${urlNavigate}`);\n                popupWindow.location.assign(urlNavigate);\n            }\n            else if (typeof popupParams.popup === \"undefined\") {\n                // Popup will be undefined if it was not passed in\n                this.logger.verbosePii(`Opening popup window to: ${urlNavigate}`);\n                popupWindow = this.openSizedPopup(urlNavigate, popupParams.popupName, popupParams.popupWindowAttributes);\n            }\n            // Popup will be null if popups are blocked\n            if (!popupWindow) {\n                throw createBrowserAuthError(emptyWindowError);\n            }\n            if (popupWindow.focus) {\n                popupWindow.focus();\n            }\n            this.currentWindow = popupWindow;\n            window.addEventListener(\"beforeunload\", this.unloadWindow);\n            return popupWindow;\n        }\n        catch (e) {\n            this.logger.error(\"error opening popup \" + e.message);\n            this.browserStorage.setInteractionInProgress(false);\n            throw createBrowserAuthError(popupWindowError);\n        }\n    }\n    /**\n     * Helper function to set popup window dimensions and position\n     * @param urlNavigate\n     * @param popupName\n     * @param popupWindowAttributes\n     * @returns\n     */\n    openSizedPopup(urlNavigate, popupName, popupWindowAttributes) {\n        /**\n         * adding winLeft and winTop to account for dual monitor\n         * using screenLeft and screenTop for IE8 and earlier\n         */\n        const winLeft = window.screenLeft ? window.screenLeft : window.screenX;\n        const winTop = window.screenTop ? window.screenTop : window.screenY;\n        /**\n         * window.innerWidth displays browser window\"s height and width excluding toolbars\n         * using document.documentElement.clientWidth for IE8 and earlier\n         */\n        const winWidth = window.innerWidth ||\n            document.documentElement.clientWidth ||\n            document.body.clientWidth;\n        const winHeight = window.innerHeight ||\n            document.documentElement.clientHeight ||\n            document.body.clientHeight;\n        let width = popupWindowAttributes.popupSize?.width;\n        let height = popupWindowAttributes.popupSize?.height;\n        let top = popupWindowAttributes.popupPosition?.top;\n        let left = popupWindowAttributes.popupPosition?.left;\n        if (!width || width < 0 || width > winWidth) {\n            this.logger.verbose(\"Default popup window width used. Window width not configured or invalid.\");\n            width = BrowserConstants.POPUP_WIDTH;\n        }\n        if (!height || height < 0 || height > winHeight) {\n            this.logger.verbose(\"Default popup window height used. Window height not configured or invalid.\");\n            height = BrowserConstants.POPUP_HEIGHT;\n        }\n        if (!top || top < 0 || top > winHeight) {\n            this.logger.verbose(\"Default popup window top position used. Window top not configured or invalid.\");\n            top = Math.max(0, winHeight / 2 - BrowserConstants.POPUP_HEIGHT / 2 + winTop);\n        }\n        if (!left || left < 0 || left > winWidth) {\n            this.logger.verbose(\"Default popup window left position used. Window left not configured or invalid.\");\n            left = Math.max(0, winWidth / 2 - BrowserConstants.POPUP_WIDTH / 2 + winLeft);\n        }\n        return window.open(urlNavigate, popupName, `width=${width}, height=${height}, top=${top}, left=${left}, scrollbars=yes`);\n    }\n    /**\n     * Event callback to unload main window.\n     */\n    unloadWindow(e) {\n        this.browserStorage.cleanRequestByInteractionType(InteractionType.Popup);\n        if (this.currentWindow) {\n            this.currentWindow.close();\n        }\n        // Guarantees browser unload will happen, so no other errors will be thrown.\n        e.preventDefault();\n    }\n    /**\n     * Closes popup, removes any state vars created during popup calls.\n     * @param popupWindow\n     */\n    cleanPopup(popupWindow) {\n        if (popupWindow) {\n            // Close window.\n            popupWindow.close();\n        }\n        // Remove window unload function\n        window.removeEventListener(\"beforeunload\", this.unloadWindow);\n        // Interaction is completed - remove interaction status.\n        this.browserStorage.setInteractionInProgress(false);\n    }\n    /**\n     * Generates the name for the popup based on the client id and request\n     * @param clientId\n     * @param request\n     */\n    generatePopupName(scopes, authority) {\n        return `${BrowserConstants.POPUP_NAME_PREFIX}.${this.config.auth.clientId}.${scopes.join(\"-\")}.${authority}.${this.correlationId}`;\n    }\n    /**\n     * Generates the name for the popup based on the client id and request for logouts\n     * @param clientId\n     * @param request\n     */\n    generateLogoutPopupName(request) {\n        const homeAccountId = request.account && request.account.homeAccountId;\n        return `${BrowserConstants.POPUP_NAME_PREFIX}.${this.config.auth.clientId}.${homeAccountId}.${this.correlationId}`;\n    }\n    /**\n     * Extracts the server response from the popup window\n     */\n    extractServerResponseStringFromPopup(popupWindow, href) {\n        let serverResponseString;\n        if (this.config.auth.OIDCOptions?.serverResponseType ===\n            ServerResponseType.QUERY) {\n            serverResponseString = UrlString.parseQueryServerResponse(href);\n        }\n        else {\n            serverResponseString = popupWindow.location.hash;\n        }\n        return serverResponseString;\n    }\n}\n\nexport { PopupClient };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}