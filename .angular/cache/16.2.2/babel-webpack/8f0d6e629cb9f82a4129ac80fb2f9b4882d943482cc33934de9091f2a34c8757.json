{"ast":null,"code":"/*! @azure/msal-common v14.0.3 2023-09-05 */\n'use strict';\n\nimport _asyncToGenerator from \"C:/Users/v-dkamali/Documents/AngularMSALAD/microsoft-login/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { buildClientInfo } from '../account/ClientInfo.mjs';\nimport { ClientAuthError } from '../error/ClientAuthError.mjs';\nimport { ServerError } from '../error/ServerError.mjs';\nimport { ScopeSet } from '../request/ScopeSet.mjs';\nimport { AccountEntity } from '../cache/entities/AccountEntity.mjs';\nimport { IdTokenEntity } from '../cache/entities/IdTokenEntity.mjs';\nimport { AccessTokenEntity } from '../cache/entities/AccessTokenEntity.mjs';\nimport { RefreshTokenEntity } from '../cache/entities/RefreshTokenEntity.mjs';\nimport { InteractionRequiredAuthError } from '../error/InteractionRequiredAuthError.mjs';\nimport { CacheRecord } from '../cache/entities/CacheRecord.mjs';\nimport { ProtocolUtils } from '../utils/ProtocolUtils.mjs';\nimport { Constants, HttpStatus, AuthenticationScheme, THE_FAMILY_ID } from '../utils/Constants.mjs';\nimport { PopTokenGenerator } from '../crypto/PopTokenGenerator.mjs';\nimport { AppMetadataEntity } from '../cache/entities/AppMetadataEntity.mjs';\nimport { TokenCacheContext } from '../cache/persistence/TokenCacheContext.mjs';\nimport { PerformanceEvents } from '../telemetry/performance/PerformanceEvent.mjs';\nimport { extractTokenClaims, checkMaxAge } from '../account/AuthToken.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * Class that handles response parsing.\n * @internal\n */\nclass ResponseHandler {\n  constructor(clientId, cacheStorage, cryptoObj, logger, serializableCache, persistencePlugin, performanceClient) {\n    this.clientId = clientId;\n    this.cacheStorage = cacheStorage;\n    this.cryptoObj = cryptoObj;\n    this.logger = logger;\n    this.serializableCache = serializableCache;\n    this.persistencePlugin = persistencePlugin;\n    this.performanceClient = performanceClient;\n  }\n  /**\n   * Function which validates server authorization code response.\n   * @param serverResponseHash\n   * @param cachedState\n   * @param cryptoObj\n   */\n  validateServerAuthorizationCodeResponse(serverResponseHash, cachedState, cryptoObj) {\n    if (!serverResponseHash.state || !cachedState) {\n      throw serverResponseHash.state ? ClientAuthError.createStateNotFoundError(\"Cached State\") : ClientAuthError.createStateNotFoundError(\"Server State\");\n    }\n    let decodedServerResponseHash;\n    let decodedCachedState;\n    try {\n      decodedServerResponseHash = decodeURIComponent(serverResponseHash.state);\n    } catch (e) {\n      throw ClientAuthError.createInvalidStateError(serverResponseHash.state, `Server response hash URI could not be decoded`);\n    }\n    try {\n      decodedCachedState = decodeURIComponent(cachedState);\n    } catch (e) {\n      throw ClientAuthError.createInvalidStateError(serverResponseHash.state, `Cached state URI could not be decoded`);\n    }\n    if (decodedServerResponseHash !== decodedCachedState) {\n      throw ClientAuthError.createStateMismatchError();\n    }\n    // Check for error\n    if (serverResponseHash.error || serverResponseHash.error_description || serverResponseHash.suberror) {\n      if (InteractionRequiredAuthError.isInteractionRequiredError(serverResponseHash.error, serverResponseHash.error_description, serverResponseHash.suberror)) {\n        throw new InteractionRequiredAuthError(serverResponseHash.error || Constants.EMPTY_STRING, serverResponseHash.error_description, serverResponseHash.suberror, serverResponseHash.timestamp || Constants.EMPTY_STRING, serverResponseHash.trace_id || Constants.EMPTY_STRING, serverResponseHash.correlation_id || Constants.EMPTY_STRING, serverResponseHash.claims || Constants.EMPTY_STRING);\n      }\n      throw new ServerError(serverResponseHash.error || Constants.EMPTY_STRING, serverResponseHash.error_description, serverResponseHash.suberror);\n    }\n    if (serverResponseHash.client_info) {\n      buildClientInfo(serverResponseHash.client_info, cryptoObj);\n    }\n  }\n  /**\n   * Function which validates server authorization token response.\n   * @param serverResponse\n   * @param refreshAccessToken\n   */\n  validateTokenResponse(serverResponse, refreshAccessToken) {\n    // Check for error\n    if (serverResponse.error || serverResponse.error_description || serverResponse.suberror) {\n      const errString = `${serverResponse.error_codes} - [${serverResponse.timestamp}]: ${serverResponse.error_description} - Correlation ID: ${serverResponse.correlation_id} - Trace ID: ${serverResponse.trace_id}`;\n      const serverError = new ServerError(serverResponse.error, errString, serverResponse.suberror);\n      // check if 500 error\n      if (refreshAccessToken && serverResponse.status && serverResponse.status >= HttpStatus.SERVER_ERROR_RANGE_START && serverResponse.status <= HttpStatus.SERVER_ERROR_RANGE_END) {\n        this.logger.warning(`executeTokenRequest:validateTokenResponse - AAD is currently unavailable and the access token is unable to be refreshed.\\n${serverError}`);\n        // don't throw an exception, but alert the user via a log that the token was unable to be refreshed\n        return;\n        // check if 400 error\n      } else if (refreshAccessToken && serverResponse.status && serverResponse.status >= HttpStatus.CLIENT_ERROR_RANGE_START && serverResponse.status <= HttpStatus.CLIENT_ERROR_RANGE_END) {\n        this.logger.warning(`executeTokenRequest:validateTokenResponse - AAD is currently available but is unable to refresh the access token.\\n${serverError}`);\n        // don't throw an exception, but alert the user via a log that the token was unable to be refreshed\n        return;\n      }\n      if (InteractionRequiredAuthError.isInteractionRequiredError(serverResponse.error, serverResponse.error_description, serverResponse.suberror)) {\n        throw new InteractionRequiredAuthError(serverResponse.error, serverResponse.error_description, serverResponse.suberror, serverResponse.timestamp || Constants.EMPTY_STRING, serverResponse.trace_id || Constants.EMPTY_STRING, serverResponse.correlation_id || Constants.EMPTY_STRING, serverResponse.claims || Constants.EMPTY_STRING);\n      }\n      throw serverError;\n    }\n  }\n  /**\n   * Returns a constructed token response based on given string. Also manages the cache updates and cleanups.\n   * @param serverTokenResponse\n   * @param authority\n   */\n  handleServerTokenResponse(serverTokenResponse, authority, reqTimestamp, request, authCodePayload, userAssertionHash, handlingRefreshTokenResponse, forceCacheRefreshTokenResponse, serverRequestId) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      _this.performanceClient?.addQueueMeasurement(PerformanceEvents.HandleServerTokenResponse, serverTokenResponse.correlation_id);\n      // create an idToken object (not entity)\n      let idTokenClaims;\n      if (serverTokenResponse.id_token) {\n        idTokenClaims = extractTokenClaims(serverTokenResponse.id_token || Constants.EMPTY_STRING, _this.cryptoObj.base64Decode);\n        // token nonce check (TODO: Add a warning if no nonce is given?)\n        if (authCodePayload && authCodePayload.nonce) {\n          if (idTokenClaims.nonce !== authCodePayload.nonce) {\n            throw ClientAuthError.createNonceMismatchError();\n          }\n        }\n        // token max_age check\n        if (request.maxAge || request.maxAge === 0) {\n          const authTime = idTokenClaims.auth_time;\n          if (!authTime) {\n            throw ClientAuthError.createAuthTimeNotFoundError();\n          }\n          checkMaxAge(authTime, request.maxAge);\n        }\n      }\n      // generate homeAccountId\n      _this.homeAccountIdentifier = AccountEntity.generateHomeAccountId(serverTokenResponse.client_info || Constants.EMPTY_STRING, authority.authorityType, _this.logger, _this.cryptoObj, idTokenClaims);\n      // save the response tokens\n      let requestStateObj;\n      if (!!authCodePayload && !!authCodePayload.state) {\n        requestStateObj = ProtocolUtils.parseRequestState(_this.cryptoObj, authCodePayload.state);\n      }\n      // Add keyId from request to serverTokenResponse if defined\n      serverTokenResponse.key_id = serverTokenResponse.key_id || request.sshKid || undefined;\n      const cacheRecord = _this.generateCacheRecord(serverTokenResponse, authority, reqTimestamp, request, idTokenClaims, userAssertionHash, authCodePayload);\n      let cacheContext;\n      try {\n        if (_this.persistencePlugin && _this.serializableCache) {\n          _this.logger.verbose(\"Persistence enabled, calling beforeCacheAccess\");\n          cacheContext = new TokenCacheContext(_this.serializableCache, true);\n          yield _this.persistencePlugin.beforeCacheAccess(cacheContext);\n        }\n        /*\n         * When saving a refreshed tokens to the cache, it is expected that the account that was used is present in the cache.\n         * If not present, we should return null, as it's the case that another application called removeAccount in between\n         * the calls to getAllAccounts and acquireTokenSilent. We should not overwrite that removal, unless explicitly flagged by\n         * the developer, as in the case of refresh token flow used in ADAL Node to MSAL Node migration.\n         */\n        if (handlingRefreshTokenResponse && !forceCacheRefreshTokenResponse && cacheRecord.account) {\n          const key = cacheRecord.account.generateAccountKey();\n          const account = _this.cacheStorage.getAccount(key);\n          if (!account) {\n            _this.logger.warning(\"Account used to refresh tokens not in persistence, refreshed tokens will not be stored in the cache\");\n            return ResponseHandler.generateAuthenticationResult(_this.cryptoObj, authority, cacheRecord, false, request, idTokenClaims, requestStateObj, undefined, serverRequestId);\n          }\n        }\n        yield _this.cacheStorage.saveCacheRecord(cacheRecord, request.storeInCache);\n      } finally {\n        if (_this.persistencePlugin && _this.serializableCache && cacheContext) {\n          _this.logger.verbose(\"Persistence enabled, calling afterCacheAccess\");\n          yield _this.persistencePlugin.afterCacheAccess(cacheContext);\n        }\n      }\n      return ResponseHandler.generateAuthenticationResult(_this.cryptoObj, authority, cacheRecord, false, request, idTokenClaims, requestStateObj, serverTokenResponse, serverRequestId);\n    })();\n  }\n  /**\n   * Generates CacheRecord\n   * @param serverTokenResponse\n   * @param idTokenObj\n   * @param authority\n   */\n  generateCacheRecord(serverTokenResponse, authority, reqTimestamp, request, idTokenClaims, userAssertionHash, authCodePayload) {\n    const env = authority.getPreferredCache();\n    if (!env) {\n      throw ClientAuthError.createInvalidCacheEnvironmentError();\n    }\n    // IdToken: non AAD scenarios can have empty realm\n    let cachedIdToken;\n    let cachedAccount;\n    if (serverTokenResponse.id_token && !!idTokenClaims) {\n      cachedIdToken = IdTokenEntity.createIdTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.id_token, this.clientId, idTokenClaims.tid || \"\");\n      cachedAccount = AccountEntity.createAccount({\n        homeAccountId: this.homeAccountIdentifier,\n        idTokenClaims: idTokenClaims,\n        clientInfo: serverTokenResponse.client_info,\n        cloudGraphHostName: authCodePayload?.cloud_graph_host_name,\n        msGraphHost: authCodePayload?.msgraph_host\n      }, authority);\n    }\n    // AccessToken\n    let cachedAccessToken = null;\n    if (serverTokenResponse.access_token) {\n      // If scopes not returned in server response, use request scopes\n      const responseScopes = serverTokenResponse.scope ? ScopeSet.fromString(serverTokenResponse.scope) : new ScopeSet(request.scopes || []);\n      /*\n       * Use timestamp calculated before request\n       * Server may return timestamps as strings, parse to numbers if so.\n       */\n      const expiresIn = (typeof serverTokenResponse.expires_in === \"string\" ? parseInt(serverTokenResponse.expires_in, 10) : serverTokenResponse.expires_in) || 0;\n      const extExpiresIn = (typeof serverTokenResponse.ext_expires_in === \"string\" ? parseInt(serverTokenResponse.ext_expires_in, 10) : serverTokenResponse.ext_expires_in) || 0;\n      const refreshIn = (typeof serverTokenResponse.refresh_in === \"string\" ? parseInt(serverTokenResponse.refresh_in, 10) : serverTokenResponse.refresh_in) || undefined;\n      const tokenExpirationSeconds = reqTimestamp + expiresIn;\n      const extendedTokenExpirationSeconds = tokenExpirationSeconds + extExpiresIn;\n      const refreshOnSeconds = refreshIn && refreshIn > 0 ? reqTimestamp + refreshIn : undefined;\n      // non AAD scenarios can have empty realm\n      cachedAccessToken = AccessTokenEntity.createAccessTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.access_token || Constants.EMPTY_STRING, this.clientId, idTokenClaims?.tid || authority.tenant, responseScopes.printScopes(), tokenExpirationSeconds, extendedTokenExpirationSeconds, this.cryptoObj, refreshOnSeconds, serverTokenResponse.token_type, userAssertionHash, serverTokenResponse.key_id, request.claims, request.requestedClaimsHash);\n    }\n    // refreshToken\n    let cachedRefreshToken = null;\n    if (serverTokenResponse.refresh_token) {\n      cachedRefreshToken = RefreshTokenEntity.createRefreshTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.refresh_token || Constants.EMPTY_STRING, this.clientId, serverTokenResponse.foci, userAssertionHash);\n    }\n    // appMetadata\n    let cachedAppMetadata = null;\n    if (serverTokenResponse.foci) {\n      cachedAppMetadata = AppMetadataEntity.createAppMetadataEntity(this.clientId, env, serverTokenResponse.foci);\n    }\n    return new CacheRecord(cachedAccount, cachedIdToken, cachedAccessToken, cachedRefreshToken, cachedAppMetadata);\n  }\n  /**\n   * Creates an @AuthenticationResult from @CacheRecord , @IdToken , and a boolean that states whether or not the result is from cache.\n   *\n   * Optionally takes a state string that is set as-is in the response.\n   *\n   * @param cacheRecord\n   * @param idTokenObj\n   * @param fromTokenCache\n   * @param stateString\n   */\n  static generateAuthenticationResult(cryptoObj, authority, cacheRecord, fromTokenCache, request, idTokenClaims, requestState, serverTokenResponse, requestId) {\n    return _asyncToGenerator(function* () {\n      let accessToken = Constants.EMPTY_STRING;\n      let responseScopes = [];\n      let expiresOn = null;\n      let extExpiresOn;\n      let refreshOn;\n      let familyId = Constants.EMPTY_STRING;\n      if (cacheRecord.accessToken) {\n        if (cacheRecord.accessToken.tokenType === AuthenticationScheme.POP) {\n          const popTokenGenerator = new PopTokenGenerator(cryptoObj);\n          const {\n            secret,\n            keyId\n          } = cacheRecord.accessToken;\n          if (!keyId) {\n            throw ClientAuthError.createKeyIdMissingError();\n          }\n          accessToken = yield popTokenGenerator.signPopToken(secret, keyId, request);\n        } else {\n          accessToken = cacheRecord.accessToken.secret;\n        }\n        responseScopes = ScopeSet.fromString(cacheRecord.accessToken.target).asArray();\n        expiresOn = new Date(Number(cacheRecord.accessToken.expiresOn) * 1000);\n        extExpiresOn = new Date(Number(cacheRecord.accessToken.extendedExpiresOn) * 1000);\n        if (cacheRecord.accessToken.refreshOn) {\n          refreshOn = new Date(Number(cacheRecord.accessToken.refreshOn) * 1000);\n        }\n      }\n      if (cacheRecord.appMetadata) {\n        familyId = cacheRecord.appMetadata.familyId === THE_FAMILY_ID ? THE_FAMILY_ID : \"\";\n      }\n      const uid = idTokenClaims?.oid || idTokenClaims?.sub || \"\";\n      const tid = idTokenClaims?.tid || \"\";\n      // for hybrid + native bridge enablement, send back the native account Id\n      if (serverTokenResponse?.spa_accountid && !!cacheRecord.account) {\n        cacheRecord.account.nativeAccountId = serverTokenResponse?.spa_accountid;\n      }\n      return {\n        authority: authority.canonicalAuthority,\n        uniqueId: uid,\n        tenantId: tid,\n        scopes: responseScopes,\n        account: cacheRecord.account ? cacheRecord.account.getAccountInfo() : null,\n        idToken: cacheRecord?.idToken?.secret || \"\",\n        idTokenClaims: idTokenClaims || {},\n        accessToken: accessToken,\n        fromCache: fromTokenCache,\n        expiresOn: expiresOn,\n        extExpiresOn: extExpiresOn,\n        refreshOn: refreshOn,\n        correlationId: request.correlationId,\n        requestId: requestId || Constants.EMPTY_STRING,\n        familyId: familyId,\n        tokenType: cacheRecord.accessToken?.tokenType || Constants.EMPTY_STRING,\n        state: requestState ? requestState.userRequestState : Constants.EMPTY_STRING,\n        cloudGraphHostName: cacheRecord.account?.cloudGraphHostName || Constants.EMPTY_STRING,\n        msGraphHost: cacheRecord.account?.msGraphHost || Constants.EMPTY_STRING,\n        code: serverTokenResponse?.spa_code,\n        fromNativeBroker: false\n      };\n    })();\n  }\n}\nexport { ResponseHandler };","map":{"version":3,"names":["_asyncToGenerator","buildClientInfo","ClientAuthError","ServerError","ScopeSet","AccountEntity","IdTokenEntity","AccessTokenEntity","RefreshTokenEntity","InteractionRequiredAuthError","CacheRecord","ProtocolUtils","Constants","HttpStatus","AuthenticationScheme","THE_FAMILY_ID","PopTokenGenerator","AppMetadataEntity","TokenCacheContext","PerformanceEvents","extractTokenClaims","checkMaxAge","ResponseHandler","constructor","clientId","cacheStorage","cryptoObj","logger","serializableCache","persistencePlugin","performanceClient","validateServerAuthorizationCodeResponse","serverResponseHash","cachedState","state","createStateNotFoundError","decodedServerResponseHash","decodedCachedState","decodeURIComponent","e","createInvalidStateError","createStateMismatchError","error","error_description","suberror","isInteractionRequiredError","EMPTY_STRING","timestamp","trace_id","correlation_id","claims","client_info","validateTokenResponse","serverResponse","refreshAccessToken","errString","error_codes","serverError","status","SERVER_ERROR_RANGE_START","SERVER_ERROR_RANGE_END","warning","CLIENT_ERROR_RANGE_START","CLIENT_ERROR_RANGE_END","handleServerTokenResponse","serverTokenResponse","authority","reqTimestamp","request","authCodePayload","userAssertionHash","handlingRefreshTokenResponse","forceCacheRefreshTokenResponse","serverRequestId","_this","addQueueMeasurement","HandleServerTokenResponse","idTokenClaims","id_token","base64Decode","nonce","createNonceMismatchError","maxAge","authTime","auth_time","createAuthTimeNotFoundError","homeAccountIdentifier","generateHomeAccountId","authorityType","requestStateObj","parseRequestState","key_id","sshKid","undefined","cacheRecord","generateCacheRecord","cacheContext","verbose","beforeCacheAccess","account","key","generateAccountKey","getAccount","generateAuthenticationResult","saveCacheRecord","storeInCache","afterCacheAccess","env","getPreferredCache","createInvalidCacheEnvironmentError","cachedIdToken","cachedAccount","createIdTokenEntity","tid","createAccount","homeAccountId","clientInfo","cloudGraphHostName","cloud_graph_host_name","msGraphHost","msgraph_host","cachedAccessToken","access_token","responseScopes","scope","fromString","scopes","expiresIn","expires_in","parseInt","extExpiresIn","ext_expires_in","refreshIn","refresh_in","tokenExpirationSeconds","extendedTokenExpirationSeconds","refreshOnSeconds","createAccessTokenEntity","tenant","printScopes","token_type","requestedClaimsHash","cachedRefreshToken","refresh_token","createRefreshTokenEntity","foci","cachedAppMetadata","createAppMetadataEntity","fromTokenCache","requestState","requestId","accessToken","expiresOn","extExpiresOn","refreshOn","familyId","tokenType","POP","popTokenGenerator","secret","keyId","createKeyIdMissingError","signPopToken","target","asArray","Date","Number","extendedExpiresOn","appMetadata","uid","oid","sub","spa_accountid","nativeAccountId","canonicalAuthority","uniqueId","tenantId","getAccountInfo","idToken","fromCache","correlationId","userRequestState","code","spa_code","fromNativeBroker"],"sources":["C:/Users/v-dkamali/Documents/AngularMSALAD/microsoft-login/node_modules/@azure/msal-common/dist/response/ResponseHandler.mjs"],"sourcesContent":["/*! @azure/msal-common v14.0.3 2023-09-05 */\n'use strict';\nimport { buildClientInfo } from '../account/ClientInfo.mjs';\nimport { ClientAuthError } from '../error/ClientAuthError.mjs';\nimport { ServerError } from '../error/ServerError.mjs';\nimport { ScopeSet } from '../request/ScopeSet.mjs';\nimport { AccountEntity } from '../cache/entities/AccountEntity.mjs';\nimport { IdTokenEntity } from '../cache/entities/IdTokenEntity.mjs';\nimport { AccessTokenEntity } from '../cache/entities/AccessTokenEntity.mjs';\nimport { RefreshTokenEntity } from '../cache/entities/RefreshTokenEntity.mjs';\nimport { InteractionRequiredAuthError } from '../error/InteractionRequiredAuthError.mjs';\nimport { CacheRecord } from '../cache/entities/CacheRecord.mjs';\nimport { ProtocolUtils } from '../utils/ProtocolUtils.mjs';\nimport { Constants, HttpStatus, AuthenticationScheme, THE_FAMILY_ID } from '../utils/Constants.mjs';\nimport { PopTokenGenerator } from '../crypto/PopTokenGenerator.mjs';\nimport { AppMetadataEntity } from '../cache/entities/AppMetadataEntity.mjs';\nimport { TokenCacheContext } from '../cache/persistence/TokenCacheContext.mjs';\nimport { PerformanceEvents } from '../telemetry/performance/PerformanceEvent.mjs';\nimport { extractTokenClaims, checkMaxAge } from '../account/AuthToken.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * Class that handles response parsing.\n * @internal\n */\nclass ResponseHandler {\n    constructor(clientId, cacheStorage, cryptoObj, logger, serializableCache, persistencePlugin, performanceClient) {\n        this.clientId = clientId;\n        this.cacheStorage = cacheStorage;\n        this.cryptoObj = cryptoObj;\n        this.logger = logger;\n        this.serializableCache = serializableCache;\n        this.persistencePlugin = persistencePlugin;\n        this.performanceClient = performanceClient;\n    }\n    /**\n     * Function which validates server authorization code response.\n     * @param serverResponseHash\n     * @param cachedState\n     * @param cryptoObj\n     */\n    validateServerAuthorizationCodeResponse(serverResponseHash, cachedState, cryptoObj) {\n        if (!serverResponseHash.state || !cachedState) {\n            throw serverResponseHash.state\n                ? ClientAuthError.createStateNotFoundError(\"Cached State\")\n                : ClientAuthError.createStateNotFoundError(\"Server State\");\n        }\n        let decodedServerResponseHash;\n        let decodedCachedState;\n        try {\n            decodedServerResponseHash = decodeURIComponent(serverResponseHash.state);\n        }\n        catch (e) {\n            throw ClientAuthError.createInvalidStateError(serverResponseHash.state, `Server response hash URI could not be decoded`);\n        }\n        try {\n            decodedCachedState = decodeURIComponent(cachedState);\n        }\n        catch (e) {\n            throw ClientAuthError.createInvalidStateError(serverResponseHash.state, `Cached state URI could not be decoded`);\n        }\n        if (decodedServerResponseHash !== decodedCachedState) {\n            throw ClientAuthError.createStateMismatchError();\n        }\n        // Check for error\n        if (serverResponseHash.error ||\n            serverResponseHash.error_description ||\n            serverResponseHash.suberror) {\n            if (InteractionRequiredAuthError.isInteractionRequiredError(serverResponseHash.error, serverResponseHash.error_description, serverResponseHash.suberror)) {\n                throw new InteractionRequiredAuthError(serverResponseHash.error || Constants.EMPTY_STRING, serverResponseHash.error_description, serverResponseHash.suberror, serverResponseHash.timestamp || Constants.EMPTY_STRING, serverResponseHash.trace_id || Constants.EMPTY_STRING, serverResponseHash.correlation_id || Constants.EMPTY_STRING, serverResponseHash.claims || Constants.EMPTY_STRING);\n            }\n            throw new ServerError(serverResponseHash.error || Constants.EMPTY_STRING, serverResponseHash.error_description, serverResponseHash.suberror);\n        }\n        if (serverResponseHash.client_info) {\n            buildClientInfo(serverResponseHash.client_info, cryptoObj);\n        }\n    }\n    /**\n     * Function which validates server authorization token response.\n     * @param serverResponse\n     * @param refreshAccessToken\n     */\n    validateTokenResponse(serverResponse, refreshAccessToken) {\n        // Check for error\n        if (serverResponse.error ||\n            serverResponse.error_description ||\n            serverResponse.suberror) {\n            const errString = `${serverResponse.error_codes} - [${serverResponse.timestamp}]: ${serverResponse.error_description} - Correlation ID: ${serverResponse.correlation_id} - Trace ID: ${serverResponse.trace_id}`;\n            const serverError = new ServerError(serverResponse.error, errString, serverResponse.suberror);\n            // check if 500 error\n            if (refreshAccessToken &&\n                serverResponse.status &&\n                serverResponse.status >= HttpStatus.SERVER_ERROR_RANGE_START &&\n                serverResponse.status <= HttpStatus.SERVER_ERROR_RANGE_END) {\n                this.logger.warning(`executeTokenRequest:validateTokenResponse - AAD is currently unavailable and the access token is unable to be refreshed.\\n${serverError}`);\n                // don't throw an exception, but alert the user via a log that the token was unable to be refreshed\n                return;\n                // check if 400 error\n            }\n            else if (refreshAccessToken &&\n                serverResponse.status &&\n                serverResponse.status >= HttpStatus.CLIENT_ERROR_RANGE_START &&\n                serverResponse.status <= HttpStatus.CLIENT_ERROR_RANGE_END) {\n                this.logger.warning(`executeTokenRequest:validateTokenResponse - AAD is currently available but is unable to refresh the access token.\\n${serverError}`);\n                // don't throw an exception, but alert the user via a log that the token was unable to be refreshed\n                return;\n            }\n            if (InteractionRequiredAuthError.isInteractionRequiredError(serverResponse.error, serverResponse.error_description, serverResponse.suberror)) {\n                throw new InteractionRequiredAuthError(serverResponse.error, serverResponse.error_description, serverResponse.suberror, serverResponse.timestamp || Constants.EMPTY_STRING, serverResponse.trace_id || Constants.EMPTY_STRING, serverResponse.correlation_id || Constants.EMPTY_STRING, serverResponse.claims || Constants.EMPTY_STRING);\n            }\n            throw serverError;\n        }\n    }\n    /**\n     * Returns a constructed token response based on given string. Also manages the cache updates and cleanups.\n     * @param serverTokenResponse\n     * @param authority\n     */\n    async handleServerTokenResponse(serverTokenResponse, authority, reqTimestamp, request, authCodePayload, userAssertionHash, handlingRefreshTokenResponse, forceCacheRefreshTokenResponse, serverRequestId) {\n        this.performanceClient?.addQueueMeasurement(PerformanceEvents.HandleServerTokenResponse, serverTokenResponse.correlation_id);\n        // create an idToken object (not entity)\n        let idTokenClaims;\n        if (serverTokenResponse.id_token) {\n            idTokenClaims = extractTokenClaims(serverTokenResponse.id_token || Constants.EMPTY_STRING, this.cryptoObj.base64Decode);\n            // token nonce check (TODO: Add a warning if no nonce is given?)\n            if (authCodePayload && authCodePayload.nonce) {\n                if (idTokenClaims.nonce !== authCodePayload.nonce) {\n                    throw ClientAuthError.createNonceMismatchError();\n                }\n            }\n            // token max_age check\n            if (request.maxAge || request.maxAge === 0) {\n                const authTime = idTokenClaims.auth_time;\n                if (!authTime) {\n                    throw ClientAuthError.createAuthTimeNotFoundError();\n                }\n                checkMaxAge(authTime, request.maxAge);\n            }\n        }\n        // generate homeAccountId\n        this.homeAccountIdentifier = AccountEntity.generateHomeAccountId(serverTokenResponse.client_info || Constants.EMPTY_STRING, authority.authorityType, this.logger, this.cryptoObj, idTokenClaims);\n        // save the response tokens\n        let requestStateObj;\n        if (!!authCodePayload && !!authCodePayload.state) {\n            requestStateObj = ProtocolUtils.parseRequestState(this.cryptoObj, authCodePayload.state);\n        }\n        // Add keyId from request to serverTokenResponse if defined\n        serverTokenResponse.key_id =\n            serverTokenResponse.key_id || request.sshKid || undefined;\n        const cacheRecord = this.generateCacheRecord(serverTokenResponse, authority, reqTimestamp, request, idTokenClaims, userAssertionHash, authCodePayload);\n        let cacheContext;\n        try {\n            if (this.persistencePlugin && this.serializableCache) {\n                this.logger.verbose(\"Persistence enabled, calling beforeCacheAccess\");\n                cacheContext = new TokenCacheContext(this.serializableCache, true);\n                await this.persistencePlugin.beforeCacheAccess(cacheContext);\n            }\n            /*\n             * When saving a refreshed tokens to the cache, it is expected that the account that was used is present in the cache.\n             * If not present, we should return null, as it's the case that another application called removeAccount in between\n             * the calls to getAllAccounts and acquireTokenSilent. We should not overwrite that removal, unless explicitly flagged by\n             * the developer, as in the case of refresh token flow used in ADAL Node to MSAL Node migration.\n             */\n            if (handlingRefreshTokenResponse &&\n                !forceCacheRefreshTokenResponse &&\n                cacheRecord.account) {\n                const key = cacheRecord.account.generateAccountKey();\n                const account = this.cacheStorage.getAccount(key);\n                if (!account) {\n                    this.logger.warning(\"Account used to refresh tokens not in persistence, refreshed tokens will not be stored in the cache\");\n                    return ResponseHandler.generateAuthenticationResult(this.cryptoObj, authority, cacheRecord, false, request, idTokenClaims, requestStateObj, undefined, serverRequestId);\n                }\n            }\n            await this.cacheStorage.saveCacheRecord(cacheRecord, request.storeInCache);\n        }\n        finally {\n            if (this.persistencePlugin &&\n                this.serializableCache &&\n                cacheContext) {\n                this.logger.verbose(\"Persistence enabled, calling afterCacheAccess\");\n                await this.persistencePlugin.afterCacheAccess(cacheContext);\n            }\n        }\n        return ResponseHandler.generateAuthenticationResult(this.cryptoObj, authority, cacheRecord, false, request, idTokenClaims, requestStateObj, serverTokenResponse, serverRequestId);\n    }\n    /**\n     * Generates CacheRecord\n     * @param serverTokenResponse\n     * @param idTokenObj\n     * @param authority\n     */\n    generateCacheRecord(serverTokenResponse, authority, reqTimestamp, request, idTokenClaims, userAssertionHash, authCodePayload) {\n        const env = authority.getPreferredCache();\n        if (!env) {\n            throw ClientAuthError.createInvalidCacheEnvironmentError();\n        }\n        // IdToken: non AAD scenarios can have empty realm\n        let cachedIdToken;\n        let cachedAccount;\n        if (serverTokenResponse.id_token && !!idTokenClaims) {\n            cachedIdToken = IdTokenEntity.createIdTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.id_token, this.clientId, idTokenClaims.tid || \"\");\n            cachedAccount = AccountEntity.createAccount({\n                homeAccountId: this.homeAccountIdentifier,\n                idTokenClaims: idTokenClaims,\n                clientInfo: serverTokenResponse.client_info,\n                cloudGraphHostName: authCodePayload?.cloud_graph_host_name,\n                msGraphHost: authCodePayload?.msgraph_host,\n            }, authority);\n        }\n        // AccessToken\n        let cachedAccessToken = null;\n        if (serverTokenResponse.access_token) {\n            // If scopes not returned in server response, use request scopes\n            const responseScopes = serverTokenResponse.scope\n                ? ScopeSet.fromString(serverTokenResponse.scope)\n                : new ScopeSet(request.scopes || []);\n            /*\n             * Use timestamp calculated before request\n             * Server may return timestamps as strings, parse to numbers if so.\n             */\n            const expiresIn = (typeof serverTokenResponse.expires_in === \"string\"\n                ? parseInt(serverTokenResponse.expires_in, 10)\n                : serverTokenResponse.expires_in) || 0;\n            const extExpiresIn = (typeof serverTokenResponse.ext_expires_in === \"string\"\n                ? parseInt(serverTokenResponse.ext_expires_in, 10)\n                : serverTokenResponse.ext_expires_in) || 0;\n            const refreshIn = (typeof serverTokenResponse.refresh_in === \"string\"\n                ? parseInt(serverTokenResponse.refresh_in, 10)\n                : serverTokenResponse.refresh_in) || undefined;\n            const tokenExpirationSeconds = reqTimestamp + expiresIn;\n            const extendedTokenExpirationSeconds = tokenExpirationSeconds + extExpiresIn;\n            const refreshOnSeconds = refreshIn && refreshIn > 0\n                ? reqTimestamp + refreshIn\n                : undefined;\n            // non AAD scenarios can have empty realm\n            cachedAccessToken = AccessTokenEntity.createAccessTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.access_token || Constants.EMPTY_STRING, this.clientId, idTokenClaims?.tid || authority.tenant, responseScopes.printScopes(), tokenExpirationSeconds, extendedTokenExpirationSeconds, this.cryptoObj, refreshOnSeconds, serverTokenResponse.token_type, userAssertionHash, serverTokenResponse.key_id, request.claims, request.requestedClaimsHash);\n        }\n        // refreshToken\n        let cachedRefreshToken = null;\n        if (serverTokenResponse.refresh_token) {\n            cachedRefreshToken = RefreshTokenEntity.createRefreshTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.refresh_token || Constants.EMPTY_STRING, this.clientId, serverTokenResponse.foci, userAssertionHash);\n        }\n        // appMetadata\n        let cachedAppMetadata = null;\n        if (serverTokenResponse.foci) {\n            cachedAppMetadata = AppMetadataEntity.createAppMetadataEntity(this.clientId, env, serverTokenResponse.foci);\n        }\n        return new CacheRecord(cachedAccount, cachedIdToken, cachedAccessToken, cachedRefreshToken, cachedAppMetadata);\n    }\n    /**\n     * Creates an @AuthenticationResult from @CacheRecord , @IdToken , and a boolean that states whether or not the result is from cache.\n     *\n     * Optionally takes a state string that is set as-is in the response.\n     *\n     * @param cacheRecord\n     * @param idTokenObj\n     * @param fromTokenCache\n     * @param stateString\n     */\n    static async generateAuthenticationResult(cryptoObj, authority, cacheRecord, fromTokenCache, request, idTokenClaims, requestState, serverTokenResponse, requestId) {\n        let accessToken = Constants.EMPTY_STRING;\n        let responseScopes = [];\n        let expiresOn = null;\n        let extExpiresOn;\n        let refreshOn;\n        let familyId = Constants.EMPTY_STRING;\n        if (cacheRecord.accessToken) {\n            if (cacheRecord.accessToken.tokenType === AuthenticationScheme.POP) {\n                const popTokenGenerator = new PopTokenGenerator(cryptoObj);\n                const { secret, keyId } = cacheRecord.accessToken;\n                if (!keyId) {\n                    throw ClientAuthError.createKeyIdMissingError();\n                }\n                accessToken = await popTokenGenerator.signPopToken(secret, keyId, request);\n            }\n            else {\n                accessToken = cacheRecord.accessToken.secret;\n            }\n            responseScopes = ScopeSet.fromString(cacheRecord.accessToken.target).asArray();\n            expiresOn = new Date(Number(cacheRecord.accessToken.expiresOn) * 1000);\n            extExpiresOn = new Date(Number(cacheRecord.accessToken.extendedExpiresOn) * 1000);\n            if (cacheRecord.accessToken.refreshOn) {\n                refreshOn = new Date(Number(cacheRecord.accessToken.refreshOn) * 1000);\n            }\n        }\n        if (cacheRecord.appMetadata) {\n            familyId =\n                cacheRecord.appMetadata.familyId === THE_FAMILY_ID\n                    ? THE_FAMILY_ID\n                    : \"\";\n        }\n        const uid = idTokenClaims?.oid || idTokenClaims?.sub || \"\";\n        const tid = idTokenClaims?.tid || \"\";\n        // for hybrid + native bridge enablement, send back the native account Id\n        if (serverTokenResponse?.spa_accountid && !!cacheRecord.account) {\n            cacheRecord.account.nativeAccountId =\n                serverTokenResponse?.spa_accountid;\n        }\n        return {\n            authority: authority.canonicalAuthority,\n            uniqueId: uid,\n            tenantId: tid,\n            scopes: responseScopes,\n            account: cacheRecord.account\n                ? cacheRecord.account.getAccountInfo()\n                : null,\n            idToken: cacheRecord?.idToken?.secret || \"\",\n            idTokenClaims: idTokenClaims || {},\n            accessToken: accessToken,\n            fromCache: fromTokenCache,\n            expiresOn: expiresOn,\n            extExpiresOn: extExpiresOn,\n            refreshOn: refreshOn,\n            correlationId: request.correlationId,\n            requestId: requestId || Constants.EMPTY_STRING,\n            familyId: familyId,\n            tokenType: cacheRecord.accessToken?.tokenType || Constants.EMPTY_STRING,\n            state: requestState\n                ? requestState.userRequestState\n                : Constants.EMPTY_STRING,\n            cloudGraphHostName: cacheRecord.account?.cloudGraphHostName ||\n                Constants.EMPTY_STRING,\n            msGraphHost: cacheRecord.account?.msGraphHost || Constants.EMPTY_STRING,\n            code: serverTokenResponse?.spa_code,\n            fromNativeBroker: false,\n        };\n    }\n}\n\nexport { ResponseHandler };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}