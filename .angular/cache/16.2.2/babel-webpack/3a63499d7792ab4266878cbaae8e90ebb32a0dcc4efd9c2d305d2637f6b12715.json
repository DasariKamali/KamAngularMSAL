{"ast":null,"code":"/*! @azure/msal-common v14.0.3 2023-09-05 */\n'use strict';\n\nimport { CredentialEntity } from './CredentialEntity.mjs';\nimport { CredentialType, AuthenticationScheme } from '../../utils/Constants.mjs';\nimport { TimeUtils } from '../../utils/TimeUtils.mjs';\nimport { ClientAuthError } from '../../error/ClientAuthError.mjs';\nimport { extractTokenClaims } from '../../account/AuthToken.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * ACCESS_TOKEN Credential Type\n *\n * Key:Value Schema:\n *\n * Key Example: uid.utid-login.microsoftonline.com-accesstoken-clientId-contoso.com-user.read\n *\n * Value Schema:\n * {\n *      homeAccountId: home account identifier for the auth scheme,\n *      environment: entity that issued the token, represented as a full host\n *      credentialType: Type of credential as a string, can be one of the following: RefreshToken, AccessToken, IdToken, Password, Cookie, Certificate, Other\n *      clientId: client ID of the application\n *      secret: Actual credential as a string\n *      familyId: Family ID identifier, usually only used for refresh tokens\n *      realm: Full tenant or organizational identifier that the account belongs to\n *      target: Permissions that are included in the token, or for refresh tokens, the resource identifier.\n *      cachedAt: Absolute device time when entry was created in the cache.\n *      expiresOn: Token expiry time, calculated based on current UTC time in seconds. Represented as a string.\n *      extendedExpiresOn: Additional extended expiry time until when token is valid in case of server-side outage. Represented as string in UTC seconds.\n *      keyId: used for POP and SSH tokenTypes\n *      tokenType: Type of the token issued. Usually \"Bearer\"\n * }\n */\nclass AccessTokenEntity extends CredentialEntity {\n  /**\n   * Create AccessTokenEntity\n   * @param homeAccountId\n   * @param environment\n   * @param accessToken\n   * @param clientId\n   * @param tenantId\n   * @param scopes\n   * @param expiresOn\n   * @param extExpiresOn\n   */\n  static createAccessTokenEntity(homeAccountId, environment, accessToken, clientId, tenantId, scopes, expiresOn, extExpiresOn, cryptoUtils, refreshOn, tokenType, userAssertionHash, keyId, requestedClaims, requestedClaimsHash) {\n    const atEntity = new AccessTokenEntity();\n    atEntity.homeAccountId = homeAccountId;\n    atEntity.credentialType = CredentialType.ACCESS_TOKEN;\n    atEntity.secret = accessToken;\n    const currentTime = TimeUtils.nowSeconds();\n    atEntity.cachedAt = currentTime.toString();\n    /*\n     * Token expiry time.\n     * This value should be  calculated based on the current UTC time measured locally and the value  expires_in Represented as a string in JSON.\n     */\n    atEntity.expiresOn = expiresOn.toString();\n    atEntity.extendedExpiresOn = extExpiresOn.toString();\n    if (refreshOn) {\n      atEntity.refreshOn = refreshOn.toString();\n    }\n    atEntity.environment = environment;\n    atEntity.clientId = clientId;\n    atEntity.realm = tenantId;\n    atEntity.target = scopes;\n    atEntity.userAssertionHash = userAssertionHash;\n    atEntity.tokenType = tokenType || AuthenticationScheme.BEARER;\n    if (requestedClaims) {\n      atEntity.requestedClaims = requestedClaims;\n      atEntity.requestedClaimsHash = requestedClaimsHash;\n    }\n    /*\n     * Create Access Token With Auth Scheme instead of regular access token\n     * Cast to lower to handle \"bearer\" from ADFS\n     */\n    if (atEntity.tokenType?.toLowerCase() !== AuthenticationScheme.BEARER.toLowerCase()) {\n      atEntity.credentialType = CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME;\n      switch (atEntity.tokenType) {\n        case AuthenticationScheme.POP:\n          // Make sure keyId is present and add it to credential\n          const tokenClaims = extractTokenClaims(accessToken, cryptoUtils.base64Decode);\n          if (!tokenClaims?.cnf?.kid) {\n            throw ClientAuthError.createTokenClaimsRequiredError();\n          }\n          atEntity.keyId = tokenClaims.cnf.kid;\n          break;\n        case AuthenticationScheme.SSH:\n          atEntity.keyId = keyId;\n      }\n    }\n    return atEntity;\n  }\n  /**\n   * Validates an entity: checks for all expected params\n   * @param entity\n   */\n  static isAccessTokenEntity(entity) {\n    if (!entity) {\n      return false;\n    }\n    return entity.hasOwnProperty(\"homeAccountId\") && entity.hasOwnProperty(\"environment\") && entity.hasOwnProperty(\"credentialType\") && entity.hasOwnProperty(\"realm\") && entity.hasOwnProperty(\"clientId\") && entity.hasOwnProperty(\"secret\") && entity.hasOwnProperty(\"target\") && (entity[\"credentialType\"] === CredentialType.ACCESS_TOKEN || entity[\"credentialType\"] === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME);\n  }\n}\nexport { AccessTokenEntity };","map":{"version":3,"names":["CredentialEntity","CredentialType","AuthenticationScheme","TimeUtils","ClientAuthError","extractTokenClaims","AccessTokenEntity","createAccessTokenEntity","homeAccountId","environment","accessToken","clientId","tenantId","scopes","expiresOn","extExpiresOn","cryptoUtils","refreshOn","tokenType","userAssertionHash","keyId","requestedClaims","requestedClaimsHash","atEntity","credentialType","ACCESS_TOKEN","secret","currentTime","nowSeconds","cachedAt","toString","extendedExpiresOn","realm","target","BEARER","toLowerCase","ACCESS_TOKEN_WITH_AUTH_SCHEME","POP","tokenClaims","base64Decode","cnf","kid","createTokenClaimsRequiredError","SSH","isAccessTokenEntity","entity","hasOwnProperty"],"sources":["C:/Users/v-dkamali/Documents/AngularMSALAD/microsoft-login/node_modules/@azure/msal-common/dist/cache/entities/AccessTokenEntity.mjs"],"sourcesContent":["/*! @azure/msal-common v14.0.3 2023-09-05 */\n'use strict';\nimport { CredentialEntity } from './CredentialEntity.mjs';\nimport { CredentialType, AuthenticationScheme } from '../../utils/Constants.mjs';\nimport { TimeUtils } from '../../utils/TimeUtils.mjs';\nimport { ClientAuthError } from '../../error/ClientAuthError.mjs';\nimport { extractTokenClaims } from '../../account/AuthToken.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * ACCESS_TOKEN Credential Type\n *\n * Key:Value Schema:\n *\n * Key Example: uid.utid-login.microsoftonline.com-accesstoken-clientId-contoso.com-user.read\n *\n * Value Schema:\n * {\n *      homeAccountId: home account identifier for the auth scheme,\n *      environment: entity that issued the token, represented as a full host\n *      credentialType: Type of credential as a string, can be one of the following: RefreshToken, AccessToken, IdToken, Password, Cookie, Certificate, Other\n *      clientId: client ID of the application\n *      secret: Actual credential as a string\n *      familyId: Family ID identifier, usually only used for refresh tokens\n *      realm: Full tenant or organizational identifier that the account belongs to\n *      target: Permissions that are included in the token, or for refresh tokens, the resource identifier.\n *      cachedAt: Absolute device time when entry was created in the cache.\n *      expiresOn: Token expiry time, calculated based on current UTC time in seconds. Represented as a string.\n *      extendedExpiresOn: Additional extended expiry time until when token is valid in case of server-side outage. Represented as string in UTC seconds.\n *      keyId: used for POP and SSH tokenTypes\n *      tokenType: Type of the token issued. Usually \"Bearer\"\n * }\n */\nclass AccessTokenEntity extends CredentialEntity {\n    /**\n     * Create AccessTokenEntity\n     * @param homeAccountId\n     * @param environment\n     * @param accessToken\n     * @param clientId\n     * @param tenantId\n     * @param scopes\n     * @param expiresOn\n     * @param extExpiresOn\n     */\n    static createAccessTokenEntity(homeAccountId, environment, accessToken, clientId, tenantId, scopes, expiresOn, extExpiresOn, cryptoUtils, refreshOn, tokenType, userAssertionHash, keyId, requestedClaims, requestedClaimsHash) {\n        const atEntity = new AccessTokenEntity();\n        atEntity.homeAccountId = homeAccountId;\n        atEntity.credentialType = CredentialType.ACCESS_TOKEN;\n        atEntity.secret = accessToken;\n        const currentTime = TimeUtils.nowSeconds();\n        atEntity.cachedAt = currentTime.toString();\n        /*\n         * Token expiry time.\n         * This value should be  calculated based on the current UTC time measured locally and the value  expires_in Represented as a string in JSON.\n         */\n        atEntity.expiresOn = expiresOn.toString();\n        atEntity.extendedExpiresOn = extExpiresOn.toString();\n        if (refreshOn) {\n            atEntity.refreshOn = refreshOn.toString();\n        }\n        atEntity.environment = environment;\n        atEntity.clientId = clientId;\n        atEntity.realm = tenantId;\n        atEntity.target = scopes;\n        atEntity.userAssertionHash = userAssertionHash;\n        atEntity.tokenType = tokenType || AuthenticationScheme.BEARER;\n        if (requestedClaims) {\n            atEntity.requestedClaims = requestedClaims;\n            atEntity.requestedClaimsHash = requestedClaimsHash;\n        }\n        /*\n         * Create Access Token With Auth Scheme instead of regular access token\n         * Cast to lower to handle \"bearer\" from ADFS\n         */\n        if (atEntity.tokenType?.toLowerCase() !==\n            AuthenticationScheme.BEARER.toLowerCase()) {\n            atEntity.credentialType =\n                CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME;\n            switch (atEntity.tokenType) {\n                case AuthenticationScheme.POP:\n                    // Make sure keyId is present and add it to credential\n                    const tokenClaims = extractTokenClaims(accessToken, cryptoUtils.base64Decode);\n                    if (!tokenClaims?.cnf?.kid) {\n                        throw ClientAuthError.createTokenClaimsRequiredError();\n                    }\n                    atEntity.keyId = tokenClaims.cnf.kid;\n                    break;\n                case AuthenticationScheme.SSH:\n                    atEntity.keyId = keyId;\n            }\n        }\n        return atEntity;\n    }\n    /**\n     * Validates an entity: checks for all expected params\n     * @param entity\n     */\n    static isAccessTokenEntity(entity) {\n        if (!entity) {\n            return false;\n        }\n        return (entity.hasOwnProperty(\"homeAccountId\") &&\n            entity.hasOwnProperty(\"environment\") &&\n            entity.hasOwnProperty(\"credentialType\") &&\n            entity.hasOwnProperty(\"realm\") &&\n            entity.hasOwnProperty(\"clientId\") &&\n            entity.hasOwnProperty(\"secret\") &&\n            entity.hasOwnProperty(\"target\") &&\n            (entity[\"credentialType\"] === CredentialType.ACCESS_TOKEN ||\n                entity[\"credentialType\"] ===\n                    CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME));\n    }\n}\n\nexport { AccessTokenEntity };\n"],"mappings":"AAAA;AACA,YAAY;;AACZ,SAASA,gBAAgB,QAAQ,wBAAwB;AACzD,SAASC,cAAc,EAAEC,oBAAoB,QAAQ,2BAA2B;AAChF,SAASC,SAAS,QAAQ,2BAA2B;AACrD,SAASC,eAAe,QAAQ,iCAAiC;AACjE,SAASC,kBAAkB,QAAQ,6BAA6B;;AAEhE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,iBAAiB,SAASN,gBAAgB,CAAC;EAC7C;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,OAAOO,uBAAuBA,CAACC,aAAa,EAAEC,WAAW,EAAEC,WAAW,EAAEC,QAAQ,EAAEC,QAAQ,EAAEC,MAAM,EAAEC,SAAS,EAAEC,YAAY,EAAEC,WAAW,EAAEC,SAAS,EAAEC,SAAS,EAAEC,iBAAiB,EAAEC,KAAK,EAAEC,eAAe,EAAEC,mBAAmB,EAAE;IAC5N,MAAMC,QAAQ,GAAG,IAAIjB,iBAAiB,CAAC,CAAC;IACxCiB,QAAQ,CAACf,aAAa,GAAGA,aAAa;IACtCe,QAAQ,CAACC,cAAc,GAAGvB,cAAc,CAACwB,YAAY;IACrDF,QAAQ,CAACG,MAAM,GAAGhB,WAAW;IAC7B,MAAMiB,WAAW,GAAGxB,SAAS,CAACyB,UAAU,CAAC,CAAC;IAC1CL,QAAQ,CAACM,QAAQ,GAAGF,WAAW,CAACG,QAAQ,CAAC,CAAC;IAC1C;AACR;AACA;AACA;IACQP,QAAQ,CAACT,SAAS,GAAGA,SAAS,CAACgB,QAAQ,CAAC,CAAC;IACzCP,QAAQ,CAACQ,iBAAiB,GAAGhB,YAAY,CAACe,QAAQ,CAAC,CAAC;IACpD,IAAIb,SAAS,EAAE;MACXM,QAAQ,CAACN,SAAS,GAAGA,SAAS,CAACa,QAAQ,CAAC,CAAC;IAC7C;IACAP,QAAQ,CAACd,WAAW,GAAGA,WAAW;IAClCc,QAAQ,CAACZ,QAAQ,GAAGA,QAAQ;IAC5BY,QAAQ,CAACS,KAAK,GAAGpB,QAAQ;IACzBW,QAAQ,CAACU,MAAM,GAAGpB,MAAM;IACxBU,QAAQ,CAACJ,iBAAiB,GAAGA,iBAAiB;IAC9CI,QAAQ,CAACL,SAAS,GAAGA,SAAS,IAAIhB,oBAAoB,CAACgC,MAAM;IAC7D,IAAIb,eAAe,EAAE;MACjBE,QAAQ,CAACF,eAAe,GAAGA,eAAe;MAC1CE,QAAQ,CAACD,mBAAmB,GAAGA,mBAAmB;IACtD;IACA;AACR;AACA;AACA;IACQ,IAAIC,QAAQ,CAACL,SAAS,EAAEiB,WAAW,CAAC,CAAC,KACjCjC,oBAAoB,CAACgC,MAAM,CAACC,WAAW,CAAC,CAAC,EAAE;MAC3CZ,QAAQ,CAACC,cAAc,GACnBvB,cAAc,CAACmC,6BAA6B;MAChD,QAAQb,QAAQ,CAACL,SAAS;QACtB,KAAKhB,oBAAoB,CAACmC,GAAG;UACzB;UACA,MAAMC,WAAW,GAAGjC,kBAAkB,CAACK,WAAW,EAAEM,WAAW,CAACuB,YAAY,CAAC;UAC7E,IAAI,CAACD,WAAW,EAAEE,GAAG,EAAEC,GAAG,EAAE;YACxB,MAAMrC,eAAe,CAACsC,8BAA8B,CAAC,CAAC;UAC1D;UACAnB,QAAQ,CAACH,KAAK,GAAGkB,WAAW,CAACE,GAAG,CAACC,GAAG;UACpC;QACJ,KAAKvC,oBAAoB,CAACyC,GAAG;UACzBpB,QAAQ,CAACH,KAAK,GAAGA,KAAK;MAC9B;IACJ;IACA,OAAOG,QAAQ;EACnB;EACA;AACJ;AACA;AACA;EACI,OAAOqB,mBAAmBA,CAACC,MAAM,EAAE;IAC/B,IAAI,CAACA,MAAM,EAAE;MACT,OAAO,KAAK;IAChB;IACA,OAAQA,MAAM,CAACC,cAAc,CAAC,eAAe,CAAC,IAC1CD,MAAM,CAACC,cAAc,CAAC,aAAa,CAAC,IACpCD,MAAM,CAACC,cAAc,CAAC,gBAAgB,CAAC,IACvCD,MAAM,CAACC,cAAc,CAAC,OAAO,CAAC,IAC9BD,MAAM,CAACC,cAAc,CAAC,UAAU,CAAC,IACjCD,MAAM,CAACC,cAAc,CAAC,QAAQ,CAAC,IAC/BD,MAAM,CAACC,cAAc,CAAC,QAAQ,CAAC,KAC9BD,MAAM,CAAC,gBAAgB,CAAC,KAAK5C,cAAc,CAACwB,YAAY,IACrDoB,MAAM,CAAC,gBAAgB,CAAC,KACpB5C,cAAc,CAACmC,6BAA6B,CAAC;EAC7D;AACJ;AAEA,SAAS9B,iBAAiB"},"metadata":{},"sourceType":"module","externalDependencies":[]}