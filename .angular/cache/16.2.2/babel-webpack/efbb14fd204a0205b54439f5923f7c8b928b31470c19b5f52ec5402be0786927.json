{"ast":null,"code":"/*! @azure/msal-common v14.0.3 2023-09-05 */\n'use strict';\n\nimport _asyncToGenerator from \"C:/Users/v-dkamali/Documents/AngularMSALAD/microsoft-login/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { Constants, ResponseCodes, RegionDiscoverySources } from '../utils/Constants.mjs';\nimport { PerformanceEvents } from '../telemetry/performance/PerformanceEvent.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nclass RegionDiscovery {\n  constructor(networkInterface, performanceClient, correlationId) {\n    this.networkInterface = networkInterface;\n    this.performanceClient = performanceClient;\n    this.correlationId = correlationId;\n  }\n  /**\n   * Detect the region from the application's environment.\n   *\n   * @returns Promise<string | null>\n   */\n  detectRegion(environmentRegion, regionDiscoveryMetadata) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      _this.performanceClient?.addQueueMeasurement(PerformanceEvents.RegionDiscoveryDetectRegion, _this.correlationId);\n      // Initialize auto detected region with the region from the envrionment\n      let autodetectedRegionName = environmentRegion;\n      // Check if a region was detected from the environment, if not, attempt to get the region from IMDS\n      if (!autodetectedRegionName) {\n        const options = RegionDiscovery.IMDS_OPTIONS;\n        try {\n          _this.performanceClient?.setPreQueueTime(PerformanceEvents.RegionDiscoveryGetRegionFromIMDS, _this.correlationId);\n          const localIMDSVersionResponse = yield _this.getRegionFromIMDS(Constants.IMDS_VERSION, options);\n          if (localIMDSVersionResponse.status === ResponseCodes.httpSuccess) {\n            autodetectedRegionName = localIMDSVersionResponse.body;\n            regionDiscoveryMetadata.region_source = RegionDiscoverySources.IMDS;\n          }\n          // If the response using the local IMDS version failed, try to fetch the current version of IMDS and retry.\n          if (localIMDSVersionResponse.status === ResponseCodes.httpBadRequest) {\n            _this.performanceClient?.setPreQueueTime(PerformanceEvents.RegionDiscoveryGetCurrentVersion, _this.correlationId);\n            const currentIMDSVersion = yield _this.getCurrentVersion(options);\n            if (!currentIMDSVersion) {\n              regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;\n              return null;\n            }\n            _this.performanceClient?.setPreQueueTime(PerformanceEvents.RegionDiscoveryGetRegionFromIMDS, _this.correlationId);\n            const currentIMDSVersionResponse = yield _this.getRegionFromIMDS(currentIMDSVersion, options);\n            if (currentIMDSVersionResponse.status === ResponseCodes.httpSuccess) {\n              autodetectedRegionName = currentIMDSVersionResponse.body;\n              regionDiscoveryMetadata.region_source = RegionDiscoverySources.IMDS;\n            }\n          }\n        } catch (e) {\n          regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;\n          return null;\n        }\n      } else {\n        regionDiscoveryMetadata.region_source = RegionDiscoverySources.ENVIRONMENT_VARIABLE;\n      }\n      // If no region was auto detected from the environment or from the IMDS endpoint, mark the attempt as a FAILED_AUTO_DETECTION\n      if (!autodetectedRegionName) {\n        regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;\n      }\n      return autodetectedRegionName || null;\n    })();\n  }\n  /**\n   * Make the call to the IMDS endpoint\n   *\n   * @param imdsEndpointUrl\n   * @returns Promise<NetworkResponse<string>>\n   */\n  getRegionFromIMDS(version, options) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      _this2.performanceClient?.addQueueMeasurement(PerformanceEvents.RegionDiscoveryGetRegionFromIMDS, _this2.correlationId);\n      return _this2.networkInterface.sendGetRequestAsync(`${Constants.IMDS_ENDPOINT}?api-version=${version}&format=text`, options, Constants.IMDS_TIMEOUT);\n    })();\n  }\n  /**\n   * Get the most recent version of the IMDS endpoint available\n   *\n   * @returns Promise<string | null>\n   */\n  getCurrentVersion(options) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      _this3.performanceClient?.addQueueMeasurement(PerformanceEvents.RegionDiscoveryGetCurrentVersion, _this3.correlationId);\n      try {\n        const response = yield _this3.networkInterface.sendGetRequestAsync(`${Constants.IMDS_ENDPOINT}?format=json`, options);\n        // When IMDS endpoint is called without the api version query param, bad request response comes back with latest version.\n        if (response.status === ResponseCodes.httpBadRequest && response.body && response.body[\"newest-versions\"] && response.body[\"newest-versions\"].length > 0) {\n          return response.body[\"newest-versions\"][0];\n        }\n        return null;\n      } catch (e) {\n        return null;\n      }\n    })();\n  }\n}\n// Options for the IMDS endpoint request\nRegionDiscovery.IMDS_OPTIONS = {\n  headers: {\n    Metadata: \"true\"\n  }\n};\nexport { RegionDiscovery };","map":{"version":3,"names":["_asyncToGenerator","Constants","ResponseCodes","RegionDiscoverySources","PerformanceEvents","RegionDiscovery","constructor","networkInterface","performanceClient","correlationId","detectRegion","environmentRegion","regionDiscoveryMetadata","_this","addQueueMeasurement","RegionDiscoveryDetectRegion","autodetectedRegionName","options","IMDS_OPTIONS","setPreQueueTime","RegionDiscoveryGetRegionFromIMDS","localIMDSVersionResponse","getRegionFromIMDS","IMDS_VERSION","status","httpSuccess","body","region_source","IMDS","httpBadRequest","RegionDiscoveryGetCurrentVersion","currentIMDSVersion","getCurrentVersion","FAILED_AUTO_DETECTION","currentIMDSVersionResponse","e","ENVIRONMENT_VARIABLE","version","_this2","sendGetRequestAsync","IMDS_ENDPOINT","IMDS_TIMEOUT","_this3","response","length","headers","Metadata"],"sources":["C:/Users/v-dkamali/Documents/AngularMSALAD/microsoft-login/node_modules/@azure/msal-common/dist/authority/RegionDiscovery.mjs"],"sourcesContent":["/*! @azure/msal-common v14.0.3 2023-09-05 */\n'use strict';\nimport { Constants, ResponseCodes, RegionDiscoverySources } from '../utils/Constants.mjs';\nimport { PerformanceEvents } from '../telemetry/performance/PerformanceEvent.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nclass RegionDiscovery {\n    constructor(networkInterface, performanceClient, correlationId) {\n        this.networkInterface = networkInterface;\n        this.performanceClient = performanceClient;\n        this.correlationId = correlationId;\n    }\n    /**\n     * Detect the region from the application's environment.\n     *\n     * @returns Promise<string | null>\n     */\n    async detectRegion(environmentRegion, regionDiscoveryMetadata) {\n        this.performanceClient?.addQueueMeasurement(PerformanceEvents.RegionDiscoveryDetectRegion, this.correlationId);\n        // Initialize auto detected region with the region from the envrionment\n        let autodetectedRegionName = environmentRegion;\n        // Check if a region was detected from the environment, if not, attempt to get the region from IMDS\n        if (!autodetectedRegionName) {\n            const options = RegionDiscovery.IMDS_OPTIONS;\n            try {\n                this.performanceClient?.setPreQueueTime(PerformanceEvents.RegionDiscoveryGetRegionFromIMDS, this.correlationId);\n                const localIMDSVersionResponse = await this.getRegionFromIMDS(Constants.IMDS_VERSION, options);\n                if (localIMDSVersionResponse.status ===\n                    ResponseCodes.httpSuccess) {\n                    autodetectedRegionName = localIMDSVersionResponse.body;\n                    regionDiscoveryMetadata.region_source =\n                        RegionDiscoverySources.IMDS;\n                }\n                // If the response using the local IMDS version failed, try to fetch the current version of IMDS and retry.\n                if (localIMDSVersionResponse.status ===\n                    ResponseCodes.httpBadRequest) {\n                    this.performanceClient?.setPreQueueTime(PerformanceEvents.RegionDiscoveryGetCurrentVersion, this.correlationId);\n                    const currentIMDSVersion = await this.getCurrentVersion(options);\n                    if (!currentIMDSVersion) {\n                        regionDiscoveryMetadata.region_source =\n                            RegionDiscoverySources.FAILED_AUTO_DETECTION;\n                        return null;\n                    }\n                    this.performanceClient?.setPreQueueTime(PerformanceEvents.RegionDiscoveryGetRegionFromIMDS, this.correlationId);\n                    const currentIMDSVersionResponse = await this.getRegionFromIMDS(currentIMDSVersion, options);\n                    if (currentIMDSVersionResponse.status ===\n                        ResponseCodes.httpSuccess) {\n                        autodetectedRegionName =\n                            currentIMDSVersionResponse.body;\n                        regionDiscoveryMetadata.region_source =\n                            RegionDiscoverySources.IMDS;\n                    }\n                }\n            }\n            catch (e) {\n                regionDiscoveryMetadata.region_source =\n                    RegionDiscoverySources.FAILED_AUTO_DETECTION;\n                return null;\n            }\n        }\n        else {\n            regionDiscoveryMetadata.region_source =\n                RegionDiscoverySources.ENVIRONMENT_VARIABLE;\n        }\n        // If no region was auto detected from the environment or from the IMDS endpoint, mark the attempt as a FAILED_AUTO_DETECTION\n        if (!autodetectedRegionName) {\n            regionDiscoveryMetadata.region_source =\n                RegionDiscoverySources.FAILED_AUTO_DETECTION;\n        }\n        return autodetectedRegionName || null;\n    }\n    /**\n     * Make the call to the IMDS endpoint\n     *\n     * @param imdsEndpointUrl\n     * @returns Promise<NetworkResponse<string>>\n     */\n    async getRegionFromIMDS(version, options) {\n        this.performanceClient?.addQueueMeasurement(PerformanceEvents.RegionDiscoveryGetRegionFromIMDS, this.correlationId);\n        return this.networkInterface.sendGetRequestAsync(`${Constants.IMDS_ENDPOINT}?api-version=${version}&format=text`, options, Constants.IMDS_TIMEOUT);\n    }\n    /**\n     * Get the most recent version of the IMDS endpoint available\n     *\n     * @returns Promise<string | null>\n     */\n    async getCurrentVersion(options) {\n        this.performanceClient?.addQueueMeasurement(PerformanceEvents.RegionDiscoveryGetCurrentVersion, this.correlationId);\n        try {\n            const response = await this.networkInterface.sendGetRequestAsync(`${Constants.IMDS_ENDPOINT}?format=json`, options);\n            // When IMDS endpoint is called without the api version query param, bad request response comes back with latest version.\n            if (response.status === ResponseCodes.httpBadRequest &&\n                response.body &&\n                response.body[\"newest-versions\"] &&\n                response.body[\"newest-versions\"].length > 0) {\n                return response.body[\"newest-versions\"][0];\n            }\n            return null;\n        }\n        catch (e) {\n            return null;\n        }\n    }\n}\n// Options for the IMDS endpoint request\nRegionDiscovery.IMDS_OPTIONS = {\n    headers: {\n        Metadata: \"true\",\n    },\n};\n\nexport { RegionDiscovery };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}